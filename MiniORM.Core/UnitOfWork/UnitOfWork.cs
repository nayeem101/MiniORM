using MiniORM.Core.Query;
using MiniORM.Core.Repository;

namespace MiniORM.Core.UnitOfWork;

/// <summary>
/// Unit of Work implementation.
/// 
/// Design Pattern: Unit of Work + Registry
/// - Manages repository instances
/// - Coordinates transaction boundaries
/// - Processes tracked entity changes
/// </summary>
public class UnitOfWork : IUnitOfWork
{
    private readonly DbContext _context;
    private readonly Dictionary<Type, object> _repositories = new Dictionary<Type, object>();
    private bool _disposed;

    public ChangeTracker ChangeTracker { get; } = new ChangeTracker();

    public UnitOfWork(DbContext context)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
    }

    /// <summary>
    /// Gets or creates a repository for the specified entity type.
    /// </summary>
    public IRepository<TEntity> Repository<TEntity>() where TEntity : class, new()
    {
        var type = typeof(TEntity);
        
        if (!_repositories.TryGetValue(type, out var repository))
        {
            repository = new TrackedRepository<TEntity>(_context, ChangeTracker);
            _repositories[type] = repository;
        }

        return (IRepository<TEntity>)repository;
    }

    /// <summary>
    /// Saves all tracked changes to the database.
    /// </summary>
    public int SaveChanges()
    {
        ChangeTracker.DetectChanges();
        var changedEntries = ChangeTracker.GetChangedEntries().ToList();
        var affectedRows = 0;

        foreach (var entry in changedEntries)
        {
            switch (entry.State)
            {
                case EntityState.Added:
                    affectedRows += InsertEntity(entry);
                    break;

                case EntityState.Modified:
                    affectedRows += UpdateEntity(entry);
                    break;

                case EntityState.Deleted:
                    affectedRows += DeleteEntity(entry);
                    break;
            }
        }

        ChangeTracker.AcceptAllChanges();
        return affectedRows;
    }

    private int InsertEntity(EntityEntry entry)
    {
        var metadata = EntityMapper.GetMetadata(entry.EntityType);
        var insertQuery = new InsertQueryBuilder()
            .Into(metadata.TableName);

        foreach (var prop in metadata.GetInsertProperties())
        {
            insertQuery.Value(prop.ColumnName, prop.GetValue(entry.Entity));
        }

        var sql = insertQuery.Build();
        var id = _context.ExecuteScalar(sql, insertQuery.GetParameterTuples());

        // Set the generated ID on the entity
        if (id != null && metadata.PrimaryKey!.IsAutoGenerated)
        {
            var convertedId = Convert.ChangeType(id, metadata.PrimaryKey.PropertyType);
            metadata.PrimaryKey.SetValue(entry.Entity, convertedId);
        }

        return 1;
    }

    private int UpdateEntity(EntityEntry entry)
    {
        var metadata = EntityMapper.GetMetadata(entry.EntityType);
        var updateQuery = new UpdateQueryBuilder()
            .Table(metadata.TableName);

        foreach (var prop in metadata.GetUpdateProperties())
        {
            updateQuery.Set(prop.ColumnName, prop.GetValue(entry.Entity));
        }

        // Add WHERE for primary key
        if (metadata.PrimaryKey != null)
        {
            updateQuery.Where(metadata.PrimaryKey.ColumnName, 
                metadata.PrimaryKey.GetValue(entry.Entity));
        }

        var sql = updateQuery.Build();
        return _context.ExecuteNonQuery(sql, updateQuery.GetParameterTuples());
    }

    private int DeleteEntity(EntityEntry entry)
    {
        var metadata = EntityMapper.GetMetadata(entry.EntityType);
        var deleteQuery = new DeleteQueryBuilder()
            .From(metadata.TableName);

        if (metadata.PrimaryKey != null)
        {
            deleteQuery.Where(metadata.PrimaryKey.ColumnName, 
                metadata.PrimaryKey.GetValue(entry.Entity));
        }

        var sql = deleteQuery.Build();
        return _context.ExecuteNonQuery(sql, deleteQuery.GetParameterTuples());
    }

    public void BeginTransaction()
    {
        _context.BeginTransaction();
    }

    public void Commit()
    {
        _context.Commit();
    }

    public void Rollback()
    {
        _context.Rollback();
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            ChangeTracker.Clear();
        }

        _disposed = true;
    }
}
