using System.Reflection;
using MiniORM.Core.Attributes;

namespace MiniORM.Core;

/// <summary>
/// Holds metadata about a single property.
/// </summary>
public class PropertyMetadata
{
    public PropertyInfo PropertyInfo { get; }
    public string PropertyName { get; }
    public string ColumnName { get; }
    public Type PropertyType { get; }
    public bool IsPrimaryKey { get; internal set; }
    public bool IsAutoGenerated { get; internal set; }
    public bool IsNullable { get; }
    public bool IsNotMapped { get; }
    public bool IsForeignKey { get; }
    public Type? ForeignKeyType { get; }
    public int MaxLength { get; }
    public string? DbType { get; }

    public PropertyMetadata(PropertyInfo propertyInfo)
    {
        PropertyInfo = propertyInfo ?? throw new ArgumentNullException(nameof(propertyInfo));
        PropertyName = propertyInfo.Name;
        PropertyType = propertyInfo.PropertyType;

        // Check for [NotMapped]
        IsNotMapped = propertyInfo.GetCustomAttribute<NotMappedAttribute>() != null;

        if (IsNotMapped) 
        {
            ColumnName = PropertyName;
            return;
        }

        // Check for [Column]
        var columnAttr = propertyInfo.GetCustomAttribute<ColumnAttribute>();
        ColumnName = columnAttr?.Name ?? PropertyName;
        MaxLength = columnAttr?.MaxLength ?? -1;
        DbType = columnAttr?.DbType;

        // Determine nullability
        IsNullable = columnAttr?.IsNullable ?? IsNullableType(PropertyType);

        // Check for [PrimaryKey]
        var pkAttr = propertyInfo.GetCustomAttribute<PrimaryKeyAttribute>();
        IsPrimaryKey = pkAttr != null;
        IsAutoGenerated = pkAttr?.AutoGenerate ?? false;

        // Check for [ForeignKey]
        var fkAttr = propertyInfo.GetCustomAttribute<ForeignKeyAttribute>();
        IsForeignKey = fkAttr != null;
        ForeignKeyType = fkAttr?.RelatedEntity;
    }

    /// <summary>
    /// Determines if a type is nullable (reference type or Nullable<T>).
    /// </summary>
    private static bool IsNullableType(Type type)
    {
        // Reference types are always nullable
        if (!type.IsValueType) return true;

        // Check for Nullable<T>
        return Nullable.GetUnderlyingType(type) != null;
    }

    /// <summary>
    /// Gets the value of this property from an entity instance.
    /// </summary>
    public object? GetValue(object entity)
    {
        return PropertyInfo.GetValue(entity);
    }

    /// <summary>
    /// Sets the value of this property on an entity instance.
    /// </summary>
    public void SetValue(object entity, object? value)
    {
        // Handle DBNull
        if (value == DBNull.Value)
        {
            value = null;
        }

        // Handle type conversion
        if (value != null && !PropertyType.IsAssignableFrom(value.GetType()))
        {
            value = ConvertValue(value, PropertyType);
        }

        PropertyInfo.SetValue(entity, value);
    }

    /// <summary>
    /// Converts a value to the target type.
    /// </summary>
    private static object? ConvertValue(object value, Type targetType)
    {
        // Handle Nullable<T>
        var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

        // Handle enums
        if (underlyingType.IsEnum)
        {
            return Enum.ToObject(underlyingType, value);
        }

        // Handle Guid
        if (underlyingType == typeof(Guid) && value is string stringValue)
        {
            return Guid.Parse(stringValue);
        }

        // Use Convert for other types
        return Convert.ChangeType(value, underlyingType);
    }
}
