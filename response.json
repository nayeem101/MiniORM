{
    "id": "6931ca6f00f33e8394f49977",
    "userId": "68152fb6231f6f2d76a5d7b8",
    "title": "C# ORM Implementation Guide",
    "totalTokens": 72685,
    "isStarred": true,
    "createdAt": "2025-12-04T17:52:47.618Z",
    "updatedAt": "2025-12-05T06:05:12.961Z",
    "isArchived": false,
    "models": [
        "claude-opus-4-5-20251101"
    ],
    "turns": [
        {
            "prompt": {
                "text": "help me learn c# by implementing a simple ORM for sql dbs. step by step in detail with the explanations of design patterns used in the implementation.",
                "images": [],
                "tokenCount": 31,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# - A Complete Step-by-Step Guide\n\nThis is an excellent way to learn C#! We'll build a mini ORM from scratch, covering essential concepts and design patterns along the way.\n\n## Table of Contents\n1. [Overview & Architecture](#1-overview--architecture)\n2. [Project Setup](#2-project-setup)\n3. [Custom Attributes (Metadata Pattern)](#3-custom-attributes)\n4. [Entity Base Class](#4-entity-base-class)\n5. [Reflection-Based Mapper](#5-reflection-based-mapper)\n6. [Database Connection Manager (Singleton Pattern)](#6-database-connection-manager)\n7. [SQL Query Builder (Builder Pattern)](#7-sql-query-builder)\n8. [Generic Repository (Repository Pattern)](#8-generic-repository)\n9. [Unit of Work Pattern](#9-unit-of-work-pattern)\n10. [Expression Parser for LINQ-like Queries](#10-expression-parser)\n11. [Putting It All Together](#11-complete-example)\n\n---\n\n## 1. Overview & Architecture\n\n### What is an ORM?\n\nAn **Object-Relational Mapper** bridges the gap between object-oriented programming and relational databases by:\n- Mapping classes to database tables\n- Mapping properties to columns\n- Converting objects to SQL and vice versa\n\n### Architecture Diagram\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        Application Layer                         │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐  │\n│  │   Entity    │    │  Repository │    │    Unit of Work     │  │\n│  │   Classes   │    │   Pattern   │    │      Pattern        │  │\n│  └──────┬──────┘    └──────┬──────┘    └──────────┬──────────┘  │\n│         │                  │                       │             │\n│         ▼                  ▼                       ▼             │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │                      ORM Core                                ││\n│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐   ││\n│  │  │  Attributes  │  │   Mapper     │  │  Query Builder   │   ││\n│  │  │  (Metadata)  │  │ (Reflection) │  │    (Builder)     │   ││\n│  │  └──────────────┘  └──────────────┘  └──────────────────┘   ││\n│  └─────────────────────────────────────────────────────────────┘│\n│                              │                                   │\n│                              ▼                                   │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │              Database Connection Manager                     ││\n│  │                    (Singleton Pattern)                       ││\n│  └─────────────────────────────────────────────────────────────┘│\n│                              │                                   │\n└──────────────────────────────┼───────────────────────────────────┘\n                               ▼\n                    ┌─────────────────────┐\n                    │   SQL Database      │\n                    │ (SQL Server/SQLite) │\n                    └─────────────────────┘\n```\n\n---\n\n## 2. Project Setup\n\n### Create the Solution Structure\n\n```bash\n# Create solution\ndotnet new sln -n MiniORM\n\n# Create projects\ndotnet new classlib -n MiniORM.Core\ndotnet new console -n MiniORM.Demo\n\n# Add to solution\ndotnet sln add MiniORM.Core\ndotnet sln add MiniORM.Demo\n\n# Add reference\ndotnet add MiniORM.Demo reference MiniORM.Core\n\n# Add required packages\ncd MiniORM.Core\ndotnet add package Microsoft.Data.SqlClient\ndotnet add package System.Data.SQLite  # For SQLite support\n```\n\n### Project Structure\n\n```\nMiniORM/\n├── MiniORM.Core/\n│   ├── Attributes/\n│   │   ├── TableAttribute.cs\n│   │   ├── ColumnAttribute.cs\n│   │   ├── PrimaryKeyAttribute.cs\n│   │   └── ForeignKeyAttribute.cs\n│   ├── Core/\n│   │   ├── EntityBase.cs\n│   │   ├── EntityMapper.cs\n│   │   └── EntityMetadata.cs\n│   ├── Connection/\n│   │   ├── IDbConnectionFactory.cs\n│   │   └── DbConnectionFactory.cs\n│   ├── Query/\n│   │   ├── SqlQueryBuilder.cs\n│   │   ├── WhereClauseBuilder.cs\n│   │   └── ExpressionParser.cs\n│   ├── Repository/\n│   │   ├── IRepository.cs\n│   │   └── Repository.cs\n│   └── UnitOfWork/\n│       ├── IUnitOfWork.cs\n│       ├── UnitOfWork.cs\n│       └── ChangeTracker.cs\n└── MiniORM.Demo/\n    └── Program.cs\n```\n\n---\n\n## 3. Custom Attributes (Metadata Pattern)\n\n### Design Pattern: Metadata/Decorator Pattern\n\n**Purpose**: Attach metadata to classes and properties that our ORM will read at runtime using reflection.\n\n**Why Use Attributes?**\n- Declarative way to define mappings\n- Keeps mapping close to the entity definition\n- Clean separation of concerns\n\n### TableAttribute.cs\n\n```csharp\nusing System;\n\nnamespace MiniORM.Core.Attributes\n{\n    /// <summary>\n    /// Maps a class to a database table.\n    /// This attribute uses the Metadata pattern to attach \n    /// mapping information to entity classes.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]\n    public class TableAttribute : Attribute\n    {\n        /// <summary>\n        /// The name of the database table.\n        /// </summary>\n        public string Name { get; }\n        \n        /// <summary>\n        /// Optional schema name (e.g., \"dbo\" in SQL Server).\n        /// </summary>\n        public string Schema { get; set; } = \"dbo\";\n\n        public TableAttribute(string name)\n        {\n            // Null check with throw expression (C# 7+)\n            Name = name ?? throw new ArgumentNullException(nameof(name));\n        }\n\n        /// <summary>\n        /// Gets the fully qualified table name.\n        /// </summary>\n        public string FullTableName => string.IsNullOrEmpty(Schema) \n            ? $\"[{Name}]\" \n            : $\"[{Schema}].[{Name}]\";\n    }\n}\n```\n\n### ColumnAttribute.cs\n\n```csharp\nusing System;\n\nnamespace MiniORM.Core.Attributes\n{\n    /// <summary>\n    /// Maps a property to a database column.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]\n    public class ColumnAttribute : Attribute\n    {\n        /// <summary>\n        /// The name of the database column.\n        /// If not specified, the property name is used.\n        /// </summary>\n        public string Name { get; }\n        \n        /// <summary>\n        /// The SQL data type (e.g., \"NVARCHAR(100)\", \"INT\").\n        /// </summary>\n        public string DbType { get; set; }\n        \n        /// <summary>\n        /// Whether the column allows NULL values.\n        /// </summary>\n        public bool IsNullable { get; set; } = true;\n        \n        /// <summary>\n        /// Maximum length for string columns.\n        /// </summary>\n        public int MaxLength { get; set; } = -1;\n\n        public ColumnAttribute() { }\n\n        public ColumnAttribute(string name)\n        {\n            Name = name;\n        }\n    }\n}\n```\n\n### PrimaryKeyAttribute.cs\n\n```csharp\nusing System;\n\nnamespace MiniORM.Core.Attributes\n{\n    /// <summary>\n    /// Marks a property as the primary key.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]\n    public class PrimaryKeyAttribute : Attribute\n    {\n        /// <summary>\n        /// Whether the primary key is auto-generated (IDENTITY in SQL Server).\n        /// </summary>\n        public bool AutoGenerate { get; set; } = true;\n        \n        /// <summary>\n        /// The name of the sequence (for databases that use sequences).\n        /// </summary>\n        public string SequenceName { get; set; }\n    }\n}\n```\n\n### ForeignKeyAttribute.cs\n\n```csharp\nusing System;\n\nnamespace MiniORM.Core.Attributes\n{\n    /// <summary>\n    /// Marks a property as a foreign key relationship.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]\n    public class ForeignKeyAttribute : Attribute\n    {\n        /// <summary>\n        /// The type of the related entity.\n        /// </summary>\n        public Type RelatedEntity { get; }\n        \n        /// <summary>\n        /// The property name on the related entity (usually the primary key).\n        /// </summary>\n        public string RelatedProperty { get; set; } = \"Id\";\n\n        public ForeignKeyAttribute(Type relatedEntity)\n        {\n            RelatedEntity = relatedEntity ?? throw new ArgumentNullException(nameof(relatedEntity));\n        }\n    }\n}\n```\n\n### NotMappedAttribute.cs\n\n```csharp\nusing System;\n\nnamespace MiniORM.Core.Attributes\n{\n    /// <summary>\n    /// Excludes a property from database mapping.\n    /// Useful for computed properties or navigation properties.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]\n    public class NotMappedAttribute : Attribute\n    {\n    }\n}\n```\n\n---\n\n## 4. Entity Base Class\n\n### EntityBase.cs\n\n```csharp\nusing System;\nusing System.ComponentModel;\nusing System.Runtime.CompilerServices;\nusing MiniORM.Core.Attributes;\n\nnamespace MiniORM.Core\n{\n    /// <summary>\n    /// Base class for all entities.\n    /// Implements INotifyPropertyChanged for change tracking.\n    /// \n    /// Design Pattern: Template Method Pattern\n    /// - Provides a skeleton for entity behavior\n    /// - Subclasses fill in specific details (properties)\n    /// </summary>\n    public abstract class EntityBase : INotifyPropertyChanged\n    {\n        // Event for property change notifications (used by change tracker)\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        /// <summary>\n        /// Entity state for tracking changes.\n        /// </summary>\n        [NotMapped]\n        public EntityState State { get; internal set; } = EntityState.Detached;\n\n        /// <summary>\n        /// Raises the PropertyChanged event.\n        /// The CallerMemberName attribute automatically captures the property name.\n        /// </summary>\n        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)\n        {\n            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n            \n            // Mark as modified when a property changes (if already attached)\n            if (State == EntityState.Unchanged)\n            {\n                State = EntityState.Modified;\n            }\n        }\n\n        /// <summary>\n        /// Helper method to set property values with change notification.\n        /// </summary>\n        /// <typeparam name=\"T\">The type of the property.</typeparam>\n        /// <param name=\"field\">Reference to the backing field.</param>\n        /// <param name=\"value\">The new value.</param>\n        /// <param name=\"propertyName\">The property name (auto-captured).</param>\n        /// <returns>True if the value changed, false otherwise.</returns>\n        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)\n        {\n            // Check if value actually changed\n            if (EqualityComparer<T>.Default.Equals(field, value))\n            {\n                return false;\n            }\n\n            field = value;\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n    }\n\n    /// <summary>\n    /// Represents the state of an entity in the context.\n    /// </summary>\n    public enum EntityState\n    {\n        /// <summary>\n        /// Entity is not being tracked.\n        /// </summary>\n        Detached,\n        \n        /// <summary>\n        /// Entity exists in the database and has not been modified.\n        /// </summary>\n        Unchanged,\n        \n        /// <summary>\n        /// Entity is new and will be inserted.\n        /// </summary>\n        Added,\n        \n        /// <summary>\n        /// Entity has been modified and will be updated.\n        /// </summary>\n        Modified,\n        \n        /// <summary>\n        /// Entity will be deleted.\n        /// </summary>\n        Deleted\n    }\n}\n```\n\n---\n\n## 5. Reflection-Based Mapper\n\n### Design Pattern: Reflection + Caching\n\n**Purpose**: Read entity metadata at runtime and cache it for performance.\n\n### EntityMetadata.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing MiniORM.Core.Attributes;\n\nnamespace MiniORM.Core\n{\n    /// <summary>\n    /// Holds cached metadata about an entity type.\n    /// This class uses the Flyweight Pattern - we create one instance\n    /// per entity type and reuse it.\n    /// </summary>\n    public class EntityMetadata\n    {\n        public Type EntityType { get; }\n        public string TableName { get; }\n        public string Schema { get; }\n        public string FullTableName { get; }\n        public PropertyMetadata PrimaryKey { get; }\n        public IReadOnlyList<PropertyMetadata> Properties { get; }\n        public IReadOnlyList<PropertyMetadata> MappedProperties { get; }\n\n        public EntityMetadata(Type entityType)\n        {\n            EntityType = entityType ?? throw new ArgumentNullException(nameof(entityType));\n\n            // Get table name from attribute or use class name\n            var tableAttr = entityType.GetCustomAttribute<TableAttribute>();\n            TableName = tableAttr?.Name ?? entityType.Name;\n            Schema = tableAttr?.Schema ?? \"dbo\";\n            FullTableName = tableAttr?.FullTableName ?? $\"[{TableName}]\";\n\n            // Get all public instance properties\n            var properties = entityType\n                .GetProperties(BindingFlags.Public | BindingFlags.Instance)\n                .Where(p => p.CanRead && p.CanWrite)\n                .Select(p => new PropertyMetadata(p))\n                .ToList();\n\n            Properties = properties;\n            MappedProperties = properties.Where(p => !p.IsNotMapped).ToList();\n            PrimaryKey = properties.FirstOrDefault(p => p.IsPrimaryKey);\n\n            // Validation\n            if (PrimaryKey == null)\n            {\n                // Try to find a property named \"Id\" or \"{EntityName}Id\"\n                PrimaryKey = properties.FirstOrDefault(p => \n                    p.PropertyName.Equals(\"Id\", StringComparison.OrdinalIgnoreCase) ||\n                    p.PropertyName.Equals($\"{entityType.Name}Id\", StringComparison.OrdinalIgn",
                    "images": [],
                    "tokenCount": 3442,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants to learn C# by implementing a simple ORM (Object-Relational Mapper) for SQL databases. This is a great learning exercise because it touches on many important C# concepts and design patterns.\n\nLet me structure this step-by-step, explaining the design patterns as we go:\n\n1. **Introduction to ORMs** - What they do and why\n2. **Project Setup** - Creating the solution structure\n3. **Core Concepts and Patterns**:\n   - Repository Pattern\n   - Unit of Work Pattern\n   - Active Record vs Data Mapper patterns\n   - Reflection for mapping\n   - Attributes for metadata\n   - Generic constraints\n   - Expression trees for querying\n\n4. **Step-by-step Implementation**:\n   - Step 1: Define custom attributes for table/column mapping\n   - Step 2: Create a base entity class\n   - Step 3: Create a DbContext/Connection manager\n   - Step 4: Implement reflection-based mapping\n   - Step 5: Build SQL query generators\n   - Step 6: Implement CRUD operations\n   - Step 7: Add a simple query builder\n   - Step 8: Implement the Repository pattern\n   - Step 9: Add Unit of Work pattern\n   - Step 10: Add basic change tracking\n\nLet me write this out comprehensively with code examples and explanations.",
                        "signature": "EsQKCkYIChgCKkDVXiF2JVFhBJrCu7glbhWTeBd2rnoal245BLitLdnUg+lgPy4oiGMYpBJrlffbY2T1lrfKUK3DOPVheCE1iC/mEgyeLUeV1KBgNiWs0xEaDBjov20RSg0+NTNtWCIwwStxvH+SxjDJZVhE2W7Ni60mq/gvB5b+0BTKFtKUDPELkUGZpyDvdUdqKm3iDWyAKqsJZyv5O2+WjNjDS6lZdOJ1JhjVCCygtLubC0Fzy8I2Nz+De8TrGsnIOUG5ucPIB2RZVqNk84hKzEoGYwkyL60wnXaehucPmat9G516SXUO7CXX0rGgI4FIOCshs3ynkGttscbFoRsHHMaxlXbKmp0T++xgxNL0O2A3QscxVmZiJFEMfcvBKVs/eokr5qGAo48cVJ0JqROcebBcxB5xTDZ0ZTlkU+3TaEqTVB0+2RLy0bETrEMZLgM5KKC9GLPCOV2yKGvXBAsBhweiEc9lva4VPlojsKsJnuK0RiKlym+ddJ1/LWq3HCnO1YyaEsx88k3dxnmw17eXEurihiVAI4yRANfZ1Nx2dho2hYXWhuIEHrg2BGyaJEBr2B/rYmXXm01qjJFJ25YhDjGhbr7raTKXuXfOOh1LcaSkcara4ynyksW683xBZ+TO9ILzrQ2oTfZ0CTHIymso8cOROS9R4hSx0vfGy87wQkSotbGNqI/8ODEF1nfdNsCkGu2knVTq3VPIKOaXiQmTd15PCQIsWnK4Kp4b4pWJsKInyEYv+SmqcfvsqiERX+/Hks+hqSD198pyUXIU646C3I0f0gS2/YRo/Vo7Mroh3a4SYttcIcfjUZRk/OtYt4t72R3NbO87j5nE0vHR3FDI0tLHYOMsQd4o4jbQSmUlds4kBXpY9WBQvvkX5bJ+cfCbFL99MbA3W9zJTm5JisvXDlx0Rs9V8fW1gUl68eBupuK6wXjkfUBHbKmTzSPO/+vAM7niIdMlE1opjRmHcAaw1+V1aB87gv/QGLc4cDN8mfUJlMMKCwEi8yP/G4/2gm6QZKCbI6erMalCEJ6WIhuNaY49S2mnpQiEZ2KgQ5+Ty304nI37PJ4bxmvxBPG1d4hgLMB8Wv4BL8KZ9aU1GJ6vs3EpSH8iJ32yCgZ1Dz+XhC/THOfneSXE5E9JSeBxosIOKNsWVPMxrQZOAtmMocSWCd544sy0QuDEJaK+UVJCNmIwF0E2pL+QN3gFxFKAG6YvkXlMqlbOh54knImAWl9Qk2DArw52c6mpMKnplKLDsh2inqkWKNv1ZDST9OXii5JzxYZqPnPY1NoifCedmY91z5u1zvUTwLVn4ce6XIyfYxHnpxqkeqnVWT9oSP3L0WTpprZfB8bWQlD2oAGd78AelGUwD+ShRQ0SocHMA1NLDq/0D1AkktR1k7imTr6qetH6u0K5QnDPhcyppxsCdHT2PLs92PwVwxpm6epw+GYdH8WFKr4v5iNV5aFCZ7ORBQGjRTp8VDoUdimqw2zLUb2IvvSoBZDqH3oI6DMOOsEbN3DAUZtlurNbhb2LPXog23YNosk2Z1C33IZjGl9Isz4e+plXiMYBRWTuj2PQnrpiSVyCXTdbA6a/bZWpeW6KdfLrZGYgo3LIG2KuFNTi+gUbsRy0jQIjrNKRfMOUNFCYfkAWegi8Gw9PIb8p2WSVRm/VBM/rr3b8loYdBJ6Ihiks8WKdPeLnfg3Njsp29CEZwo75ArRkrYfYWiWHHK8vDl5d1QyaLuBA6LHXNtHIgn8OOfB4KEU9lTOpajJsvtBlLqSx3kmYfJa7uZQwRiyeO6BwF3cK5hgB"
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 0,
            "parentIdx": -1,
            "childrenIdxs": [
                1
            ],
            "createdAt": "2025-12-04T17:53:55.737Z",
            "updatedAt": "2025-12-04T17:54:18.510Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nLet me continue from where we left off in the `EntityMetadata.cs` file:\n\n### EntityMetadata.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing MiniORM.Core.Attributes;\n\nnamespace MiniORM.Core\n{\n    /// <summary>\n    /// Holds cached metadata about an entity type.\n    /// This class uses the Flyweight Pattern - we create one instance\n    /// per entity type and reuse it.\n    /// </summary>\n    public class EntityMetadata\n    {\n        public Type EntityType { get; }\n        public string TableName { get; }\n        public string Schema { get; }\n        public string FullTableName { get; }\n        public PropertyMetadata PrimaryKey { get; }\n        public IReadOnlyList<PropertyMetadata> Properties { get; }\n        public IReadOnlyList<PropertyMetadata> MappedProperties { get; }\n\n        public EntityMetadata(Type entityType)\n        {\n            EntityType = entityType ?? throw new ArgumentNullException(nameof(entityType));\n\n            // Get table name from attribute or use class name\n            var tableAttr = entityType.GetCustomAttribute<TableAttribute>();\n            TableName = tableAttr?.Name ?? entityType.Name;\n            Schema = tableAttr?.Schema ?? \"dbo\";\n            FullTableName = tableAttr?.FullTableName ?? $\"[{TableName}]\";\n\n            // Get all public instance properties\n            var properties = entityType\n                .GetProperties(BindingFlags.Public | BindingFlags.Instance)\n                .Where(p => p.CanRead && p.CanWrite)\n                .Select(p => new PropertyMetadata(p))\n                .ToList();\n\n            Properties = properties;\n            MappedProperties = properties.Where(p => !p.IsNotMapped).ToList();\n            PrimaryKey = properties.FirstOrDefault(p => p.IsPrimaryKey);\n\n            // Validation: Try to find a property named \"Id\" or \"{EntityName}Id\" as convention\n            if (PrimaryKey == null)\n            {\n                PrimaryKey = properties.FirstOrDefault(p => \n                    p.PropertyName.Equals(\"Id\", StringComparison.OrdinalIgnoreCase) ||\n                    p.PropertyName.Equals($\"{entityType.Name}Id\", StringComparison.OrdinalIgnoreCase));\n                \n                if (PrimaryKey != null)\n                {\n                    // Mark it as primary key by convention\n                    PrimaryKey.IsPrimaryKey = true;\n                    PrimaryKey.IsAutoGenerated = true;\n                }\n            }\n\n            if (PrimaryKey == null)\n            {\n                throw new InvalidOperationException(\n                    $\"Entity '{entityType.Name}' must have a primary key. \" +\n                    \"Use [PrimaryKey] attribute or name a property 'Id'.\");\n            }\n        }\n\n        /// <summary>\n        /// Gets properties that should be included in INSERT statements.\n        /// Excludes auto-generated primary keys.\n        /// </summary>\n        public IEnumerable<PropertyMetadata> GetInsertProperties()\n        {\n            return MappedProperties.Where(p => \n                !p.IsPrimaryKey || !p.IsAutoGenerated);\n        }\n\n        /// <summary>\n        /// Gets properties that should be included in UPDATE statements.\n        /// Excludes primary keys.\n        /// </summary>\n        public IEnumerable<PropertyMetadata> GetUpdateProperties()\n        {\n            return MappedProperties.Where(p => !p.IsPrimaryKey);\n        }\n    }\n\n    /// <summary>\n    /// Holds metadata about a single property.\n    /// </summary>\n    public class PropertyMetadata\n    {\n        public PropertyInfo PropertyInfo { get; }\n        public string PropertyName { get; }\n        public string ColumnName { get; }\n        public Type PropertyType { get; }\n        public bool IsPrimaryKey { get; internal set; }\n        public bool IsAutoGenerated { get; internal set; }\n        public bool IsNullable { get; }\n        public bool IsNotMapped { get; }\n        public bool IsForeignKey { get; }\n        public Type ForeignKeyType { get; }\n        public int MaxLength { get; }\n        public string DbType { get; }\n\n        public PropertyMetadata(PropertyInfo propertyInfo)\n        {\n            PropertyInfo = propertyInfo ?? throw new ArgumentNullException(nameof(propertyInfo));\n            PropertyName = propertyInfo.Name;\n            PropertyType = propertyInfo.PropertyType;\n\n            // Check for [NotMapped]\n            IsNotMapped = propertyInfo.GetCustomAttribute<NotMappedAttribute>() != null;\n\n            if (IsNotMapped) return;\n\n            // Check for [Column]\n            var columnAttr = propertyInfo.GetCustomAttribute<ColumnAttribute>();\n            ColumnName = columnAttr?.Name ?? PropertyName;\n            MaxLength = columnAttr?.MaxLength ?? -1;\n            DbType = columnAttr?.DbType;\n            \n            // Determine nullability\n            IsNullable = columnAttr?.IsNullable ?? IsNullableType(PropertyType);\n\n            // Check for [PrimaryKey]\n            var pkAttr = propertyInfo.GetCustomAttribute<PrimaryKeyAttribute>();\n            IsPrimaryKey = pkAttr != null;\n            IsAutoGenerated = pkAttr?.AutoGenerate ?? false;\n\n            // Check for [ForeignKey]\n            var fkAttr = propertyInfo.GetCustomAttribute<ForeignKeyAttribute>();\n            IsForeignKey = fkAttr != null;\n            ForeignKeyType = fkAttr?.RelatedEntity;\n        }\n\n        /// <summary>\n        /// Determines if a type is nullable (reference type or Nullable<T>).\n        /// </summary>\n        private static bool IsNullableType(Type type)\n        {\n            // Reference types are always nullable\n            if (!type.IsValueType) return true;\n            \n            // Check for Nullable<T>\n            return Nullable.GetUnderlyingType(type) != null;\n        }\n\n        /// <summary>\n        /// Gets the value of this property from an entity instance.\n        /// </summary>\n        public object GetValue(object entity)\n        {\n            return PropertyInfo.GetValue(entity);\n        }\n\n        /// <summary>\n        /// Sets the value of this property on an entity instance.\n        /// </summary>\n        public void SetValue(object entity, object value)\n        {\n            // Handle DBNull\n            if (value == DBNull.Value)\n            {\n                value = null;\n            }\n\n            // Handle type conversion\n            if (value != null && !PropertyType.IsAssignableFrom(value.GetType()))\n            {\n                value = ConvertValue(value, PropertyType);\n            }\n\n            PropertyInfo.SetValue(entity, value);\n        }\n\n        /// <summary>\n        /// Converts a value to the target type.\n        /// </summary>\n        private static object ConvertValue(object value, Type targetType)\n        {\n            // Handle Nullable<T>\n            var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;\n\n            // Handle enums\n            if (underlyingType.IsEnum)\n            {\n                return Enum.ToObject(underlyingType, value);\n            }\n\n            // Handle Guid\n            if (underlyingType == typeof(Guid) && value is string stringValue)\n            {\n                return Guid.Parse(stringValue);\n            }\n\n            // Use Convert for other types\n            return Convert.ChangeType(value, underlyingType);\n        }\n    }\n}\n```\n\n### EntityMapper.cs\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Data;\n\nnamespace MiniORM.Core\n{\n    /// <summary>\n    /// Maps between database records and entity objects.\n    /// \n    /// Design Pattern: Flyweight Pattern\n    /// - Caches EntityMetadata instances to avoid repeated reflection\n    /// \n    /// Design Pattern: Object Pool (via caching)\n    /// - Reuses metadata objects across multiple operations\n    /// </summary>\n    public static class EntityMapper\n    {\n        // Thread-safe cache for entity metadata\n        // ConcurrentDictionary provides thread-safety for multi-threaded scenarios\n        private static readonly ConcurrentDictionary<Type, EntityMetadata> _metadataCache \n            = new ConcurrentDictionary<Type, EntityMetadata>();\n\n        /// <summary>\n        /// Gets or creates metadata for an entity type.\n        /// Uses caching to avoid repeated reflection overhead.\n        /// </summary>\n        public static EntityMetadata GetMetadata<TEntity>() where TEntity : class\n        {\n            return GetMetadata(typeof(TEntity));\n        }\n\n        /// <summary>\n        /// Gets or creates metadata for an entity type.\n        /// </summary>\n        public static EntityMetadata GetMetadata(Type entityType)\n        {\n            // GetOrAdd is atomic - ensures we only create metadata once per type\n            return _metadataCache.GetOrAdd(entityType, type => new EntityMetadata(type));\n        }\n\n        /// <summary>\n        /// Maps a DataReader row to an entity instance.\n        /// </summary>\n        /// <typeparam name=\"TEntity\">The entity type.</typeparam>\n        /// <param name=\"reader\">The data reader positioned at a row.</param>\n        /// <returns>A populated entity instance.</returns>\n        public static TEntity MapFromReader<TEntity>(IDataReader reader) where TEntity : class, new()\n        {\n            var metadata = GetMetadata<TEntity>();\n            var entity = new TEntity();\n\n            // Get column names from the reader for efficient lookup\n            var columnNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            for (int i = 0; i < reader.FieldCount; i++)\n            {\n                columnNames.Add(reader.GetName(i));\n            }\n\n            // Map each property\n            foreach (var property in metadata.MappedProperties)\n            {\n                if (columnNames.Contains(property.ColumnName))\n                {\n                    var ordinal = reader.GetOrdinal(property.ColumnName);\n                    var value = reader.IsDBNull(ordinal) ? null : reader.GetValue(ordinal);\n                    property.SetValue(entity, value);\n                }\n            }\n\n            // Set entity state to Unchanged (it came from the database)\n            if (entity is EntityBase entityBase)\n            {\n                entityBase.State = EntityState.Unchanged;\n            }\n\n            return entity;\n        }\n\n        /// <summary>\n        /// Maps multiple DataReader rows to a list of entities.\n        /// </summary>\n        public static List<TEntity> MapAllFromReader<TEntity>(IDataReader reader) where TEntity : class, new()\n        {\n            var results = new List<TEntity>();\n\n            while (reader.Read())\n            {\n                results.Add(MapFromReader<TEntity>(reader));\n            }\n\n            return results;\n        }\n\n        /// <summary>\n        /// Maps a DataRow to an entity instance.\n        /// </summary>\n        public static TEntity MapFromDataRow<TEntity>(DataRow row) where TEntity : class, new()\n        {\n            var metadata = GetMetadata<TEntity>();\n            var entity = new TEntity();\n\n            foreach (var property in metadata.MappedProperties)\n            {\n                if (row.Table.Columns.Contains(property.ColumnName))\n                {\n                    var value = row[property.ColumnName];\n                    property.SetValue(entity, value == DBNull.Value ? null : value);\n                }\n            }\n\n            if (entity is EntityBase entityBase)\n            {\n                entityBase.State = EntityState.Unchanged;\n            }\n\n            return entity;\n        }\n\n        /// <summary>\n        /// Converts an entity to a dictionary of column names and values.\n        /// Useful for generating SQL parameters.\n        /// </summary>\n        public static Dictionary<string, object> ToDictionary<TEntity>(TEntity entity) where TEntity : class\n        {\n            var metadata = GetMetadata<TEntity>();\n            var dict = new Dictionary<string, object>();\n\n            foreach (var property in metadata.MappedProperties)\n            {\n                dict[property.ColumnName] = property.GetValue(entity) ?? DBNull.Value;\n            }\n\n            return dict;\n        }\n\n        /// <summary>\n        /// Clears the metadata cache. Useful for testing or dynamic schema changes.\n        /// </summary>\n        public static void ClearCache()\n        {\n            _metadataCache.Clear();\n        }\n    }\n}\n```\n\n---\n\n## 6. Database Connection Manager (Singleton Pattern)\n\n### Design Pattern: Singleton + Factory\n\n**Purpose**: \n- Manage database connections centrally\n- Ensure consistent connection handling\n- Support multiple database providers\n\n### IDbConnectionFactory.cs\n\n```csharp\nusing System.Data;\n\nnamespace MiniORM.Core.Connection\n{\n    /// <summary>\n    /// Factory interface for creating database connections.\n    /// \n    /// Design Pattern: Abstract Factory\n    /// - Allows different implementations for different databases\n    /// </summary>\n    public interface IDbConnectionFactory\n    {\n        /// <summary>\n        /// Creates a new database connection.\n        /// </summary>\n        IDbConnection CreateConnection();\n\n        /// <summary>\n        /// Creates and opens a new database connection.\n        /// </summary>\n        IDbConnection CreateOpenConnection();\n\n        /// <summary>\n        /// Gets the connection string.\n        /// </summary>\n        string ConnectionString { get; }\n\n        /// <summary>\n        /// Gets the database provider name.\n        /// </summary>\n        string ProviderName { get; }\n    }\n}\n```\n\n### DbConnectionFactory.cs\n\n```csharp\nusing System;\nusing System.Data;\nusing Microsoft.Data.SqlClient;\n\nnamespace MiniORM.Core.Connection\n{\n    /// <summary>\n    /// SQL Server connection factory implementation.\n    /// \n    /// Design Pattern: Factory Method\n    /// - Encapsulates connection creation logic\n    /// </summary>\n    public class SqlConnectionFactory : IDbConnectionFactory\n    {\n        public string ConnectionString { get; }\n        public string ProviderName => \"Microsoft.Data.SqlClient\";\n\n        public SqlConnectionFactory(string connectionString)\n        {\n            ConnectionString = connectionString \n                ?? throw new ArgumentNullException(nameof(connectionString));\n        }\n\n        public IDbConnection CreateConnection()\n        {\n            return new SqlConnection(ConnectionString);\n        }\n\n        public IDbConnection CreateOpenConnection()\n        {\n            var connection = CreateConnection();\n            connection.Open();\n            return connection;\n        }\n    }\n\n    /// <summary>\n    /// SQLite connection factory implementation.\n    /// </summary>\n    public class SqliteConnectionFactory : IDbConnectionFactory\n    {\n        public string ConnectionString { get; }\n        public string ProviderName => \"System.Data.SQLite\";\n\n        public SqliteConnectionFactory(string connectionString)\n        {\n            ConnectionString = connectionString \n                ?? throw new ArgumentNullException(nameof(connectionString));\n        }\n\n        public IDbConnection CreateConnection()\n        {\n            // Using System.Data.SQLite\n            return new System.Data.SQLite.SQLiteConnection(ConnectionString);\n        }\n\n        public IDbConnection CreateOpenConnection()\n        {\n            var connection = CreateConnection();\n            connection.Open();\n            return connection;\n        }\n    }\n}\n```\n\n### DbContext.cs\n\n```csharp\nusing System;\nusing System.Data;\nusing MiniORM.Core.Connection;\n\nnamespace MiniORM.Core\n{\n    /// <summary>\n    /// Database context that manages connections and provides a gateway to the database.\n    /// \n    /// Design Pattern: Singleton (optional) + Facade\n    /// - Provides a simplified interface to the ORM components\n    /// - Can be used as a singleton or instantiated per request\n    /// </summary>\n    public class DbContext : IDisposable\n    {\n        private readonly IDbConnectionFactory _connectionFactory;\n        private IDbConnection _connection;\n        private IDbTransaction _transaction;\n        private bool _disposed;\n\n        // Static instance for Singleton pattern (optional usage)\n        private static DbContext _instance;\n        private static readonly object _lock = new object();\n\n        public IDbConnectionFactory ConnectionFactory => _connectionFactory;\n\n        /// <summary>\n        /// Creates a new DbContext with the specified connection factory.\n        /// </summary>\n        public DbContext(IDbConnectionFactory connectionFactory)\n        {\n            _connectionFactory = connectionFactory \n                ?? throw new ArgumentNullException(nameof(connectionFactory));\n        }\n\n        /// <summary>\n        /// Gets or creates a singleton instance.\n        /// Thread-safe implementation using double-check locking.\n        /// </summary>\n        public static DbContext GetInstance(IDbConnectionFactory connectionFactory)\n        {\n            if (_instance == null)\n            {\n                lock (_lock)\n                {\n                    if (_instance == null)\n                    {\n                        _instance = new DbContext(connectionFactory);\n                    }\n                }\n            }\n            return _instance;\n        }\n\n        /// <summary>\n        /// Gets or creates the current connection.\n        /// </summary>\n        public IDbConnection GetConnection()\n        {\n            if (_connection == null)\n            {\n                _connection = _connectionFactory.CreateConnection();\n            }\n\n            if (_connection.State != ConnectionState.Open)\n            {\n                _connection.Open();\n            }\n\n            return _connection;\n        }\n\n        /// <summary>\n        /// Begins a new transaction.\n        /// </summary>\n        public IDbTransaction BeginTransaction(IsolationLevel isolationLevel = IsolationLevel.ReadCommitted)\n        {\n            if (_transaction != null)\n            {\n                throw new InvalidOperationException(\"A transaction is already in progress.\");\n            }\n\n            _transaction = GetConnection().BeginTransaction(isolationLevel);\n            return _transaction;\n        }\n\n        /// <summary>\n        /// Gets the current transaction, if any.\n        /// </summary>\n        public IDbTransaction CurrentTransaction => _transaction;\n\n        /// <summary>\n        /// Commits the current transaction.\n        /// </summary>\n        public void Commit()\n        {\n            if (_transaction == null)\n            {\n                throw new InvalidOperationException(\"No transaction is in progress.\");\n            }\n\n            _transaction.Commit();\n            _transaction.Dispose();\n            _transaction = null;\n        }\n\n        /// <summary>\n        /// Rolls back the current transaction.\n        /// </summary>\n        public void Rollback()\n        {\n            if (_transaction == null)\n            {\n                throw new InvalidOperationException(\"No transaction is in progress.\");\n            }\n\n            _transaction.Rollback();\n            _transaction.Dispose();\n            _transaction = null;\n        }\n\n        /// <summary>\n        /// Creates a new command associated with the current connection and transaction.\n        /// </summary>\n        public IDbCommand CreateCommand()\n        {\n            var command = GetConnection().CreateCommand();\n            command.Transaction = _transaction;\n            return command;\n        }\n\n        /// <summary>\n        /// Executes a non-query SQL command.\n        /// </summary>\n        public int ExecuteNonQuery(string sql, params (string name, object value)[] parameters)\n        {\n            using var command = CreateCommand();\n            command.CommandText = sql;\n            \n            foreach (var (name, value) in parameters)\n            {\n                var param = command.CreateParameter();\n                param.ParameterName = name;\n                param.Value = value ?? DBNull.Value;\n                command.Parameters.Add(param);\n            }\n\n            return command.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// Executes a scalar SQL command.\n        /// </summary>\n        public object ExecuteScalar(string sql, params (string name, object value)[] parameters)\n        {\n            using var command = CreateCommand();\n            command.CommandText = sql;\n            \n            foreach (var (name, value) in parameters)\n            {\n                var param = command.CreateParameter();\n                param.ParameterName = name;\n                param.Value = value ?? DBNull.Value;\n                command.Parameters.Add(param);\n            }\n\n            return command.ExecuteScalar();\n        }\n\n        /// <summary>\n        /// Disposes resources.\n        /// </summary>\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (_disposed) return;\n\n            if (disposing)\n            {\n                _transaction?.Dispose();\n                _connection?.Dispose();\n            }\n\n            _disposed = true;\n        }\n\n        /// <summary>\n        /// Resets the singleton instance. Useful for testing.\n        /// </summary>\n        public static void ResetInstance()\n        {\n            lock (_lock)\n            {\n                _instance?.Dispose();\n                _instance = null;\n            }\n        }\n    }\n}\n```\n\n---\n\n## 7. SQL Query Builder (Builder Pattern)\n\n### Design Pattern: Builder Pattern\n\n**Purpose**: \n- Construct complex SQL queries step by step\n- Fluent interface for readable code\n- Separate query construction from execution\n\n### SqlQueryBuilder.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Builds SQL queries using the Builder pattern with a fluent interface.\n    /// \n    /// Design Pattern: Builder Pattern\n    /// - Separates construction of complex objects from their representation\n    /// - Same construction process can create different representations\n    /// \n    /// Design Pattern: Fluent Interface\n    /// - Methods return 'this' to allow method chaining\n    /// </summary>\n    public class SqlQueryBuilder\n    {\n        private readonly StringBuilder _selectClause = new StringBuilder();\n        private readonly StringBuilder _fromClause = new StringBuilder();\n        private readonly StringBuilder _whereClause = new StringBuilder();\n        private readonly StringBuilder _joinClause = new StringBuilder();\n        private readonly StringBuilder _orderByClause = new StringBuilder();\n        private readonly StringBuilder _groupByClause = new StringBuilder();\n        private readonly StringBuilder _havingClause = new StringBuilder();\n        \n        private readonly List<QueryParameter> _parameters = new List<QueryParameter>();\n        private int _parameterIndex = 0;\n        \n        private int? _top;\n        private int? _skip;\n        private int? _take;\n        private bool _distinct;\n\n        /// <summary>\n        /// Gets all parameters added to this query.\n        /// </summary>\n        public IReadOnlyList<QueryParameter> Parameters => _parameters;\n\n        #region SELECT Clause\n\n        /// <summary>\n        /// Starts building a SELECT query with specified columns.\n        /// </summary>\n        public SqlQueryBuilder Select(params string[] columns)\n        {\n            if (columns == null || columns.Length == 0)\n            {\n                _selectClause.Append(\"*\");\n            }\n            else\n            {\n                _selectClause.Append(string.Join(\", \", columns.Select(c => $\"[{c}]\")));\n            }\n            return this;\n        }\n\n        /// <summary>\n        /// Selects all columns.\n        /// </summary>\n        public SqlQueryBuilder SelectAll()\n        {\n            _selectClause.Append(\"*\");\n            return this;\n        }\n\n        /// <summary>\n        /// Selects specific columns from a typed entity.\n        /// </summary>\n        public SqlQueryBuilder Select<TEntity>() where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            var columns = metadata.MappedProperties.Select(p => $\"[{p.ColumnName}]\");\n            _selectClause.Append(string.Join(\", \", columns));\n            return this;\n        }\n\n        /// <summary>\n        /// Adds DISTINCT to the query.\n        /// </summary>\n        public SqlQueryBuilder Distinct()\n        {\n            _distinct = true;\n            return this;\n        }\n\n        /// <summary>\n        /// Limits the number of rows returned.\n        /// </summary>\n        public SqlQueryBuilder Top(int count)\n        {\n            _top = count;\n            return this;\n        }\n\n        #endregion\n\n        #region FROM Clause\n\n        /// <summary>\n        /// Specifies the table to select from.\n        /// </summary>\n        public SqlQueryBuilder From(string tableName, string alias = null)\n        {\n            _fromClause.Append($\"[{tableName}]\");\n            if (!string.IsNullOrEmpty(alias))\n            {\n                _fromClause.Append($\" AS [{alias}]\");\n            }\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies the table to select from using entity metadata.\n        /// </summary>\n        public SqlQueryBuilder From<TEntity>(string alias = null) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            return From(metadata.TableName, alias);\n        }\n\n        #endregion\n\n        #region WHERE Clause\n\n        /// <summary>\n        /// Adds a WHERE condition.\n        /// </summary>\n        public SqlQueryBuilder Where(string condition)\n        {\n            if (_whereClause.Length > 0)\n            {\n                _whereClause.Append(\" AND \");\n            }\n            _whereClause.Append($\"({condition})\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE condition with a param",
                    "images": [],
                    "tokenCount": 4974,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off. I was in the middle of the EntityMetadata.cs file. Let me continue from there and then proceed with the rest of the ORM implementation.",
                        "signature": "EuUCCkYIChgCKkCZgo2bVdi3lW7OVukn7IxIcbLlc6xDRFduBIGMr/Aml1O8cJDOO8FWVJWbvoA8Ook/WTW7Zn1EtxFTM/EgU6ODEgzayY3mfLnY2uDJpt0aDAB+r5mMLqZxrUdMoiIwvvWYJfR1ioiyOjLdugllYvoYmULzo8VhCjuWIxfdOd7gMh72PRTpDAJxsGtqueEAKswBteng2+s7m8tNJG+jHRCWPm0tNoTrWpql5CURjIrgfyPy6370vFv40ph3LVkWQjat8sUmcbUs+Uq0Sw0XmEQcQ3+B/vEhLRvENHHcGtAoRkfwNMxpgDhMQvpZXQfKy63WUyGB0WwDG8cfRjPtzzaTRbBAp3UUmZglJ/A+q+XO5HWtr6kAJqCn0W+Fx+M/wIJZ8x49q2oSITcr7v5LsBhICswbDLSV5UJqQatcAXP3SuJ6DdeQfvrY8YhTn0F6CPVD6ikdXO7HJ9icLqOxGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 1,
            "parentIdx": 0,
            "childrenIdxs": [
                2
            ],
            "createdAt": "2025-12-04T17:55:23.992Z",
            "updatedAt": "2025-12-04T17:56:35.752Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `SqlQueryBuilder.cs` WHERE clause section:\n\n### SqlQueryBuilder.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Represents a query parameter.\n    /// </summary>\n    public class QueryParameter\n    {\n        public string Name { get; set; }\n        public object Value { get; set; }\n        public DbType? DbType { get; set; }\n    }\n\n    /// <summary>\n    /// Builds SQL queries using the Builder pattern with a fluent interface.\n    /// </summary>\n    public class SqlQueryBuilder\n    {\n        private readonly StringBuilder _selectClause = new StringBuilder();\n        private readonly StringBuilder _fromClause = new StringBuilder();\n        private readonly StringBuilder _whereClause = new StringBuilder();\n        private readonly StringBuilder _joinClause = new StringBuilder();\n        private readonly StringBuilder _orderByClause = new StringBuilder();\n        private readonly StringBuilder _groupByClause = new StringBuilder();\n        private readonly StringBuilder _havingClause = new StringBuilder();\n        \n        private readonly List<QueryParameter> _parameters = new List<QueryParameter>();\n        private int _parameterIndex = 0;\n        \n        private int? _top;\n        private int? _skip;\n        private int? _take;\n        private bool _distinct;\n\n        public IReadOnlyList<QueryParameter> Parameters => _parameters;\n\n        #region SELECT Clause\n\n        public SqlQueryBuilder Select(params string[] columns)\n        {\n            if (columns == null || columns.Length == 0)\n            {\n                _selectClause.Append(\"*\");\n            }\n            else\n            {\n                _selectClause.Append(string.Join(\", \", columns.Select(c => $\"[{c}]\")));\n            }\n            return this;\n        }\n\n        public SqlQueryBuilder SelectAll()\n        {\n            _selectClause.Append(\"*\");\n            return this;\n        }\n\n        public SqlQueryBuilder Select<TEntity>() where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            var columns = metadata.MappedProperties.Select(p => $\"[{p.ColumnName}]\");\n            _selectClause.Append(string.Join(\", \", columns));\n            return this;\n        }\n\n        public SqlQueryBuilder SelectCount(string column = \"*\")\n        {\n            _selectClause.Append($\"COUNT({column})\");\n            return this;\n        }\n\n        public SqlQueryBuilder SelectSum(string column)\n        {\n            _selectClause.Append($\"SUM([{column}])\");\n            return this;\n        }\n\n        public SqlQueryBuilder SelectAvg(string column)\n        {\n            _selectClause.Append($\"AVG([{column}])\");\n            return this;\n        }\n\n        public SqlQueryBuilder SelectMax(string column)\n        {\n            _selectClause.Append($\"MAX([{column}])\");\n            return this;\n        }\n\n        public SqlQueryBuilder SelectMin(string column)\n        {\n            _selectClause.Append($\"MIN([{column}])\");\n            return this;\n        }\n\n        public SqlQueryBuilder Distinct()\n        {\n            _distinct = true;\n            return this;\n        }\n\n        public SqlQueryBuilder Top(int count)\n        {\n            _top = count;\n            return this;\n        }\n\n        #endregion\n\n        #region FROM Clause\n\n        public SqlQueryBuilder From(string tableName, string alias = null)\n        {\n            _fromClause.Append($\"[{tableName}]\");\n            if (!string.IsNullOrEmpty(alias))\n            {\n                _fromClause.Append($\" AS [{alias}]\");\n            }\n            return this;\n        }\n\n        public SqlQueryBuilder From<TEntity>(string alias = null) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            return From(metadata.TableName, alias);\n        }\n\n        #endregion\n\n        #region WHERE Clause\n\n        /// <summary>\n        /// Adds a raw WHERE condition.\n        /// </summary>\n        public SqlQueryBuilder Where(string condition)\n        {\n            if (_whereClause.Length > 0)\n            {\n                _whereClause.Append(\" AND \");\n            }\n            _whereClause.Append($\"({condition})\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE condition with a parameterized value.\n        /// </summary>\n        public SqlQueryBuilder Where(string column, object value)\n        {\n            return WhereEqual(column, value);\n        }\n\n        /// <summary>\n        /// Adds a WHERE column = value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereEqual(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] = {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column != value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereNotEqual(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] <> {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column > value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereGreaterThan(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] > {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column >= value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereGreaterThanOrEqual(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] >= {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column < value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereLessThan(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] < {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column <= value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereLessThanOrEqual(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] <= {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column LIKE value condition.\n        /// </summary>\n        public SqlQueryBuilder WhereLike(string column, string pattern)\n        {\n            var paramName = AddParameter(pattern);\n            return Where($\"[{column}] LIKE {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column LIKE '%value%' condition.\n        /// </summary>\n        public SqlQueryBuilder WhereContains(string column, string value)\n        {\n            return WhereLike(column, $\"%{value}%\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column LIKE 'value%' condition.\n        /// </summary>\n        public SqlQueryBuilder WhereStartsWith(string column, string value)\n        {\n            return WhereLike(column, $\"{value}%\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column LIKE '%value' condition.\n        /// </summary>\n        public SqlQueryBuilder WhereEndsWith(string column, string value)\n        {\n            return WhereLike(column, $\"%{value}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column IN (values) condition.\n        /// </summary>\n        public SqlQueryBuilder WhereIn<T>(string column, IEnumerable<T> values)\n        {\n            var valueList = values.ToList();\n            if (!valueList.Any())\n            {\n                // If no values, add impossible condition\n                return Where(\"1 = 0\");\n            }\n\n            var paramNames = new List<string>();\n            foreach (var value in valueList)\n            {\n                paramNames.Add(AddParameter(value));\n            }\n\n            return Where($\"[{column}] IN ({string.Join(\", \", paramNames)})\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column NOT IN (values) condition.\n        /// </summary>\n        public SqlQueryBuilder WhereNotIn<T>(string column, IEnumerable<T> values)\n        {\n            var valueList = values.ToList();\n            if (!valueList.Any())\n            {\n                // If no values, always true\n                return this;\n            }\n\n            var paramNames = new List<string>();\n            foreach (var value in valueList)\n            {\n                paramNames.Add(AddParameter(value));\n            }\n\n            return Where($\"[{column}] NOT IN ({string.Join(\", \", paramNames)})\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column BETWEEN value1 AND value2 condition.\n        /// </summary>\n        public SqlQueryBuilder WhereBetween(string column, object value1, object value2)\n        {\n            var paramName1 = AddParameter(value1);\n            var paramName2 = AddParameter(value2);\n            return Where($\"[{column}] BETWEEN {paramName1} AND {paramName2}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column IS NULL condition.\n        /// </summary>\n        public SqlQueryBuilder WhereNull(string column)\n        {\n            return Where($\"[{column}] IS NULL\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE column IS NOT NULL condition.\n        /// </summary>\n        public SqlQueryBuilder WhereNotNull(string column)\n        {\n            return Where($\"[{column}] IS NOT NULL\");\n        }\n\n        /// <summary>\n        /// Adds an OR condition.\n        /// </summary>\n        public SqlQueryBuilder Or(string condition)\n        {\n            if (_whereClause.Length > 0)\n            {\n                _whereClause.Append(\" OR \");\n            }\n            _whereClause.Append($\"({condition})\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds an OR condition with a parameterized value.\n        /// </summary>\n        public SqlQueryBuilder OrWhere(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Or($\"[{column}] = {paramName}\");\n        }\n\n        #endregion\n\n        #region JOIN Clause\n\n        /// <summary>\n        /// Adds an INNER JOIN clause.\n        /// </summary>\n        public SqlQueryBuilder InnerJoin(string table, string condition, string alias = null)\n        {\n            _joinClause.Append($\" INNER JOIN [{table}]\");\n            if (!string.IsNullOrEmpty(alias))\n            {\n                _joinClause.Append($\" AS [{alias}]\");\n            }\n            _joinClause.Append($\" ON {condition}\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a LEFT JOIN clause.\n        /// </summary>\n        public SqlQueryBuilder LeftJoin(string table, string condition, string alias = null)\n        {\n            _joinClause.Append($\" LEFT JOIN [{table}]\");\n            if (!string.IsNullOrEmpty(alias))\n            {\n                _joinClause.Append($\" AS [{alias}]\");\n            }\n            _joinClause.Append($\" ON {condition}\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a RIGHT JOIN clause.\n        /// </summary>\n        public SqlQueryBuilder RightJoin(string table, string condition, string alias = null)\n        {\n            _joinClause.Append($\" RIGHT JOIN [{table}]\");\n            if (!string.IsNullOrEmpty(alias))\n            {\n                _joinClause.Append($\" AS [{alias}]\");\n            }\n            _joinClause.Append($\" ON {condition}\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a typed INNER JOIN using entity metadata.\n        /// </summary>\n        public SqlQueryBuilder InnerJoin<TEntity>(string condition, string alias = null) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            return InnerJoin(metadata.TableName, condition, alias);\n        }\n\n        #endregion\n\n        #region ORDER BY Clause\n\n        /// <summary>\n        /// Adds an ORDER BY clause.\n        /// </summary>\n        public SqlQueryBuilder OrderBy(string column, bool descending = false)\n        {\n            if (_orderByClause.Length > 0)\n            {\n                _orderByClause.Append(\", \");\n            }\n            _orderByClause.Append($\"[{column}]\");\n            if (descending)\n            {\n                _orderByClause.Append(\" DESC\");\n            }\n            return this;\n        }\n\n        /// <summary>\n        /// Adds an ORDER BY ... DESC clause.\n        /// </summary>\n        public SqlQueryBuilder OrderByDescending(string column)\n        {\n            return OrderBy(column, true);\n        }\n\n        /// <summary>\n        /// Adds a secondary ordering (THEN BY).\n        /// </summary>\n        public SqlQueryBuilder ThenBy(string column, bool descending = false)\n        {\n            return OrderBy(column, descending);\n        }\n\n        #endregion\n\n        #region GROUP BY and HAVING\n\n        /// <summary>\n        /// Adds a GROUP BY clause.\n        /// </summary>\n        public SqlQueryBuilder GroupBy(params string[] columns)\n        {\n            _groupByClause.Append(string.Join(\", \", columns.Select(c => $\"[{c}]\")));\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a HAVING clause.\n        /// </summary>\n        public SqlQueryBuilder Having(string condition)\n        {\n            if (_havingClause.Length > 0)\n            {\n                _havingClause.Append(\" AND \");\n            }\n            _havingClause.Append($\"({condition})\");\n            return this;\n        }\n\n        #endregion\n\n        #region Pagination\n\n        /// <summary>\n        /// Skips a specified number of rows (for pagination).\n        /// Must be used with OrderBy.\n        /// </summary>\n        public SqlQueryBuilder Skip(int count)\n        {\n            _skip = count;\n            return this;\n        }\n\n        /// <summary>\n        /// Takes a specified number of rows (for pagination).\n        /// </summary>\n        public SqlQueryBuilder Take(int count)\n        {\n            _take = count;\n            return this;\n        }\n\n        /// <summary>\n        /// Adds pagination using OFFSET/FETCH (SQL Server 2012+).\n        /// </summary>\n        public SqlQueryBuilder Page(int pageNumber, int pageSize)\n        {\n            if (pageNumber < 1) pageNumber = 1;\n            _skip = (pageNumber - 1) * pageSize;\n            _take = pageSize;\n            return this;\n        }\n\n        #endregion\n\n        #region Parameter Management\n\n        /// <summary>\n        /// Adds a parameter and returns its name.\n        /// </summary>\n        public string AddParameter(object value, DbType? dbType = null)\n        {\n            var paramName = $\"@p{_parameterIndex++}\";\n            _parameters.Add(new QueryParameter\n            {\n                Name = paramName,\n                Value = value ?? DBNull.Value,\n                DbType = dbType\n            });\n            return paramName;\n        }\n\n        /// <summary>\n        /// Adds a named parameter.\n        /// </summary>\n        public SqlQueryBuilder WithParameter(string name, object value, DbType? dbType = null)\n        {\n            if (!name.StartsWith(\"@\"))\n            {\n                name = \"@\" + name;\n            }\n            _parameters.Add(new QueryParameter\n            {\n                Name = name,\n                Value = value ?? DBNull.Value,\n                DbType = dbType\n            });\n            return this;\n        }\n\n        #endregion\n\n        #region Build Methods\n\n        /// <summary>\n        /// Builds the SELECT query string.\n        /// </summary>\n        public string BuildSelect()\n        {\n            var sql = new StringBuilder();\n\n            // SELECT clause\n            sql.Append(\"SELECT \");\n            if (_distinct)\n            {\n                sql.Append(\"DISTINCT \");\n            }\n            if (_top.HasValue && !_skip.HasValue)\n            {\n                sql.Append($\"TOP {_top.Value} \");\n            }\n            sql.Append(_selectClause.Length > 0 ? _selectClause.ToString() : \"*\");\n\n            // FROM clause\n            if (_fromClause.Length > 0)\n            {\n                sql.Append(\" FROM \");\n                sql.Append(_fromClause);\n            }\n\n            // JOIN clause\n            if (_joinClause.Length > 0)\n            {\n                sql.Append(_joinClause);\n            }\n\n            // WHERE clause\n            if (_whereClause.Length > 0)\n            {\n                sql.Append(\" WHERE \");\n                sql.Append(_whereClause);\n            }\n\n            // GROUP BY clause\n            if (_groupByClause.Length > 0)\n            {\n                sql.Append(\" GROUP BY \");\n                sql.Append(_groupByClause);\n            }\n\n            // HAVING clause\n            if (_havingClause.Length > 0)\n            {\n                sql.Append(\" HAVING \");\n                sql.Append(_havingClause);\n            }\n\n            // ORDER BY clause\n            if (_orderByClause.Length > 0)\n            {\n                sql.Append(\" ORDER BY \");\n                sql.Append(_orderByClause);\n            }\n\n            // OFFSET/FETCH for pagination (SQL Server 2012+)\n            if (_skip.HasValue || _take.HasValue)\n            {\n                // ORDER BY is required for OFFSET/FETCH\n                if (_orderByClause.Length == 0)\n                {\n                    sql.Append(\" ORDER BY (SELECT NULL)\");\n                }\n                \n                sql.Append($\" OFFSET {_skip ?? 0} ROWS\");\n                if (_take.HasValue)\n                {\n                    sql.Append($\" FETCH NEXT {_take.Value} ROWS ONLY\");\n                }\n            }\n\n            return sql.ToString();\n        }\n\n        /// <summary>\n        /// Builds the complete query with parameters.\n        /// </summary>\n        public (string Sql, IReadOnlyList<QueryParameter> Parameters) Build()\n        {\n            return (BuildSelect(), _parameters);\n        }\n\n        /// <summary>\n        /// Resets the builder to its initial state.\n        /// </summary>\n        public SqlQueryBuilder Clear()\n        {\n            _selectClause.Clear();\n            _fromClause.Clear();\n            _whereClause.Clear();\n            _joinClause.Clear();\n            _orderByClause.Clear();\n            _groupByClause.Clear();\n            _havingClause.Clear();\n            _parameters.Clear();\n            _parameterIndex = 0;\n            _top = null;\n            _skip = null;\n            _take = null;\n            _distinct = false;\n            return this;\n        }\n\n        public override string ToString() => BuildSelect();\n\n        #endregion\n    }\n}\n```\n\n### InsertQueryBuilder.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Builds INSERT queries using the Builder pattern.\n    /// </summary>\n    public class InsertQueryBuilder\n    {\n        private string _tableName;\n        private readonly Dictionary<string, object> _values = new Dictionary<string, object>();\n        private readonly List<QueryParameter> _parameters = new List<QueryParameter>();\n        private bool _returnIdentity = true;\n        private int _parameterIndex = 0;\n\n        public IReadOnlyList<QueryParameter> Parameters => _parameters;\n\n        /// <summary>\n        /// Specifies the table to insert into.\n        /// </summary>\n        public InsertQueryBuilder Into(string tableName)\n        {\n            _tableName = tableName ?? throw new ArgumentNullException(nameof(tableName));\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies the table using entity metadata.\n        /// </summary>\n        public InsertQueryBuilder Into<TEntity>() where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            _tableName = metadata.TableName;\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a column value.\n        /// </summary>\n        public InsertQueryBuilder Value(string column, object value)\n        {\n            _values[column] = value;\n            return this;\n        }\n\n        /// <summary>\n        /// Adds multiple column values from a dictionary.\n        /// </summary>\n        public InsertQueryBuilder Values(IDictionary<string, object> values)\n        {\n            foreach (var kvp in values)\n            {\n                _values[kvp.Key] = kvp.Value;\n            }\n            return this;\n        }\n\n        /// <summary>\n        /// Adds values from an entity instance.\n        /// </summary>\n        public InsertQueryBuilder Values<TEntity>(TEntity entity) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            \n            foreach (var property in metadata.GetInsertProperties())\n            {\n                var value = property.GetValue(entity);\n                _values[property.ColumnName] = value;\n            }\n            \n            return this;\n        }\n\n        /// <summary>\n        /// Specifies whether to return the generated identity value.\n        /// </summary>\n        public InsertQueryBuilder ReturnIdentity(bool returnIdentity = true)\n        {\n            _returnIdentity = returnIdentity;\n            return this;\n        }\n\n        /// <summary>\n        /// Builds the INSERT query string.\n        /// </summary>\n        public string BuildInsert()\n        {\n            if (string.IsNullOrEmpty(_tableName))\n            {\n                throw new InvalidOperationException(\"Table name must be specified.\");\n            }\n\n            if (!_values.Any())\n            {\n                throw new InvalidOperationException(\"At least one value must be specified.\");\n            }\n\n            var sql = new StringBuilder();\n            var columns = _values.Keys.ToList();\n            var paramNames = new List<string>();\n\n            // Create parameters\n            foreach (var column in columns)\n            {\n                var paramName = $\"@p{_parameterIndex++}\";\n                paramNames.Add(paramName);\n                _parameters.Add(new QueryParameter\n                {\n                    Name = paramName,\n                    Value = _values[column] ?? DBNull.Value\n                });\n            }\n\n            sql.Append($\"INSERT INTO [{_tableName}] (\");\n            sql.Append(string.Join(\", \", columns.Select(c => $\"[{c}]\")));\n            sql.Append(\") VALUES (\");\n            sql.Append(string.Join(\", \", paramNames));\n            sql.Append(\")\");\n\n            // Add SCOPE_IDENTITY() for SQL Server to get the generated ID\n            if (_returnIdentity)\n            {\n                sql.Append(\"; SELECT SCOPE_IDENTITY();\");\n            }\n\n            return sql.ToString();\n        }\n\n        public (string Sql, IReadOnlyList<QueryParameter> Parameters) Build()\n        {\n            return (BuildInsert(), _parameters);\n        }\n\n        public override string ToString() => BuildInsert();\n    }\n}\n```\n\n### UpdateQueryBuilder.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Builds UPDATE queries using the Builder pattern.\n    /// </summary>\n    public class UpdateQueryBuilder\n    {\n        private string _tableName;\n        private readonly Dictionary<string, object> _values = new Dictionary<string, object>();\n        private readonly StringBuilder _whereClause = new StringBuilder();\n        private readonly List<QueryParameter> _parameters = new List<QueryParameter>();\n        private int _parameterIndex = 0;\n\n        public IReadOnlyList<QueryParameter> Parameters => _parameters;\n\n        /// <summary>\n        /// Specifies the table to update.\n        /// </summary>\n        public UpdateQueryBuilder Table(string tableName)\n        {\n            _tableName = tableName ?? throw new ArgumentNullException(nameof(tableName));\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies the table using entity metadata.\n        /// </summary>\n        public UpdateQueryBuilder Table<TEntity>() where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            _tableName = metadata.TableName;\n            return this;\n        }\n\n        /// <summary>\n        /// Sets a column to a value.\n        /// </summary>\n        public UpdateQueryBuilder Set(string column, object value)\n        {\n            _values[column] = value;\n            return this;\n        }\n\n        /// <summary>\n        /// Sets values from an entity instance (excludes primary key).\n        /// </summary>\n        public UpdateQueryBuilder Set<TEntity>(TEntity entity) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            \n            foreach (var property in metadata.GetUpdateProperties())\n            {\n                var value = property.GetValue(entity);\n                _values[property.ColumnName] = value;\n            }\n            \n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE condition.\n        /// </summary>\n        public UpdateQueryBuilder Where(string condition)\n        {\n            if (_whereClause.Length > 0)\n            {\n                _whereClause.Append(\" AND \");\n            }\n            _whereClause.Append($\"({condition})\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE column = value condition.\n        /// </summary>\n        public UpdateQueryBuilder Where(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] = {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE clause for the primary key.\n        /// </summary>\n        public UpdateQueryBuilder WherePrimaryKey<TEntity>(TEntity entity) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            var pkValue = metadata.PrimaryKey.GetValue(entity);\n            return Where(metadata.PrimaryKey.ColumnName, pkValue);\n        }\n\n        private string AddParameter(object value)\n        {\n            var paramName = $\"@p{_parameterIndex++}\";\n            _parameters.Add(new QueryParameter\n            {\n                Name = paramName,\n                Value = value ?? DBNull.Value\n            });\n            return paramName;\n        }\n\n        /// <summary>\n        /// Builds the UPDATE query string.\n        /// </summary>\n        public string BuildUpdate()\n        {\n            if (string.IsNullOrEmpty(_tableName))\n            {\n                throw new InvalidOperationException(\"Table name must be specified.\");\n            }\n\n            if (!_values.Any())\n            {\n                throw new InvalidOperationException(\"At least one SET value must be specified.\");\n            }\n\n            var sql = new StringBuilder();\n            sql.Append($\"UPDATE [{_tableName}] SET \");\n\n            var setClauses = new List<string>();\n            foreach (var kvp in _values)\n            {\n                var paramName = AddParameter(kvp.Value);\n                setClauses.Add($\"[{kvp.Key}] = {paramName}\");\n            }\n\n            sql.Append(string.Join(\", \", setClauses));\n\n            if (_whereClause.Length > 0)\n            {\n                sql.Append(\" WHERE \");\n                sql.Append(_whereClause);\n            }\n\n            return sql.ToString();\n        }\n\n        public (string Sql, IReadOnlyList<QueryParameter> Parameters) Build()\n        {\n            return (BuildUpdate(), _parameters);\n        }\n\n        public override string ToString() => BuildUpdate();\n    }\n}\n```\n\n### DeleteQueryBuilder.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Builds DELETE queries using the Builder pattern.\n    /// </summary>\n    public class DeleteQueryBuilder\n    {\n        private string _tableName;\n        private readonly StringBuilder _whereClause = new StringBuilder();\n        private readonly List<QueryParameter> _parameters = new List<QueryParameter>();\n        private int _parameterIndex = 0;\n\n        public IReadOnlyList<QueryParameter> Parameters => _parameters;\n\n        /// <summary>\n        /// Specifies the table to delete from.\n        /// </summary>\n        public DeleteQueryBuilder From(string tableName)\n        {\n            _tableName = tableName ?? throw new ArgumentNullException(nameof(tableName));\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies the table using entity metadata.\n        /// </summary>\n        public DeleteQueryBuilder From<TEntity>() where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            _tableName = metadata.TableName;\n            return this;\n        }\n\n        /// ",
                    "images": [],
                    "tokenCount": 5726,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the SqlQueryBuilder.cs file. I was in the middle of the WHERE clause section. Let me continue from there and complete the SqlQueryBuilder, then move on to the remaining sections.",
                        "signature": "EpIDCkYIChgCKkBpx8dwf2mufEQOOqZLDsaG/2b3O4EMkdo72IzK6dt26a+rB9dBBmFPsE+xoK5KJ6oZ/E0FVIQC78HxkaCOiBIzEgwUxS9QGa/Bb+MmJe0aDGfQbwfvG6b3V7VtgCIw06uOmq0cZxO2vBN7ZmlCDaCmAntmSosQhXkMpVdjCu/qxpog0PgTqcxLSfNW3+7IKvkBO0h1gvQgSXFNUNCmfmb1mwq499/OfPRVHd0pDqzTshodF8+HhkgTd+ZQLEsCkCAPCqnnk/CNlNLwm0wxGaTWf0PqoqMQmlo1ZpGbx8s8c+fYuVBp6GuMQKeuwXygI8USoPxutrSLfkD8c9blNRsUDm0AL1zltWpa2tgcwZeRa2IYYnDPguAafx4EIVORBVaS9BC0o03FRZdilL7hfoN3nb41cVWkEx/NMUIbQpiVvvgrv8i0087gW+ViJgX4PaVNVj+dbYeYC/NoPNShO70Mo+zhbfLcZmrYLLL/GN2sj2wdBB92LSS0lQMsgehFHb6exOm1a2uUQRHuGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 2,
            "parentIdx": 1,
            "childrenIdxs": [
                3
            ],
            "createdAt": "2025-12-04T17:57:41.725Z",
            "updatedAt": "2025-12-04T17:58:09.555Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `DeleteQueryBuilder.cs` file:\n\n### DeleteQueryBuilder.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Builds DELETE queries using the Builder pattern.\n    /// </summary>\n    public class DeleteQueryBuilder\n    {\n        private string _tableName;\n        private readonly StringBuilder _whereClause = new StringBuilder();\n        private readonly List<QueryParameter> _parameters = new List<QueryParameter>();\n        private int _parameterIndex = 0;\n\n        public IReadOnlyList<QueryParameter> Parameters => _parameters;\n\n        /// <summary>\n        /// Specifies the table to delete from.\n        /// </summary>\n        public DeleteQueryBuilder From(string tableName)\n        {\n            _tableName = tableName ?? throw new ArgumentNullException(nameof(tableName));\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies the table using entity metadata.\n        /// </summary>\n        public DeleteQueryBuilder From<TEntity>() where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            _tableName = metadata.TableName;\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE condition.\n        /// </summary>\n        public DeleteQueryBuilder Where(string condition)\n        {\n            if (_whereClause.Length > 0)\n            {\n                _whereClause.Append(\" AND \");\n            }\n            _whereClause.Append($\"({condition})\");\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE column = value condition.\n        /// </summary>\n        public DeleteQueryBuilder Where(string column, object value)\n        {\n            var paramName = AddParameter(value);\n            return Where($\"[{column}] = {paramName}\");\n        }\n\n        /// <summary>\n        /// Adds a WHERE clause for the primary key.\n        /// </summary>\n        public DeleteQueryBuilder WherePrimaryKey<TEntity>(TEntity entity) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            var pkValue = metadata.PrimaryKey.GetValue(entity);\n            return Where(metadata.PrimaryKey.ColumnName, pkValue);\n        }\n\n        /// <summary>\n        /// Adds a WHERE clause for a specific ID value.\n        /// </summary>\n        public DeleteQueryBuilder WhereId<TEntity>(object id) where TEntity : class\n        {\n            var metadata = EntityMapper.GetMetadata<TEntity>();\n            return Where(metadata.PrimaryKey.ColumnName, id);\n        }\n\n        private string AddParameter(object value)\n        {\n            var paramName = $\"@p{_parameterIndex++}\";\n            _parameters.Add(new QueryParameter\n            {\n                Name = paramName,\n                Value = value ?? DBNull.Value\n            });\n            return paramName;\n        }\n\n        /// <summary>\n        /// Builds the DELETE query string.\n        /// </summary>\n        public string BuildDelete()\n        {\n            if (string.IsNullOrEmpty(_tableName))\n            {\n                throw new InvalidOperationException(\"Table name must be specified.\");\n            }\n\n            var sql = new StringBuilder();\n            sql.Append($\"DELETE FROM [{_tableName}]\");\n\n            if (_whereClause.Length > 0)\n            {\n                sql.Append(\" WHERE \");\n                sql.Append(_whereClause);\n            }\n            else\n            {\n                // Safety check: require WHERE clause to prevent accidental deletion of all rows\n                throw new InvalidOperationException(\n                    \"DELETE without WHERE clause is not allowed. \" +\n                    \"Use DeleteAll() method if you want to delete all rows.\");\n            }\n\n            return sql.ToString();\n        }\n\n        /// <summary>\n        /// Builds a DELETE query without WHERE clause (deletes all rows).\n        /// Use with caution!\n        /// </summary>\n        public string BuildDeleteAll()\n        {\n            if (string.IsNullOrEmpty(_tableName))\n            {\n                throw new InvalidOperationException(\"Table name must be specified.\");\n            }\n\n            return $\"DELETE FROM [{_tableName}]\";\n        }\n\n        public (string Sql, IReadOnlyList<QueryParameter> Parameters) Build()\n        {\n            return (BuildDelete(), _parameters);\n        }\n\n        public override string ToString() => BuildDelete();\n    }\n}\n```\n\n---\n\n## 8. Generic Repository (Repository Pattern)\n\n### Design Pattern: Repository Pattern\n\n**Purpose**:\n- Mediates between the domain and data mapping layers\n- Acts like an in-memory domain object collection\n- Provides a clean API for data access operations\n\n**Benefits**:\n- Centralizes data access logic\n- Makes code more testable (can mock the repository)\n- Reduces duplication of query logic\n\n### IRepository.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq.Expressions;\nusing System.Threading.Tasks;\n\nnamespace MiniORM.Core.Repository\n{\n    /// <summary>\n    /// Generic repository interface defining standard CRUD operations.\n    /// \n    /// Design Pattern: Repository Pattern\n    /// - Abstracts data access behind a collection-like interface\n    /// - Enables unit testing through mocking\n    /// </summary>\n    /// <typeparam name=\"TEntity\">The entity type.</typeparam>\n    /// <typeparam name=\"TKey\">The primary key type.</typeparam>\n    public interface IRepository<TEntity, TKey> where TEntity : class\n    {\n        #region Query Operations\n\n        /// <summary>\n        /// Gets an entity by its primary key.\n        /// </summary>\n        TEntity GetById(TKey id);\n\n        /// <summary>\n        /// Gets an entity by its primary key asynchronously.\n        /// </summary>\n        Task<TEntity> GetByIdAsync(TKey id);\n\n        /// <summary>\n        /// Gets all entities.\n        /// </summary>\n        IEnumerable<TEntity> GetAll();\n\n        /// <summary>\n        /// Gets all entities asynchronously.\n        /// </summary>\n        Task<IEnumerable<TEntity>> GetAllAsync();\n\n        /// <summary>\n        /// Finds entities matching a predicate.\n        /// </summary>\n        IEnumerable<TEntity> Find(Expression<Func<TEntity, bool>> predicate);\n\n        /// <summary>\n        /// Finds entities matching a predicate asynchronously.\n        /// </summary>\n        Task<IEnumerable<TEntity>> FindAsync(Expression<Func<TEntity, bool>> predicate);\n\n        /// <summary>\n        /// Gets the first entity matching a predicate, or null.\n        /// </summary>\n        TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate);\n\n        /// <summary>\n        /// Checks if any entity matches the predicate.\n        /// </summary>\n        bool Any(Expression<Func<TEntity, bool>> predicate);\n\n        /// <summary>\n        /// Counts entities matching the predicate.\n        /// </summary>\n        int Count(Expression<Func<TEntity, bool>> predicate = null);\n\n        #endregion\n\n        #region Command Operations\n\n        /// <summary>\n        /// Adds a new entity.\n        /// </summary>\n        TEntity Add(TEntity entity);\n\n        /// <summary>\n        /// Adds a new entity asynchronously.\n        /// </summary>\n        Task<TEntity> AddAsync(TEntity entity);\n\n        /// <summary>\n        /// Adds multiple entities.\n        /// </summary>\n        void AddRange(IEnumerable<TEntity> entities);\n\n        /// <summary>\n        /// Updates an existing entity.\n        /// </summary>\n        void Update(TEntity entity);\n\n        /// <summary>\n        /// Updates an existing entity asynchronously.\n        /// </summary>\n        Task UpdateAsync(TEntity entity);\n\n        /// <summary>\n        /// Deletes an entity.\n        /// </summary>\n        void Delete(TEntity entity);\n\n        /// <summary>\n        /// Deletes an entity by its primary key.\n        /// </summary>\n        void Delete(TKey id);\n\n        /// <summary>\n        /// Deletes an entity asynchronously.\n        /// </summary>\n        Task DeleteAsync(TEntity entity);\n\n        /// <summary>\n        /// Deletes entities matching a predicate.\n        /// </summary>\n        void DeleteWhere(Expression<Func<TEntity, bool>> predicate);\n\n        #endregion\n\n        #region Query Builder Access\n\n        /// <summary>\n        /// Creates a new query builder for complex queries.\n        /// </summary>\n        IQueryable<TEntity> Query();\n\n        #endregion\n    }\n\n    /// <summary>\n    /// Repository interface with int primary key (common case).\n    /// </summary>\n    public interface IRepository<TEntity> : IRepository<TEntity, int> where TEntity : class\n    {\n    }\n}\n```\n\n### Repository.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Threading.Tasks;\nusing MiniORM.Core.Query;\n\nnamespace MiniORM.Core.Repository\n{\n    /// <summary>\n    /// Generic repository implementation.\n    /// \n    /// Design Pattern: Repository Pattern\n    /// - Encapsulates all data access logic\n    /// - Provides a clean separation between domain and data access\n    /// </summary>\n    public class Repository<TEntity, TKey> : IRepository<TEntity, TKey> where TEntity : class, new()\n    {\n        protected readonly DbContext _context;\n        protected readonly EntityMetadata _metadata;\n        protected readonly ExpressionParser _expressionParser;\n\n        public Repository(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n            _metadata = EntityMapper.GetMetadata<TEntity>();\n            _expressionParser = new ExpressionParser();\n        }\n\n        #region Query Operations\n\n        /// <summary>\n        /// Gets an entity by its primary key.\n        /// </summary>\n        public virtual TEntity GetById(TKey id)\n        {\n            var query = new SqlQueryBuilder()\n                .Select<TEntity>()\n                .From<TEntity>()\n                .Where(_metadata.PrimaryKey.ColumnName, id);\n\n            return ExecuteQuerySingle(query);\n        }\n\n        /// <summary>\n        /// Gets an entity by its primary key asynchronously.\n        /// </summary>\n        public virtual async Task<TEntity> GetByIdAsync(TKey id)\n        {\n            return await Task.Run(() => GetById(id));\n        }\n\n        /// <summary>\n        /// Gets all entities.\n        /// </summary>\n        public virtual IEnumerable<TEntity> GetAll()\n        {\n            var query = new SqlQueryBuilder()\n                .Select<TEntity>()\n                .From<TEntity>();\n\n            return ExecuteQuery(query);\n        }\n\n        /// <summary>\n        /// Gets all entities asynchronously.\n        /// </summary>\n        public virtual async Task<IEnumerable<TEntity>> GetAllAsync()\n        {\n            return await Task.Run(() => GetAll());\n        }\n\n        /// <summary>\n        /// Finds entities matching a predicate expression.\n        /// </summary>\n        public virtual IEnumerable<TEntity> Find(Expression<Func<TEntity, bool>> predicate)\n        {\n            var query = new SqlQueryBuilder()\n                .Select<TEntity>()\n                .From<TEntity>();\n\n            // Parse the expression into SQL WHERE clause\n            var whereClause = _expressionParser.ParsePredicate(predicate, query);\n            if (!string.IsNullOrEmpty(whereClause))\n            {\n                query.Where(whereClause);\n            }\n\n            return ExecuteQuery(query);\n        }\n\n        /// <summary>\n        /// Finds entities matching a predicate asynchronously.\n        /// </summary>\n        public virtual async Task<IEnumerable<TEntity>> FindAsync(Expression<Func<TEntity, bool>> predicate)\n        {\n            return await Task.Run(() => Find(predicate));\n        }\n\n        /// <summary>\n        /// Gets the first entity matching a predicate, or null.\n        /// </summary>\n        public virtual TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate)\n        {\n            var query = new SqlQueryBuilder()\n                .Select<TEntity>()\n                .From<TEntity>()\n                .Top(1);\n\n            var whereClause = _expressionParser.ParsePredicate(predicate, query);\n            if (!string.IsNullOrEmpty(whereClause))\n            {\n                query.Where(whereClause);\n            }\n\n            return ExecuteQuerySingle(query);\n        }\n\n        /// <summary>\n        /// Checks if any entity matches the predicate.\n        /// </summary>\n        public virtual bool Any(Expression<Func<TEntity, bool>> predicate)\n        {\n            return Count(predicate) > 0;\n        }\n\n        /// <summary>\n        /// Counts entities matching the predicate.\n        /// </summary>\n        public virtual int Count(Expression<Func<TEntity, bool>> predicate = null)\n        {\n            var query = new SqlQueryBuilder()\n                .SelectCount()\n                .From<TEntity>();\n\n            if (predicate != null)\n            {\n                var whereClause = _expressionParser.ParsePredicate(predicate, query);\n                if (!string.IsNullOrEmpty(whereClause))\n                {\n                    query.Where(whereClause);\n                }\n            }\n\n            var result = ExecuteScalar(query);\n            return Convert.ToInt32(result);\n        }\n\n        #endregion\n\n        #region Command Operations\n\n        /// <summary>\n        /// Adds a new entity and returns it with the generated ID.\n        /// </summary>\n        public virtual TEntity Add(TEntity entity)\n        {\n            if (entity == null)\n                throw new ArgumentNullException(nameof(entity));\n\n            var insertBuilder = new InsertQueryBuilder()\n                .Into<TEntity>()\n                .Values(entity)\n                .ReturnIdentity(_metadata.PrimaryKey.IsAutoGenerated);\n\n            var (sql, parameters) = insertBuilder.Build();\n\n            using var command = CreateCommand(sql, parameters);\n\n            if (_metadata.PrimaryKey.IsAutoGenerated)\n            {\n                // Execute and get the generated identity\n                var result = command.ExecuteScalar();\n                if (result != null && result != DBNull.Value)\n                {\n                    var generatedId = Convert.ChangeType(result, _metadata.PrimaryKey.PropertyType);\n                    _metadata.PrimaryKey.SetValue(entity, generatedId);\n                }\n            }\n            else\n            {\n                command.ExecuteNonQuery();\n            }\n\n            // Update entity state\n            if (entity is EntityBase entityBase)\n            {\n                entityBase.State = EntityState.Unchanged;\n            }\n\n            return entity;\n        }\n\n        /// <summary>\n        /// Adds a new entity asynchronously.\n        /// </summary>\n        public virtual async Task<TEntity> AddAsync(TEntity entity)\n        {\n            return await Task.Run(() => Add(entity));\n        }\n\n        /// <summary>\n        /// Adds multiple entities in a batch.\n        /// </summary>\n        public virtual void AddRange(IEnumerable<TEntity> entities)\n        {\n            foreach (var entity in entities)\n            {\n                Add(entity);\n            }\n        }\n\n        /// <summary>\n        /// Updates an existing entity.\n        /// </summary>\n        public virtual void Update(TEntity entity)\n        {\n            if (entity == null)\n                throw new ArgumentNullException(nameof(entity));\n\n            var updateBuilder = new UpdateQueryBuilder()\n                .Table<TEntity>()\n                .Set(entity)\n                .WherePrimaryKey(entity);\n\n            var (sql, parameters) = updateBuilder.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            var rowsAffected = command.ExecuteNonQuery();\n\n            if (rowsAffected == 0)\n            {\n                throw new InvalidOperationException(\n                    $\"Entity of type {typeof(TEntity).Name} with the specified key was not found.\");\n            }\n\n            // Update entity state\n            if (entity is EntityBase entityBase)\n            {\n                entityBase.State = EntityState.Unchanged;\n            }\n        }\n\n        /// <summary>\n        /// Updates an existing entity asynchronously.\n        /// </summary>\n        public virtual async Task UpdateAsync(TEntity entity)\n        {\n            await Task.Run(() => Update(entity));\n        }\n\n        /// <summary>\n        /// Deletes an entity.\n        /// </summary>\n        public virtual void Delete(TEntity entity)\n        {\n            if (entity == null)\n                throw new ArgumentNullException(nameof(entity));\n\n            var pkValue = _metadata.PrimaryKey.GetValue(entity);\n            Delete((TKey)pkValue);\n        }\n\n        /// <summary>\n        /// Deletes an entity by its primary key.\n        /// </summary>\n        public virtual void Delete(TKey id)\n        {\n            var deleteBuilder = new DeleteQueryBuilder()\n                .From<TEntity>()\n                .Where(_metadata.PrimaryKey.ColumnName, id);\n\n            var (sql, parameters) = deleteBuilder.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            command.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// Deletes an entity asynchronously.\n        /// </summary>\n        public virtual async Task DeleteAsync(TEntity entity)\n        {\n            await Task.Run(() => Delete(entity));\n        }\n\n        /// <summary>\n        /// Deletes entities matching a predicate.\n        /// </summary>\n        public virtual void DeleteWhere(Expression<Func<TEntity, bool>> predicate)\n        {\n            // First, find the entities to delete\n            var entities = Find(predicate).ToList();\n            \n            foreach (var entity in entities)\n            {\n                Delete(entity);\n            }\n        }\n\n        #endregion\n\n        #region Query Builder Access\n\n        /// <summary>\n        /// Creates a queryable for LINQ-style queries.\n        /// This is a simplified implementation - a full LINQ provider is complex.\n        /// </summary>\n        public virtual IQueryable<TEntity> Query()\n        {\n            // For a full implementation, you would create a custom IQueryable\n            // For simplicity, we return an in-memory queryable\n            return GetAll().AsQueryable();\n        }\n\n        #endregion\n\n        #region Helper Methods\n\n        /// <summary>\n        /// Executes a query and returns all results.\n        /// </summary>\n        protected List<TEntity> ExecuteQuery(SqlQueryBuilder query)\n        {\n            var (sql, parameters) = query.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            using var reader = command.ExecuteReader();\n\n            return EntityMapper.MapAllFromReader<TEntity>(reader);\n        }\n\n        /// <summary>\n        /// Executes a query and returns a single result.\n        /// </summary>\n        protected TEntity ExecuteQuerySingle(SqlQueryBuilder query)\n        {\n            var (sql, parameters) = query.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            using var reader = command.ExecuteReader();\n\n            if (reader.Read())\n            {\n                return EntityMapper.MapFromReader<TEntity>(reader);\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Executes a scalar query.\n        /// </summary>\n        protected object ExecuteScalar(SqlQueryBuilder query)\n        {\n            var (sql, parameters) = query.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            return command.ExecuteScalar();\n        }\n\n        /// <summary>\n        /// Creates a command with parameters.\n        /// </summary>\n        protected IDbCommand CreateCommand(string sql, IReadOnlyList<QueryParameter> parameters)\n        {\n            var command = _context.CreateCommand();\n            command.CommandText = sql;\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value ?? DBNull.Value;\n                \n                if (param.DbType.HasValue)\n                {\n                    dbParam.DbType = param.DbType.Value;\n                }\n\n                command.Parameters.Add(dbParam);\n            }\n\n            return command;\n        }\n\n        #endregion\n    }\n\n    /// <summary>\n    /// Repository with int primary key (common case).\n    /// </summary>\n    public class Repository<TEntity> : Repository<TEntity, int>, IRepository<TEntity> \n        where TEntity : class, new()\n    {\n        public Repository(DbContext context) : base(context)\n        {\n        }\n    }\n}\n```\n\n---\n\n## 9. Unit of Work Pattern\n\n### Design Pattern: Unit of Work\n\n**Purpose**:\n- Maintains a list of objects affected by a business transaction\n- Coordinates the writing out of changes\n- Ensures consistency across multiple repositories\n\n**Benefits**:\n- Groups multiple operations into a single transaction\n- Tracks changes to entities\n- Reduces database round trips\n\n### IUnitOfWork.cs\n\n```csharp\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MiniORM.Core.UnitOfWork\n{\n    /// <summary>\n    /// Unit of Work interface.\n    /// \n    /// Design Pattern: Unit of Work\n    /// - Maintains a list of objects affected by a business transaction\n    /// - Coordinates writing out changes and resolving concurrency issues\n    /// </summary>\n    public interface IUnitOfWork : IDisposable\n    {\n        /// <summary>\n        /// Gets a repository for the specified entity type.\n        /// </summary>\n        IRepository<TEntity> Repository<TEntity>() where TEntity : class, new();\n\n        /// <summary>\n        /// Saves all changes made in this unit of work to the database.\n        /// </summary>\n        int SaveChanges();\n\n        /// <summary>\n        /// Saves all changes asynchronously.\n        /// </summary>\n        Task<int> SaveChangesAsync();\n\n        /// <summary>\n        /// Begins a new transaction.\n        /// </summary>\n        void BeginTransaction();\n\n        /// <summary>\n        /// Commits the current transaction.\n        /// </summary>\n        void Commit();\n\n        /// <summary>\n        /// Rolls back the current transaction.\n        /// </summary>\n        void Rollback();\n    }\n}\n```\n\n### ChangeTracker.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MiniORM.Core.UnitOfWork\n{\n    /// <summary>\n    /// Tracks changes made to entities.\n    /// \n    /// Design Pattern: Observer Pattern (via INotifyPropertyChanged)\n    /// - Observes property changes on tracked entities\n    /// </summary>\n    public class ChangeTracker\n    {\n        private readonly Dictionary<object, EntityEntry> _trackedEntities \n            = new Dictionary<object, EntityEntry>();\n\n        /// <summary>\n        /// Gets all tracked entity entries.\n        /// </summary>\n        public IEnumerable<EntityEntry> Entries => _trackedEntities.Values;\n\n        /// <summary>\n        /// Gets entries for a specific entity type.\n        /// </summary>\n        public IEnumerable<EntityEntry> Entries<TEntity>() where TEntity : class\n        {\n            return _trackedEntities.Values.Where(e => e.Entity is TEntity);\n        }\n\n        /// <summary>\n        /// Starts tracking an entity.\n        /// </summary>\n        public EntityEntry Track<TEntity>(TEntity entity, EntityState state) where TEntity : class\n        {\n            if (entity == null)\n                throw new ArgumentNullException(nameof(entity));\n\n            if (_trackedEntities.TryGetValue(entity, out var existingEntry))\n            {\n                existingEntry.State = state;\n                return existingEntry;\n            }\n\n            var entry = new EntityEntry\n            {\n                Entity = entity,\n                EntityType = typeof(TEntity),\n                State = state,\n                OriginalValues = CaptureValues(entity)\n            };\n\n            _trackedEntities[entity] = entry;\n\n            // Subscribe to property changes if the entity supports it\n            if (entity is EntityBase entityBase)\n            {\n                entityBase.PropertyChanged += (sender, args) =>\n                {\n                    if (entry.State == EntityState.Unchanged)\n                    {\n                        entry.State = EntityState.Modified;\n                    }\n                };\n                entityBase.State = state;\n            }\n\n            return entry;\n        }\n\n        /// <summary>\n        /// Marks an entity as added.\n        /// </summary>\n        public EntityEntry Add<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Added);\n        }\n\n        /// <summary>\n        /// Marks an entity as modified.\n        /// </summary>\n        public EntityEntry Update<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Modified);\n        }\n\n        /// <summary>\n        /// Marks an entity as deleted.\n        /// </summary>\n        public EntityEntry Delete<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Deleted);\n        }\n\n        /// <summary>\n        /// Attaches an entity as unchanged.\n        /// </summary>\n        public EntityEntry Attach<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Unchanged);\n        }\n\n        /// <summary>\n        /// Stops tracking an entity.\n        /// </summary>\n        public void Detach<TEntity>(TEntity entity) where TEntity : class\n        {\n            if (_trackedEntities.ContainsKey(entity))\n            {\n                _trackedEntities.Remove(entity);\n                \n                if (entity is EntityBase entityBase)\n                {\n                    entityBase.State = EntityState.Detached;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets entities that have pending changes.\n        /// </summary>\n        public IEnumerable<EntityEntry> GetChangedEntries()\n        {\n            return _trackedEntities.Values.Where(e => \n                e.State == EntityState.Adde",
                    "images": [],
                    "tokenCount": 5048,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue building the ORM. I left off in the middle of the DeleteQueryBuilder.cs file. Let me continue from there and then move on to the Repository pattern, Unit of Work pattern, and Expression Parser.",
                        "signature": "EogDCkYIChgCKkBQm83Q9MkwHI1SlsC36Fy8y+g8nOU0tldzarmlInqwkXRro0WdV853wAOe45bSH9GCLqpAbcbbaM0GyXagRSbcEgz8DhuzIJ+ic+yyIxkaDBSa8Znl418DhdFbOCIwqr2pRgCd7psnDGWTo1uqvb6uJK1N6HfLSiuyL7fDBJvt5MI2wM35VNYFd5buc7cFKu8B/Rg3EbhR0cHikKKniV10S5kZ4T3EDYUVr0QVGS7y9w+Fy0hj77dtbCc/j76GmiQZTCiHOgw3pJ/MzAXJiv4apCKMUzna1SNbqbdLojXGudv/AYvtz4TIbiRFwMNkpXIKPIKi8il4HB06nOJmaP7Dya5+7Vqt5rCinql6SC+5dAUWypOhM3/ozulWl+m0/yqOrNK8cVAvb+R7OPr3TbpAIhHOnN9rI/jkwRb6VjPaXwbiLOcDpeJs6tV68kU8DGRfPh5DNu6y/cp3fWuuvWMvzKkTq17G5vtFYd2kmm+cHjKlcm3/LNC/maBKr3Q07JYYAQ=="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 3,
            "parentIdx": 2,
            "childrenIdxs": [
                4
            ],
            "createdAt": "2025-12-04T17:59:15.043Z",
            "updatedAt": "2025-12-04T17:59:29.246Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `ChangeTracker.cs` file:\n\n### ChangeTracker.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\n\nnamespace MiniORM.Core.UnitOfWork\n{\n    /// <summary>\n    /// Represents a tracked entity with its state and metadata.\n    /// </summary>\n    public class EntityEntry\n    {\n        public object Entity { get; set; }\n        public Type EntityType { get; set; }\n        public EntityState State { get; set; }\n        public Dictionary<string, object> OriginalValues { get; set; }\n        public Dictionary<string, object> CurrentValues => CaptureCurrentValues();\n\n        private Dictionary<string, object> CaptureCurrentValues()\n        {\n            var values = new Dictionary<string, object>();\n            var properties = EntityType.GetProperties(BindingFlags.Public | BindingFlags.Instance)\n                .Where(p => p.CanRead && p.CanWrite);\n\n            foreach (var prop in properties)\n            {\n                values[prop.Name] = prop.GetValue(Entity);\n            }\n\n            return values;\n        }\n\n        /// <summary>\n        /// Gets properties that have changed since tracking began.\n        /// </summary>\n        public IEnumerable<string> GetModifiedProperties()\n        {\n            var current = CurrentValues;\n            foreach (var kvp in OriginalValues)\n            {\n                if (current.TryGetValue(kvp.Key, out var currentValue))\n                {\n                    if (!Equals(kvp.Value, currentValue))\n                    {\n                        yield return kvp.Key;\n                    }\n                }\n            }\n        }\n    }\n\n    /// <summary>\n    /// Tracks changes made to entities.\n    /// \n    /// Design Pattern: Observer Pattern (via INotifyPropertyChanged)\n    /// - Observes property changes on tracked entities\n    /// \n    /// Design Pattern: Identity Map\n    /// - Ensures each entity is only tracked once\n    /// </summary>\n    public class ChangeTracker\n    {\n        private readonly Dictionary<object, EntityEntry> _trackedEntities \n            = new Dictionary<object, EntityEntry>();\n\n        /// <summary>\n        /// Gets all tracked entity entries.\n        /// </summary>\n        public IEnumerable<EntityEntry> Entries => _trackedEntities.Values;\n\n        /// <summary>\n        /// Gets entries for a specific entity type.\n        /// </summary>\n        public IEnumerable<EntityEntry> Entries<TEntity>() where TEntity : class\n        {\n            return _trackedEntities.Values.Where(e => e.Entity is TEntity);\n        }\n\n        /// <summary>\n        /// Checks if an entity is being tracked.\n        /// </summary>\n        public bool IsTracking<TEntity>(TEntity entity) where TEntity : class\n        {\n            return _trackedEntities.ContainsKey(entity);\n        }\n\n        /// <summary>\n        /// Gets the entry for a specific entity.\n        /// </summary>\n        public EntityEntry GetEntry<TEntity>(TEntity entity) where TEntity : class\n        {\n            return _trackedEntities.TryGetValue(entity, out var entry) ? entry : null;\n        }\n\n        /// <summary>\n        /// Starts tracking an entity.\n        /// </summary>\n        public EntityEntry Track<TEntity>(TEntity entity, EntityState state) where TEntity : class\n        {\n            if (entity == null)\n                throw new ArgumentNullException(nameof(entity));\n\n            if (_trackedEntities.TryGetValue(entity, out var existingEntry))\n            {\n                existingEntry.State = state;\n                return existingEntry;\n            }\n\n            var entry = new EntityEntry\n            {\n                Entity = entity,\n                EntityType = typeof(TEntity),\n                State = state,\n                OriginalValues = CaptureValues(entity)\n            };\n\n            _trackedEntities[entity] = entry;\n\n            // Subscribe to property changes if the entity supports it\n            if (entity is EntityBase entityBase)\n            {\n                entityBase.PropertyChanged += (sender, args) =>\n                {\n                    if (entry.State == EntityState.Unchanged)\n                    {\n                        entry.State = EntityState.Modified;\n                    }\n                };\n                entityBase.State = state;\n            }\n\n            return entry;\n        }\n\n        /// <summary>\n        /// Marks an entity as added.\n        /// </summary>\n        public EntityEntry Add<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Added);\n        }\n\n        /// <summary>\n        /// Marks an entity as modified.\n        /// </summary>\n        public EntityEntry Update<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Modified);\n        }\n\n        /// <summary>\n        /// Marks an entity as deleted.\n        /// </summary>\n        public EntityEntry Delete<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Deleted);\n        }\n\n        /// <summary>\n        /// Attaches an entity as unchanged.\n        /// </summary>\n        public EntityEntry Attach<TEntity>(TEntity entity) where TEntity : class\n        {\n            return Track(entity, EntityState.Unchanged);\n        }\n\n        /// <summary>\n        /// Stops tracking an entity.\n        /// </summary>\n        public void Detach<TEntity>(TEntity entity) where TEntity : class\n        {\n            if (_trackedEntities.ContainsKey(entity))\n            {\n                _trackedEntities.Remove(entity);\n                \n                if (entity is EntityBase entityBase)\n                {\n                    entityBase.State = EntityState.Detached;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets entities that have pending changes.\n        /// </summary>\n        public IEnumerable<EntityEntry> GetChangedEntries()\n        {\n            return _trackedEntities.Values.Where(e => \n                e.State == EntityState.Added ||\n                e.State == EntityState.Modified ||\n                e.State == EntityState.Deleted);\n        }\n\n        /// <summary>\n        /// Gets added entities.\n        /// </summary>\n        public IEnumerable<EntityEntry> GetAddedEntries()\n        {\n            return _trackedEntities.Values.Where(e => e.State == EntityState.Added);\n        }\n\n        /// <summary>\n        /// Gets modified entities.\n        /// </summary>\n        public IEnumerable<EntityEntry> GetModifiedEntries()\n        {\n            return _trackedEntities.Values.Where(e => e.State == EntityState.Modified);\n        }\n\n        /// <summary>\n        /// Gets deleted entities.\n        /// </summary>\n        public IEnumerable<EntityEntry> GetDeletedEntries()\n        {\n            return _trackedEntities.Values.Where(e => e.State == EntityState.Deleted);\n        }\n\n        /// <summary>\n        /// Marks all tracked entities as unchanged.\n        /// Called after SaveChanges succeeds.\n        /// </summary>\n        public void AcceptAllChanges()\n        {\n            var entriesToRemove = new List<object>();\n\n            foreach (var entry in _trackedEntities.Values)\n            {\n                switch (entry.State)\n                {\n                    case EntityState.Added:\n                    case EntityState.Modified:\n                        entry.State = EntityState.Unchanged;\n                        entry.OriginalValues = CaptureValues(entry.Entity);\n                        if (entry.Entity is EntityBase entityBase)\n                        {\n                            entityBase.State = EntityState.Unchanged;\n                        }\n                        break;\n\n                    case EntityState.Deleted:\n                        entriesToRemove.Add(entry.Entity);\n                        break;\n                }\n            }\n\n            // Remove deleted entities from tracking\n            foreach (var entity in entriesToRemove)\n            {\n                _trackedEntities.Remove(entity);\n            }\n        }\n\n        /// <summary>\n        /// Rejects all changes and reverts entities to their original state.\n        /// </summary>\n        public void RejectAllChanges()\n        {\n            var entriesToRemove = new List<object>();\n\n            foreach (var entry in _trackedEntities.Values)\n            {\n                switch (entry.State)\n                {\n                    case EntityState.Added:\n                        entriesToRemove.Add(entry.Entity);\n                        break;\n\n                    case EntityState.Modified:\n                        // Restore original values\n                        RestoreOriginalValues(entry);\n                        entry.State = EntityState.Unchanged;\n                        if (entry.Entity is EntityBase entityBase)\n                        {\n                            entityBase.State = EntityState.Unchanged;\n                        }\n                        break;\n\n                    case EntityState.Deleted:\n                        entry.State = EntityState.Unchanged;\n                        if (entry.Entity is EntityBase eb)\n                        {\n                            eb.State = EntityState.Unchanged;\n                        }\n                        break;\n                }\n            }\n\n            foreach (var entity in entriesToRemove)\n            {\n                _trackedEntities.Remove(entity);\n            }\n        }\n\n        /// <summary>\n        /// Clears all tracked entities.\n        /// </summary>\n        public void Clear()\n        {\n            foreach (var entry in _trackedEntities.Values)\n            {\n                if (entry.Entity is EntityBase entityBase)\n                {\n                    entityBase.State = EntityState.Detached;\n                }\n            }\n            _trackedEntities.Clear();\n        }\n\n        /// <summary>\n        /// Gets the number of tracked entities.\n        /// </summary>\n        public int Count => _trackedEntities.Count;\n\n        /// <summary>\n        /// Detects changes by comparing current values with original values.\n        /// </summary>\n        public void DetectChanges()\n        {\n            foreach (var entry in _trackedEntities.Values)\n            {\n                if (entry.State == EntityState.Unchanged)\n                {\n                    var modifiedProperties = entry.GetModifiedProperties().ToList();\n                    if (modifiedProperties.Any())\n                    {\n                        entry.State = EntityState.Modified;\n                        if (entry.Entity is EntityBase entityBase)\n                        {\n                            entityBase.State = EntityState.Modified;\n                        }\n                    }\n                }\n            }\n        }\n\n        #region Helper Methods\n\n        /// <summary>\n        /// Captures current property values of an entity.\n        /// </summary>\n        private static Dictionary<string, object> CaptureValues(object entity)\n        {\n            var values = new Dictionary<string, object>();\n            var properties = entity.GetType()\n                .GetProperties(BindingFlags.Public | BindingFlags.Instance)\n                .Where(p => p.CanRead && p.CanWrite);\n\n            foreach (var prop in properties)\n            {\n                try\n                {\n                    values[prop.Name] = prop.GetValue(entity);\n                }\n                catch\n                {\n                    // Ignore properties that throw exceptions\n                }\n            }\n\n            return values;\n        }\n\n        /// <summary>\n        /// Restores an entity to its original values.\n        /// </summary>\n        private static void RestoreOriginalValues(EntityEntry entry)\n        {\n            var properties = entry.EntityType\n                .GetProperties(BindingFlags.Public | BindingFlags.Instance)\n                .Where(p => p.CanRead && p.CanWrite);\n\n            foreach (var prop in properties)\n            {\n                if (entry.OriginalValues.TryGetValue(prop.Name, out var originalValue))\n                {\n                    try\n                    {\n                        prop.SetValue(entry.Entity, originalValue);\n                    }\n                    catch\n                    {\n                        // Ignore properties that can't be set\n                    }\n                }\n            }\n        }\n\n        #endregion\n    }\n}\n```\n\n### UnitOfWork.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Threading.Tasks;\nusing MiniORM.Core.Query;\nusing MiniORM.Core.Repository;\n\nnamespace MiniORM.Core.UnitOfWork\n{\n    /// <summary>\n    /// Unit of Work implementation.\n    /// \n    /// Design Pattern: Unit of Work\n    /// - Coordinates changes across multiple repositories\n    /// - Maintains transaction integrity\n    /// - Tracks entity changes\n    /// \n    /// Design Pattern: Registry (for repositories)\n    /// - Maintains a registry of repositories\n    /// </summary>\n    public class UnitOfWork : IUnitOfWork\n    {\n        private readonly DbContext _context;\n        private readonly Dictionary<Type, object> _repositories = new Dictionary<Type, object>();\n        private readonly ChangeTracker _changeTracker = new ChangeTracker();\n        private bool _disposed;\n\n        /// <summary>\n        /// Gets the change tracker for this unit of work.\n        /// </summary>\n        public ChangeTracker ChangeTracker => _changeTracker;\n\n        public UnitOfWork(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n        }\n\n        /// <summary>\n        /// Gets or creates a repository for the specified entity type.\n        /// Uses lazy initialization and caching.\n        /// </summary>\n        public IRepository<TEntity> Repository<TEntity>() where TEntity : class, new()\n        {\n            var type = typeof(TEntity);\n\n            if (!_repositories.TryGetValue(type, out var repository))\n            {\n                // Create a tracked repository that uses our change tracker\n                repository = new TrackedRepository<TEntity>(_context, _changeTracker);\n                _repositories[type] = repository;\n            }\n\n            return (IRepository<TEntity>)repository;\n        }\n\n        /// <summary>\n        /// Saves all tracked changes to the database.\n        /// </summary>\n        public int SaveChanges()\n        {\n            // Detect any changes that might have been missed\n            _changeTracker.DetectChanges();\n\n            var changedEntries = _changeTracker.GetChangedEntries();\n            var affectedRows = 0;\n            var wasInTransaction = _context.CurrentTransaction != null;\n\n            try\n            {\n                // Start a transaction if not already in one\n                if (!wasInTransaction)\n                {\n                    _context.BeginTransaction();\n                }\n\n                foreach (var entry in changedEntries)\n                {\n                    affectedRows += ProcessEntry(entry);\n                }\n\n                if (!wasInTransaction)\n                {\n                    _context.Commit();\n                }\n\n                // Mark all changes as accepted\n                _changeTracker.AcceptAllChanges();\n            }\n            catch\n            {\n                if (!wasInTransaction)\n                {\n                    _context.Rollback();\n                }\n                throw;\n            }\n\n            return affectedRows;\n        }\n\n        /// <summary>\n        /// Saves all changes asynchronously.\n        /// </summary>\n        public async Task<int> SaveChangesAsync()\n        {\n            return await Task.Run(() => SaveChanges());\n        }\n\n        /// <summary>\n        /// Begins a new transaction.\n        /// </summary>\n        public void BeginTransaction()\n        {\n            _context.BeginTransaction();\n        }\n\n        /// <summary>\n        /// Commits the current transaction.\n        /// </summary>\n        public void Commit()\n        {\n            _context.Commit();\n        }\n\n        /// <summary>\n        /// Rolls back the current transaction.\n        /// </summary>\n        public void Rollback()\n        {\n            _context.Rollback();\n            _changeTracker.RejectAllChanges();\n        }\n\n        /// <summary>\n        /// Processes a single entity entry (insert, update, or delete).\n        /// </summary>\n        private int ProcessEntry(EntityEntry entry)\n        {\n            var metadata = EntityMapper.GetMetadata(entry.EntityType);\n\n            return entry.State switch\n            {\n                EntityState.Added => ProcessInsert(entry, metadata),\n                EntityState.Modified => ProcessUpdate(entry, metadata),\n                EntityState.Deleted => ProcessDelete(entry, metadata),\n                _ => 0\n            };\n        }\n\n        /// <summary>\n        /// Processes an insert operation.\n        /// </summary>\n        private int ProcessInsert(EntityEntry entry, EntityMetadata metadata)\n        {\n            var insertBuilder = new InsertQueryBuilder();\n            insertBuilder.Into(metadata.TableName);\n\n            foreach (var property in metadata.GetInsertProperties())\n            {\n                var value = property.GetValue(entry.Entity);\n                insertBuilder.Value(property.ColumnName, value);\n            }\n\n            var (sql, parameters) = insertBuilder.Build();\n\n            using var command = CreateCommand(sql, parameters);\n\n            if (metadata.PrimaryKey.IsAutoGenerated)\n            {\n                var result = command.ExecuteScalar();\n                if (result != null && result != DBNull.Value)\n                {\n                    var generatedId = Convert.ChangeType(result, metadata.PrimaryKey.PropertyType);\n                    metadata.PrimaryKey.SetValue(entry.Entity, generatedId);\n                }\n                return 1;\n            }\n            else\n            {\n                return command.ExecuteNonQuery();\n            }\n        }\n\n        /// <summary>\n        /// Processes an update operation.\n        /// </summary>\n        private int ProcessUpdate(EntityEntry entry, EntityMetadata metadata)\n        {\n            var updateBuilder = new UpdateQueryBuilder();\n            updateBuilder.Table(metadata.TableName);\n\n            // Only update modified properties for efficiency\n            var modifiedProperties = entry.GetModifiedProperties().ToHashSet();\n\n            foreach (var property in metadata.GetUpdateProperties())\n            {\n                // If change tracking detected specific changes, only update those\n                // Otherwise, update all non-PK properties\n                if (modifiedProperties.Count == 0 || modifiedProperties.Contains(property.PropertyName))\n                {\n                    var value = property.GetValue(entry.Entity);\n                    updateBuilder.Set(property.ColumnName, value);\n                }\n            }\n\n            // Add WHERE clause for primary key\n            var pkValue = metadata.PrimaryKey.GetValue(entry.Entity);\n            updateBuilder.Where(metadata.PrimaryKey.ColumnName, pkValue);\n\n            var (sql, parameters) = updateBuilder.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            return command.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// Processes a delete operation.\n        /// </summary>\n        private int ProcessDelete(EntityEntry entry, EntityMetadata metadata)\n        {\n            var deleteBuilder = new DeleteQueryBuilder();\n            deleteBuilder.From(metadata.TableName);\n\n            var pkValue = metadata.PrimaryKey.GetValue(entry.Entity);\n            deleteBuilder.Where(metadata.PrimaryKey.ColumnName, pkValue);\n\n            var (sql, parameters) = deleteBuilder.Build();\n\n            using var command = CreateCommand(sql, parameters);\n            return command.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// Creates a command with parameters.\n        /// </summary>\n        private IDbCommand CreateCommand(string sql, IReadOnlyList<QueryParameter> parameters)\n        {\n            var command = _context.CreateCommand();\n            command.CommandText = sql;\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value ?? DBNull.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            return command;\n        }\n\n        #region IDisposable\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (_disposed) return;\n\n            if (disposing)\n            {\n                _changeTracker.Clear();\n                _repositories.Clear();\n            }\n\n            _disposed = true;\n        }\n\n        #endregion\n    }\n\n    /// <summary>\n    /// A repository that automatically tracks entities with the change tracker.\n    /// </summary>\n    internal class TrackedRepository<TEntity> : Repository<TEntity> where TEntity : class, new()\n    {\n        private readonly ChangeTracker _changeTracker;\n\n        public TrackedRepository(DbContext context, ChangeTracker changeTracker) : base(context)\n        {\n            _changeTracker = changeTracker;\n        }\n\n        public override TEntity GetById(int id)\n        {\n            var entity = base.GetById(id);\n            if (entity != null)\n            {\n                _changeTracker.Attach(entity);\n            }\n            return entity;\n        }\n\n        public override IEnumerable<TEntity> GetAll()\n        {\n            var entities = base.GetAll();\n            foreach (var entity in entities)\n            {\n                _changeTracker.Attach(entity);\n            }\n            return entities;\n        }\n\n        public override TEntity Add(TEntity entity)\n        {\n            _changeTracker.Add(entity);\n            return entity; // Don't save yet - SaveChanges will do it\n        }\n\n        public override void Update(TEntity entity)\n        {\n            _changeTracker.Update(entity);\n            // Don't save yet - SaveChanges will do it\n        }\n\n        public override void Delete(TEntity entity)\n        {\n            _changeTracker.Delete(entity);\n            // Don't save yet - SaveChanges will do it\n        }\n    }\n}\n```\n\n---\n\n## 10. Expression Parser for LINQ-like Queries\n\n### Design Pattern: Visitor Pattern / Interpreter Pattern\n\n**Purpose**:\n- Parse C# expression trees into SQL WHERE clauses\n- Enable LINQ-style queries like `Find(x => x.Name == \"John\")`\n\n### ExpressionParser.cs\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Reflection;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Parses LINQ expression trees into SQL WHERE clauses.\n    /// \n    /// Design Pattern: Visitor Pattern\n    /// - Visits each node in the expression tree\n    /// - Generates SQL based on the node type\n    /// \n    /// Design Pattern: Interpreter Pattern\n    /// - Interprets the expression language into SQL\n    /// </summary>\n    public class ExpressionParser\n    {\n        private SqlQueryBuilder _queryBuilder;\n        private readonly Dictionary<ExpressionType, string> _operatorMap;\n\n        public ExpressionParser()\n        {\n            // Map C# operators to SQL operators\n            _operatorMap = new Dictionary<ExpressionType, string>\n            {\n                { ExpressionType.Equal, \"=\" },\n                { ExpressionType.NotEqual, \"<>\" },\n                { ExpressionType.GreaterThan, \">\" },\n                { ExpressionType.GreaterThanOrEqual, \">=\" },\n                { ExpressionType.LessThan, \"<\" },\n                { ExpressionType.LessThanOrEqual, \"<=\" },\n                { ExpressionType.AndAlso, \"AND\" },\n                { ExpressionType.OrElse, \"OR\" },\n                { ExpressionType.Add, \"+\" },\n                { ExpressionType.Subtract, \"-\" },\n                { ExpressionType.Multiply, \"*\" },\n                { ExpressionType.Divide, \"/\" },\n                { ExpressionType.Modulo, \"%\" },\n            };\n        }\n\n        /// <summary>\n        /// Parses a predicate expression into a SQL WHERE clause.\n        /// </summary>\n        /// <typeparam name=\"TEntity\">The entity type.</typeparam>\n        /// <param name=\"predicate\">The predicate expression.</param>\n        /// <param name=\"queryBuilder\">The query builder to add parameters to.</param>\n        /// <returns>The SQL WHERE clause.</returns>\n        public string ParsePredicate<TEntity>(\n            Expression<Func<TEntity, bool>> predicate, \n            SqlQueryBuilder queryBuilder) where TEntity : class\n        {\n            _queryBuilder = queryBuilder;\n            return Visit(predicate.Body);\n        }\n\n        /// <summary>\n        /// Main visitor method that dispatches to specific handlers.\n        /// </summary>\n        private string Visit(Expression expression)\n        {\n            return expression switch\n            {\n                BinaryExpression binary => VisitBinary(binary),\n                MemberExpression member => VisitMember(member),\n                ConstantExpression constant => VisitConstant(constant),\n                UnaryExpression unary => VisitUnary(unary),\n                MethodCallExpression methodCall => VisitMethodCall(methodCall),\n                NewArrayExpression newArray => VisitNewArray(newArray),\n                _ => throw new NotSupportedException(\n                    $\"Expression type '{expression.GetType().Name}' is not supported.\")\n            };\n        }\n\n        /// <summary>\n        /// Visits binary expressions (==, !=, &&, ||, etc.).\n        /// </summary>\n        private string VisitBinary(BinaryExpression expression)\n        {\n            // Handle null comparisons specially\n            if (IsNullConstant(expression.Right))\n            {\n                var left = Visit(expression.Left);\n                return expression.NodeType == ExpressionType.Equal\n                    ? $\"{left} IS NULL\"\n                    : $\"{left} IS NOT NULL\";\n            }\n\n            if (IsNullConstant(expression.Left))\n            {\n                var right = Visit(expression.Right);\n                return expression.NodeType == ExpressionType.Equal\n                    ? $\"{right} IS NULL\"\n                    : $\"{right} IS NOT NULL\";\n            }\n\n            var leftSql = Visit(expression.Left);\n            var rightSql = Visit(expression.Right);\n\n            if (!_operatorMap.TryGetValue(expression.NodeType, out var op))\n            {\n                throw new NotSupportedException(\n                    $\"Binary operator '{expression.NodeType}' is not supported.\");\n            }\n\n            // Wrap AND/OR conditions in parentheses for proper precedence\n            if (expression.NodeType == ExpressionType.AndAlso || \n                expression.NodeType == ExpressionType.OrElse)\n            {\n                return $\"({leftSql} {op}",
                    "images": [],
                    "tokenCount": 4988,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the ChangeTracker.cs file. I was in the middle of the GetChangedEntries method. Let me continue from there and then complete the rest of the ORM implementation including:\n\n1. Complete ChangeTracker.cs\n2. UnitOfWork.cs\n3. Expression Parser (Section 10)\n4. Complete Example (Section 11)\n\nLet me continue with the implementation.",
                        "signature": "EqAECkYIChgCKkDiZdVirnpt2TyWQQHDxokMAb7PmXWE/xbMkSrJ5BowZ65t2S19KktnKP3RFrLQdumf+pnhQOMj7p6aFUWWX6ZpEgw6MGcz4lHjrWMsc5QaDISsLadi1/EIC2nIISIwX8XzJFENFwgPAEKoloq+QkrgfTmV4l+Cg6qZSbuJtZGfKBKJvhIi3+Oei/ByXfJJKocDsIRNAEuuA2uCE1vNst4pdcDRn1z2qT6mMaGk5/kVB8Sj1SGA84QQJplpwEWtBOnq6hJaAgHj0jzM20NegI9c1OMhlvvBLCzs0rfYJUlz2LFMmYAHuUNAGEF4bDQx3f34bvuNrDzBU+2dGGCFXx/uE5eWHhVq+pclSLeZ3ZNWpowmlCGTtgUaYFNvsAtJnFVoj4O+mSzg2N9YZJ+ECAZ9vWaH3+9+ZFy/Fj+FqIHzYCtHlITm/YrXE5aXtAjBof1sVOYVtzH665uvi+UjtuSmKHRQbuJm2/kNAB9zdT+MV1Q+ddFqtYRLUl8wYihTUdHVeEJEr2YWOPQaIrq4Q8+2tzf0WEW2t/Ekh1Q4LSx3NIDhPVKb1xm+nvxLVENP+MZV7BnQv92bZwZedTbGW1a46O3yklt/cA2+xzTNCrk0RU9unBYP/nXnZO9J+4JXr7x7K5pVq69EnIa0gmVBcZU+NgzBRsggScN8es+X4FdaMdYukqK/QBfhyu9+jeNor87OaIHgXmpsNBgB"
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 4,
            "parentIdx": 3,
            "childrenIdxs": [
                5
            ],
            "createdAt": "2025-12-04T18:00:35.006Z",
            "updatedAt": "2025-12-04T18:01:23.940Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `ExpressionParser.cs` file:\n\n### ExpressionParser.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Reflection;\nusing System.Text;\n\nnamespace MiniORM.Core.Query\n{\n    /// <summary>\n    /// Parses LINQ expression trees into SQL WHERE clauses.\n    /// \n    /// Design Pattern: Visitor Pattern\n    /// - Visits each node in the expression tree\n    /// - Generates SQL based on the node type\n    /// \n    /// Design Pattern: Interpreter Pattern\n    /// - Interprets the expression language into SQL\n    /// </summary>\n    public class ExpressionParser\n    {\n        private SqlQueryBuilder _queryBuilder;\n        private readonly Dictionary<ExpressionType, string> _operatorMap;\n\n        public ExpressionParser()\n        {\n            // Map C# operators to SQL operators\n            _operatorMap = new Dictionary<ExpressionType, string>\n            {\n                { ExpressionType.Equal, \"=\" },\n                { ExpressionType.NotEqual, \"<>\" },\n                { ExpressionType.GreaterThan, \">\" },\n                { ExpressionType.GreaterThanOrEqual, \">=\" },\n                { ExpressionType.LessThan, \"<\" },\n                { ExpressionType.LessThanOrEqual, \"<=\" },\n                { ExpressionType.AndAlso, \"AND\" },\n                { ExpressionType.OrElse, \"OR\" },\n                { ExpressionType.Add, \"+\" },\n                { ExpressionType.Subtract, \"-\" },\n                { ExpressionType.Multiply, \"*\" },\n                { ExpressionType.Divide, \"/\" },\n                { ExpressionType.Modulo, \"%\" },\n            };\n        }\n\n        /// <summary>\n        /// Parses a predicate expression into a SQL WHERE clause.\n        /// </summary>\n        public string ParsePredicate<TEntity>(\n            Expression<Func<TEntity, bool>> predicate, \n            SqlQueryBuilder queryBuilder) where TEntity : class\n        {\n            _queryBuilder = queryBuilder;\n            return Visit(predicate.Body);\n        }\n\n        /// <summary>\n        /// Main visitor method that dispatches to specific handlers.\n        /// </summary>\n        private string Visit(Expression expression)\n        {\n            return expression switch\n            {\n                BinaryExpression binary => VisitBinary(binary),\n                MemberExpression member => VisitMember(member),\n                ConstantExpression constant => VisitConstant(constant),\n                UnaryExpression unary => VisitUnary(unary),\n                MethodCallExpression methodCall => VisitMethodCall(methodCall),\n                NewArrayExpression newArray => VisitNewArray(newArray),\n                _ => throw new NotSupportedException(\n                    $\"Expression type '{expression.GetType().Name}' is not supported.\")\n            };\n        }\n\n        /// <summary>\n        /// Visits binary expressions (==, !=, &&, ||, etc.).\n        /// </summary>\n        private string VisitBinary(BinaryExpression expression)\n        {\n            // Handle null comparisons specially\n            if (IsNullConstant(expression.Right))\n            {\n                var left = Visit(expression.Left);\n                return expression.NodeType == ExpressionType.Equal\n                    ? $\"{left} IS NULL\"\n                    : $\"{left} IS NOT NULL\";\n            }\n\n            if (IsNullConstant(expression.Left))\n            {\n                var right = Visit(expression.Right);\n                return expression.NodeType == ExpressionType.Equal\n                    ? $\"{right} IS NULL\"\n                    : $\"{right} IS NOT NULL\";\n            }\n\n            var leftSql = Visit(expression.Left);\n            var rightSql = Visit(expression.Right);\n\n            if (!_operatorMap.TryGetValue(expression.NodeType, out var op))\n            {\n                throw new NotSupportedException(\n                    $\"Binary operator '{expression.NodeType}' is not supported.\");\n            }\n\n            // Wrap AND/OR conditions in parentheses for proper precedence\n            if (expression.NodeType == ExpressionType.AndAlso || \n                expression.NodeType == ExpressionType.OrElse)\n            {\n                return $\"({leftSql}) {op} ({rightSql})\";\n            }\n\n            return $\"{leftSql} {op} {rightSql}\";\n        }\n\n        /// <summary>\n        /// Visits member access expressions (e.g., x.Name, x.Age).\n        /// </summary>\n        private string VisitMember(MemberExpression expression)\n        {\n            // Check if this is accessing a property on the parameter (e.g., x.Name)\n            if (expression.Expression is ParameterExpression)\n            {\n                // This is a column reference\n                var metadata = EntityMapper.GetMetadata(expression.Expression.Type);\n                var property = metadata.MappedProperties\n                    .FirstOrDefault(p => p.PropertyName == expression.Member.Name);\n\n                if (property != null)\n                {\n                    return $\"[{property.ColumnName}]\";\n                }\n\n                return $\"[{expression.Member.Name}]\";\n            }\n\n            // Check if this is a captured variable or nested member access\n            // We need to evaluate it to get the actual value\n            var value = EvaluateExpression(expression);\n            var paramName = _queryBuilder.AddParameter(value);\n            return paramName;\n        }\n\n        /// <summary>\n        /// Visits constant expressions (literal values).\n        /// </summary>\n        private string VisitConstant(ConstantExpression expression)\n        {\n            if (expression.Value == null)\n            {\n                return \"NULL\";\n            }\n\n            // Add as a parameter to prevent SQL injection\n            var paramName = _queryBuilder.AddParameter(expression.Value);\n            return paramName;\n        }\n\n        /// <summary>\n        /// Visits unary expressions (!, -, Convert, etc.).\n        /// </summary>\n        private string VisitUnary(UnaryExpression expression)\n        {\n            switch (expression.NodeType)\n            {\n                case ExpressionType.Not:\n                    var operand = Visit(expression.Operand);\n                    return $\"NOT ({operand})\";\n\n                case ExpressionType.Convert:\n                case ExpressionType.ConvertChecked:\n                    // Simply visit the inner expression\n                    return Visit(expression.Operand);\n\n                case ExpressionType.Negate:\n                case ExpressionType.NegateChecked:\n                    return $\"-{Visit(expression.Operand)}\";\n\n                default:\n                    throw new NotSupportedException(\n                        $\"Unary operator '{expression.NodeType}' is not supported.\");\n            }\n        }\n\n        /// <summary>\n        /// Visits method call expressions (Contains, StartsWith, etc.).\n        /// </summary>\n        private string VisitMethodCall(MethodCallExpression expression)\n        {\n            var methodName = expression.Method.Name;\n            var declaringType = expression.Method.DeclaringType;\n\n            // String methods\n            if (declaringType == typeof(string))\n            {\n                return VisitStringMethod(expression);\n            }\n\n            // Enumerable/List Contains method (for IN clause)\n            if (methodName == \"Contains\")\n            {\n                return VisitContainsMethod(expression);\n            }\n\n            // Nullable HasValue\n            if (methodName == \"HasValue\" && declaringType?.Name.StartsWith(\"Nullable\") == true)\n            {\n                var member = Visit(expression.Object);\n                return $\"{member} IS NOT NULL\";\n            }\n\n            // Object.Equals\n            if (methodName == \"Equals\" && expression.Arguments.Count == 1)\n            {\n                var left = Visit(expression.Object);\n                var right = Visit(expression.Arguments[0]);\n                return $\"{left} = {right}\";\n            }\n\n            throw new NotSupportedException(\n                $\"Method '{methodName}' is not supported.\");\n        }\n\n        /// <summary>\n        /// Visits string method calls (Contains, StartsWith, EndsWith, etc.).\n        /// </summary>\n        private string VisitStringMethod(MethodCallExpression expression)\n        {\n            var methodName = expression.Method.Name;\n            var column = Visit(expression.Object);\n\n            switch (methodName)\n            {\n                case \"Contains\":\n                {\n                    var value = EvaluateExpression(expression.Arguments[0])?.ToString();\n                    var paramName = _queryBuilder.AddParameter($\"%{value}%\");\n                    return $\"{column} LIKE {paramName}\";\n                }\n\n                case \"StartsWith\":\n                {\n                    var value = EvaluateExpression(expression.Arguments[0])?.ToString();\n                    var paramName = _queryBuilder.AddParameter($\"{value}%\");\n                    return $\"{column} LIKE {paramName}\";\n                }\n\n                case \"EndsWith\":\n                {\n                    var value = EvaluateExpression(expression.Arguments[0])?.ToString();\n                    var paramName = _queryBuilder.AddParameter($\"%{value}\");\n                    return $\"{column} LIKE {paramName}\";\n                }\n\n                case \"ToUpper\":\n                    return $\"UPPER({column})\";\n\n                case \"ToLower\":\n                    return $\"LOWER({column})\";\n\n                case \"Trim\":\n                    return $\"LTRIM(RTRIM({column}))\";\n\n                case \"TrimStart\":\n                    return $\"LTRIM({column})\";\n\n                case \"TrimEnd\":\n                    return $\"RTRIM({column})\";\n\n                case \"IsNullOrEmpty\":\n                    return $\"({column} IS NULL OR {column} = '')\";\n\n                case \"IsNullOrWhiteSpace\":\n                    return $\"({column} IS NULL OR LTRIM(RTRIM({column})) = '')\";\n\n                case \"Equals\":\n                {\n                    var value = EvaluateExpression(expression.Arguments[0]);\n                    var paramName = _queryBuilder.AddParameter(value);\n                    \n                    // Check for StringComparison argument\n                    if (expression.Arguments.Count > 1)\n                    {\n                        var comparison = (StringComparison)EvaluateExpression(expression.Arguments[1]);\n                        if (comparison == StringComparison.OrdinalIgnoreCase ||\n                            comparison == StringComparison.CurrentCultureIgnoreCase)\n                        {\n                            return $\"LOWER({column}) = LOWER({paramName})\";\n                        }\n                    }\n                    \n                    return $\"{column} = {paramName}\";\n                }\n\n                case \"Substring\":\n                {\n                    var startIndex = EvaluateExpression(expression.Arguments[0]);\n                    // SQL SUBSTRING is 1-based, C# is 0-based\n                    var sqlStart = Convert.ToInt32(startIndex) + 1;\n\n                    if (expression.Arguments.Count > 1)\n                    {\n                        var length = EvaluateExpression(expression.Arguments[1]);\n                        return $\"SUBSTRING({column}, {sqlStart}, {length})\";\n                    }\n                    \n                    return $\"SUBSTRING({column}, {sqlStart}, LEN({column}))\";\n                }\n\n                case \"Replace\":\n                {\n                    var oldValue = EvaluateExpression(expression.Arguments[0]);\n                    var newValue = EvaluateExpression(expression.Arguments[1]);\n                    var oldParam = _queryBuilder.AddParameter(oldValue);\n                    var newParam = _queryBuilder.AddParameter(newValue);\n                    return $\"REPLACE({column}, {oldParam}, {newParam})\";\n                }\n\n                default:\n                    throw new NotSupportedException(\n                        $\"String method '{methodName}' is not supported.\");\n            }\n        }\n\n        /// <summary>\n        /// Visits Contains method for IN clause support.\n        /// Handles both list.Contains(x.Property) and x.Property.Contains(value).\n        /// </summary>\n        private string VisitContainsMethod(MethodCallExpression expression)\n        {\n            // Check if this is a static Enumerable.Contains or instance List.Contains\n            if (expression.Object != null)\n            {\n                // Instance method: list.Contains(x.Property)\n                var collection = EvaluateExpression(expression.Object) as IEnumerable;\n                if (collection != null)\n                {\n                    var column = Visit(expression.Arguments[0]);\n                    return BuildInClause(column, collection);\n                }\n            }\n            else if (expression.Method.DeclaringType == typeof(Enumerable))\n            {\n                // Static method: Enumerable.Contains(list, x.Property)\n                var collection = EvaluateExpression(expression.Arguments[0]) as IEnumerable;\n                if (collection != null)\n                {\n                    var column = Visit(expression.Arguments[1]);\n                    return BuildInClause(column, collection);\n                }\n            }\n\n            throw new NotSupportedException(\"Contains method usage is not supported.\");\n        }\n\n        /// <summary>\n        /// Builds an IN clause from a collection.\n        /// </summary>\n        private string BuildInClause(string column, IEnumerable collection)\n        {\n            var values = new List<string>();\n            \n            foreach (var item in collection)\n            {\n                var paramName = _queryBuilder.AddParameter(item);\n                values.Add(paramName);\n            }\n\n            if (!values.Any())\n            {\n                // Empty collection - always false\n                return \"1 = 0\";\n            }\n\n            return $\"{column} IN ({string.Join(\", \", values)})\";\n        }\n\n        /// <summary>\n        /// Visits new array expressions.\n        /// </summary>\n        private string VisitNewArray(NewArrayExpression expression)\n        {\n            var values = new List<object>();\n            \n            foreach (var item in expression.Expressions)\n            {\n                values.Add(EvaluateExpression(item));\n            }\n\n            var paramNames = values.Select(v => _queryBuilder.AddParameter(v));\n            return string.Join(\", \", paramNames);\n        }\n\n        /// <summary>\n        /// Checks if an expression represents a null constant.\n        /// </summary>\n        private static bool IsNullConstant(Expression expression)\n        {\n            if (expression is ConstantExpression constant)\n            {\n                return constant.Value == null;\n            }\n\n            // Check for null in a captured variable\n            if (expression is MemberExpression member)\n            {\n                try\n                {\n                    var value = EvaluateExpression(expression);\n                    return value == null;\n                }\n                catch\n                {\n                    return false;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Evaluates an expression to get its runtime value.\n        /// Used for captured variables and complex expressions.\n        /// </summary>\n        private static object EvaluateExpression(Expression expression)\n        {\n            // Handle constant expressions directly\n            if (expression is ConstantExpression constant)\n            {\n                return constant.Value;\n            }\n\n            // For other expressions, compile and execute\n            try\n            {\n                var lambda = Expression.Lambda(expression);\n                var compiled = lambda.Compile();\n                return compiled.DynamicInvoke();\n            }\n            catch (Exception ex)\n            {\n                throw new InvalidOperationException(\n                    $\"Failed to evaluate expression: {expression}\", ex);\n            }\n        }\n    }\n}\n```\n\n---\n\n## 11. Putting It All Together - Complete Example\n\nNow let's create a complete working example that demonstrates all the components.\n\n### Sample Entities\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\n\nnamespace MiniORM.Demo.Entities\n{\n    /// <summary>\n    /// User entity demonstrating attribute-based mapping.\n    /// </summary>\n    [Table(\"Users\")]\n    public class User : EntityBase\n    {\n        private int _id;\n        private string _username;\n        private string _email;\n        private string _passwordHash;\n        private DateTime _createdAt;\n        private DateTime? _lastLoginAt;\n        private bool _isActive;\n        private int? _departmentId;\n\n        [PrimaryKey(AutoGenerate = true)]\n        [Column(\"Id\")]\n        public int Id\n        {\n            get => _id;\n            set => SetProperty(ref _id, value);\n        }\n\n        [Column(\"Username\", MaxLength = 50)]\n        public string Username\n        {\n            get => _username;\n            set => SetProperty(ref _username, value);\n        }\n\n        [Column(\"Email\", MaxLength = 100)]\n        public string Email\n        {\n            get => _email;\n            set => SetProperty(ref _email, value);\n        }\n\n        [Column(\"PasswordHash\", MaxLength = 256)]\n        public string PasswordHash\n        {\n            get => _passwordHash;\n            set => SetProperty(ref _passwordHash, value);\n        }\n\n        [Column(\"CreatedAt\")]\n        public DateTime CreatedAt\n        {\n            get => _createdAt;\n            set => SetProperty(ref _createdAt, value);\n        }\n\n        [Column(\"LastLoginAt\", IsNullable = true)]\n        public DateTime? LastLoginAt\n        {\n            get => _lastLoginAt;\n            set => SetProperty(ref _lastLoginAt, value);\n        }\n\n        [Column(\"IsActive\")]\n        public bool IsActive\n        {\n            get => _isActive;\n            set => SetProperty(ref _isActive, value);\n        }\n\n        [Column(\"DepartmentId\", IsNullable = true)]\n        [ForeignKey(typeof(Department))]\n        public int? DepartmentId\n        {\n            get => _departmentId;\n            set => SetProperty(ref _departmentId, value);\n        }\n\n        // Navigation property (not mapped to database)\n        [NotMapped]\n        public Department Department { get; set; }\n\n        // Computed property (not mapped)\n        [NotMapped]\n        public string DisplayName => $\"{Username} <{Email}>\";\n    }\n\n    /// <summary>\n    /// Department entity.\n    /// </summary>\n    [Table(\"Departments\")]\n    public class Department : EntityBase\n    {\n        private int _id;\n        private string _name;\n        private string _description;\n\n        [PrimaryKey(AutoGenerate = true)]\n        public int Id\n        {\n            get => _id;\n            set => SetProperty(ref _id, value);\n        }\n\n        [Column(\"Name\", MaxLength = 100)]\n        public string Name\n        {\n            get => _name;\n            set => SetProperty(ref _name, value);\n        }\n\n        [Column(\"Description\", MaxLength = 500, IsNullable = true)]\n        public string Description\n        {\n            get => _description;\n            set => SetProperty(ref _description, value);\n        }\n\n        [NotMapped]\n        public List<User> Users { get; set; } = new List<User>();\n    }\n\n    /// <summary>\n    /// Product entity for e-commerce scenarios.\n    /// </summary>\n    [Table(\"Products\", Schema = \"dbo\")]\n    public class Product : EntityBase\n    {\n        private int _id;\n        private string _name;\n        private string _description;\n        private decimal _price;\n        private int _stockQuantity;\n        private int _categoryId;\n        private bool _isAvailable;\n        private DateTime _createdAt;\n\n        [PrimaryKey(AutoGenerate = true)]\n        public int Id\n        {\n            get => _id;\n            set => SetProperty(ref _id, value);\n        }\n\n        [Column(\"Name\", MaxLength = 200)]\n        public string Name\n        {\n            get => _name;\n            set => SetProperty(ref _name, value);\n        }\n\n        [Column(\"Description\", MaxLength = 2000, IsNullable = true)]\n        public string Description\n        {\n            get => _description;\n            set => SetProperty(ref _description, value);\n        }\n\n        [Column(\"Price\")]\n        public decimal Price\n        {\n            get => _price;\n            set => SetProperty(ref _price, value);\n        }\n\n        [Column(\"StockQuantity\")]\n        public int StockQuantity\n        {\n            get => _stockQuantity;\n            set => SetProperty(ref _stockQuantity, value);\n        }\n\n        [Column(\"CategoryId\")]\n        [ForeignKey(typeof(Category))]\n        public int CategoryId\n        {\n            get => _categoryId;\n            set => SetProperty(ref _categoryId, value);\n        }\n\n        [Column(\"IsAvailable\")]\n        public bool IsAvailable\n        {\n            get => _isAvailable;\n            set => SetProperty(ref _isAvailable, value);\n        }\n\n        [Column(\"CreatedAt\")]\n        public DateTime CreatedAt\n        {\n            get => _createdAt;\n            set => SetProperty(ref _createdAt, value);\n        }\n\n        [NotMapped]\n        public Category Category { get; set; }\n    }\n\n    /// <summary>\n    /// Category entity.\n    /// </summary>\n    [Table(\"Categories\")]\n    public class Category : EntityBase\n    {\n        private int _id;\n        private string _name;\n        private int? _parentCategoryId;\n\n        [PrimaryKey(AutoGenerate = true)]\n        public int Id\n        {\n            get => _id;\n            set => SetProperty(ref _id, value);\n        }\n\n        [Column(\"Name\", MaxLength = 100)]\n        public string Name\n        {\n            get => _name;\n            set => SetProperty(ref _name, value);\n        }\n\n        [Column(\"ParentCategoryId\", IsNullable = true)]\n        public int? ParentCategoryId\n        {\n            get => _parentCategoryId;\n            set => SetProperty(ref _parentCategoryId, value);\n        }\n\n        [NotMapped]\n        public List<Product> Products { get; set; } = new List<Product>();\n    }\n}\n```\n\n### Database Setup Helper\n\n```csharp\nusing System;\nusing System.Data;\n\nnamespace MiniORM.Demo\n{\n    /// <summary>\n    /// Helper class to set up the database schema for testing.\n    /// </summary>\n    public static class DatabaseSetup\n    {\n        public static void CreateTables(DbContext context)\n        {\n            var createTablesSql = @\"\n                -- Create Departments table\n                IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Departments')\n                BEGIN\n                    CREATE TABLE [Departments] (\n                        [Id] INT IDENTITY(1,1) PRIMARY KEY,\n                        [Name] NVARCHAR(100) NOT NULL,\n                        [Description] NVARCHAR(500) NULL\n                    );\n                END\n\n                -- Create Users table\n                IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Users')\n                BEGIN\n                    CREATE TABLE [Users] (\n                        [Id] INT IDENTITY(1,1) PRIMARY KEY,\n                        [Username] NVARCHAR(50) NOT NULL,\n                        [Email] NVARCHAR(100) NOT NULL,\n                        [PasswordHash] NVARCHAR(256) NOT NULL,\n                        [CreatedAt] DATETIME2 NOT NULL DEFAULT GETDATE(),\n                        [LastLoginAt] DATETIME2 NULL,\n                        [IsActive] BIT NOT NULL DEFAULT 1,\n                        [DepartmentId] INT NULL,\n                        CONSTRAINT FK_Users_Department FOREIGN KEY ([DepartmentId]) \n                            REFERENCES [Departments]([Id])\n                    );\n                END\n\n                -- Create Categories table\n                IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Categories')\n                BEGIN\n                    CREATE TABLE [Categories] (\n                        [Id] INT IDENTITY(1,1) PRIMARY KEY,\n                        [Name] NVARCHAR(100) NOT NULL,\n                        [ParentCategoryId] INT NULL,\n                        CONSTRAINT FK_Categories_Parent FOREIGN KEY ([ParentCategoryId]) \n                            REFERENCES [Categories]([Id])\n                    );\n                END\n\n                -- Create Products table\n                IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Products')\n                BEGIN\n                    CREATE TABLE [Products] (\n                        [Id] INT IDENTITY(1,1) PRIMARY KEY,\n                        [Name] NVARCHAR(200) NOT NULL,\n                        [Description] NVARCHAR(2000) NULL,\n                        [Price] DECIMAL(18,2) NOT NULL,\n                        [StockQuantity] INT NOT NULL DEFAULT 0,\n                        [CategoryId] INT NOT NULL,\n                        [IsAvailable] BIT NOT NULL DEFAULT 1,\n                        [CreatedAt] DATETIME2 NOT NULL DEFAULT GETDATE(),\n                        CONSTRAINT FK_Products_Category FOREIGN KEY ([CategoryId]) \n                            REFERENCES [Categories]([Id])\n                    );\n                END\n            \";\n\n            context.ExecuteNonQuery(createTablesSql);\n            Console.WriteLine(\"Database tables created successfully.\");\n        }\n\n        public static void SeedData(DbContext context)\n        {\n            var seedSql = @\"\n                -- Seed Departments\n                IF NOT EXISTS (SELECT 1 FROM [Departments])\n                BEGIN\n                    INSERT INTO [Departments] ([Name], [Description]) VALUES \n                        ('Engineering', 'Software Development Team'),\n                        ('Marketing', 'Marketing and Sales Team'),\n                        ('HR', 'Human Resources');\n                END\n\n                -- Seed Categories\n                IF NOT EXISTS (SELECT 1 FROM [Categories])\n                BEGIN\n                    INSERT INTO [Categories] ([Name], [ParentCategoryId]) VALUES \n                        ('Electronics', NULL),\n                        ('Clothing', NULL),\n                        ('Books', NULL);\n                    \n                    INSERT INTO [Categories] ([Name], [ParentCategoryId]) VALUES \n                        ('Smartphones', 1),\n                        ('Laptops', 1),\n                        ('Men''s Clothing', 2),\n                        ('Women''s Clothing', 2);\n                END\n            \";\n\n            context.ExecuteNonQuery(seedSql);\n            Console.WriteLine(\"Seed data inserted successfully.\");\n        }\n\n        public static void DropTables(DbContext context)\n        {\n            var dropTablesSql = @\"\n                IF EXISTS (SELECT * FROM sys.tables WHERE name = 'Products')\n                    DROP TABLE [Products];\n                IF EXISTS (SELECT * FROM sys.tables WHERE name = 'Users')\n                    DROP TABLE [Users];\n                IF EXISTS (SELECT * FROM sys.tables WHERE name = 'Categories')\n                    DROP TABLE [Categories];\n                IF EXISTS (SELECT * FROM sys.tables WHERE name = 'Departments')\n                    DROP TABLE [Departments];\n            \";\n\n            context.ExecuteNonQuery(dropTablesSql);\n            Console.WriteLine(\"Database tables dropped successfully.\");\n        }\n    }\n}\n```\n\n### Main Program - Demonstrating All Features\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing MiniORM.Core;\nusing MiniORM.Core.Connection;\nusing MiniORM.Core.Query;\nusing MiniORM.Core.Repository;\nusing MiniORM.Core.UnitOfWork;\nusing MiniORM.Demo.Entities;\n\nnamespace MiniORM.Demo\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"===========================================\");\n            Console.WriteLine(\"   MiniORM - Simple C# ORM Demonstration   \");\n            Console.WriteLine(\"===========================================\\n\");\n\n            // Connection string - update this for your database\n            var connectionString = \"Server=localhost;Database=MiniOrmDemo;Truste",
                    "images": [],
                    "tokenCount": 5307,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the ExpressionParser.cs file. I was in the middle of the VisitBinary method.",
                        "signature": "EqwCCkYIChgCKkAu/aK7oTUcobTxSL7tj2b0yy5aEtjBtRcu8c9aMno337fQxpGg3S5fhaD8JI+d2XtJR9WWWYAnfOOtNLMm0jz3EgxRHcq5Pc/UNtsYZ0saDJcl9055OHOYrEmCXyIwVQa2dgcD11YnnArY5HKmDjXJKbYDRHT4sDdoq+CLzAv1u8QRPzY9I9mbzmOFE1HvKpMBaTmsRTjqpvujRbp7DHFSgyr0/LZpO4as5+iXtpLPy2mvdudCegP92i6y7wvIEv1LK9g+0m0M3BlD9vzd7XlH49Cd/vB8U9sRcBHm/MnwiIpHLdOlaOQMxutVrQZ4cdaMdKjsCnYuPwa+XwOK4CPeEdkn9rwS7woBccAM5htX6lpUD6YXvq4umSL4CdTY60qVPZIXGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 5,
            "parentIdx": 4,
            "childrenIdxs": [
                6
            ],
            "createdAt": "2025-12-04T18:02:29.212Z",
            "updatedAt": "2025-12-04T18:02:43.035Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `Program.cs` file:\n\n### Program.cs (Complete)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing MiniORM.Core;\nusing MiniORM.Core.Connection;\nusing MiniORM.Core.Query;\nusing MiniORM.Core.Repository;\nusing MiniORM.Core.UnitOfWork;\nusing MiniORM.Demo.Entities;\n\nnamespace MiniORM.Demo\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"===========================================\");\n            Console.WriteLine(\"   MiniORM - Simple C# ORM Demonstration   \");\n            Console.WriteLine(\"===========================================\\n\");\n\n            // Connection string - update this for your database\n            var connectionString = \"Server=localhost;Database=MiniOrmDemo;Trusted_Connection=True;TrustServerCertificate=True;\";\n\n            // Create connection factory (Factory Pattern)\n            var connectionFactory = new SqlConnectionFactory(connectionString);\n\n            // Create DbContext\n            using var context = new DbContext(connectionFactory);\n\n            try\n            {\n                // Setup database\n                Console.WriteLine(\"Setting up database...\\n\");\n                DatabaseSetup.CreateTables(context);\n                DatabaseSetup.SeedData(context);\n\n                // Run demonstrations\n                DemonstrateBasicCRUD(context);\n                DemonstrateQueryBuilder(context);\n                DemonstrateRepository(context);\n                DemonstrateUnitOfWork(context);\n                DemonstrateExpressionQueries(context);\n                DemonstrateTransactions(context);\n                DemonstrateChangeTracking(context);\n\n                Console.WriteLine(\"\\n===========================================\");\n                Console.WriteLine(\"   All demonstrations completed!           \");\n                Console.WriteLine(\"===========================================\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"\\nError: {ex.Message}\");\n                Console.WriteLine($\"Stack Trace: {ex.StackTrace}\");\n            }\n\n            Console.WriteLine(\"\\nPress any key to exit...\");\n            Console.ReadKey();\n        }\n\n        /// <summary>\n        /// Demonstrates basic CRUD operations using the Repository.\n        /// </summary>\n        static void DemonstrateBasicCRUD(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- Basic CRUD Operations ---\\n\");\n\n            var userRepo = new Repository<User>(context);\n\n            // CREATE - Insert a new user\n            Console.WriteLine(\"1. Creating a new user...\");\n            var newUser = new User\n            {\n                Username = \"john_doe\",\n                Email = \"john@example.com\",\n                PasswordHash = \"hashed_password_123\",\n                CreatedAt = DateTime.UtcNow,\n                IsActive = true,\n                DepartmentId = 1\n            };\n\n            var createdUser = userRepo.Add(newUser);\n            Console.WriteLine($\"   Created user with ID: {createdUser.Id}\");\n            Console.WriteLine($\"   Username: {createdUser.Username}\");\n            Console.WriteLine($\"   Email: {createdUser.Email}\");\n\n            // READ - Get user by ID\n            Console.WriteLine(\"\\n2. Reading user by ID...\");\n            var fetchedUser = userRepo.GetById(createdUser.Id);\n            Console.WriteLine($\"   Found user: {fetchedUser.Username} ({fetchedUser.Email})\");\n\n            // UPDATE - Modify the user\n            Console.WriteLine(\"\\n3. Updating user...\");\n            fetchedUser.Email = \"john.doe@newdomain.com\";\n            fetchedUser.LastLoginAt = DateTime.UtcNow;\n            userRepo.Update(fetchedUser);\n            Console.WriteLine($\"   Updated email to: {fetchedUser.Email}\");\n\n            // Verify update\n            var updatedUser = userRepo.GetById(fetchedUser.Id);\n            Console.WriteLine($\"   Verified email: {updatedUser.Email}\");\n\n            // READ ALL - Get all users\n            Console.WriteLine(\"\\n4. Getting all users...\");\n            var allUsers = userRepo.GetAll().ToList();\n            Console.WriteLine($\"   Total users: {allUsers.Count}\");\n            foreach (var user in allUsers)\n            {\n                Console.WriteLine($\"   - {user.Id}: {user.Username} ({user.Email})\");\n            }\n\n            // DELETE - Remove the user\n            Console.WriteLine(\"\\n5. Deleting user...\");\n            userRepo.Delete(createdUser.Id);\n            Console.WriteLine($\"   Deleted user with ID: {createdUser.Id}\");\n\n            // Verify deletion\n            var deletedUser = userRepo.GetById(createdUser.Id);\n            Console.WriteLine($\"   User exists after deletion: {deletedUser != null}\");\n        }\n\n        /// <summary>\n        /// Demonstrates the SQL Query Builder (Builder Pattern).\n        /// </summary>\n        static void DemonstrateQueryBuilder(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- SQL Query Builder Demonstration ---\\n\");\n\n            // Example 1: Simple SELECT\n            Console.WriteLine(\"1. Simple SELECT query:\");\n            var query1 = new SqlQueryBuilder()\n                .Select(\"Id\", \"Name\", \"Description\")\n                .From(\"Departments\")\n                .OrderBy(\"Name\");\n\n            Console.WriteLine($\"   SQL: {query1.BuildSelect()}\\n\");\n\n            // Example 2: SELECT with WHERE conditions\n            Console.WriteLine(\"2. SELECT with WHERE conditions:\");\n            var query2 = new SqlQueryBuilder()\n                .SelectAll()\n                .From(\"Products\")\n                .WhereGreaterThan(\"Price\", 100)\n                .Where(\"IsAvailable\", true)\n                .OrderByDescending(\"Price\")\n                .Top(10);\n\n            var (sql2, params2) = query2.Build();\n            Console.WriteLine($\"   SQL: {sql2}\");\n            Console.WriteLine($\"   Parameters: {string.Join(\", \", params2.Select(p => $\"{p.Name}={p.Value}\"))}\\n\");\n\n            // Example 3: SELECT with JOIN\n            Console.WriteLine(\"3. SELECT with JOIN:\");\n            var query3 = new SqlQueryBuilder()\n                .Select(\"u.Username\", \"u.Email\", \"d.Name AS DepartmentName\")\n                .From(\"Users\", \"u\")\n                .LeftJoin(\"Departments\", \"[u].[DepartmentId] = [d].[Id]\", \"d\")\n                .WhereNotNull(\"u.DepartmentId\");\n\n            Console.WriteLine($\"   SQL: {query3.BuildSelect()}\\n\");\n\n            // Example 4: SELECT with pagination\n            Console.WriteLine(\"4. SELECT with pagination (Page 2, 10 items per page):\");\n            var query4 = new SqlQueryBuilder()\n                .SelectAll()\n                .From(\"Products\")\n                .OrderBy(\"Id\")\n                .Page(2, 10);\n\n            Console.WriteLine($\"   SQL: {query4.BuildSelect()}\\n\");\n\n            // Example 5: Aggregation query\n            Console.WriteLine(\"5. Aggregation query:\");\n            var query5 = new SqlQueryBuilder()\n                .Select(\"CategoryId\")\n                .SelectCount(\"*\")\n                .From(\"Products\")\n                .GroupBy(\"CategoryId\")\n                .Having(\"COUNT(*) > 0\");\n\n            Console.WriteLine($\"   SQL: {query5.BuildSelect()}\\n\");\n\n            // Example 6: INSERT query\n            Console.WriteLine(\"6. INSERT query:\");\n            var insertQuery = new InsertQueryBuilder()\n                .Into(\"Products\")\n                .Value(\"Name\", \"New Product\")\n                .Value(\"Price\", 99.99m)\n                .Value(\"CategoryId\", 1)\n                .Value(\"IsAvailable\", true)\n                .Value(\"StockQuantity\", 100)\n                .Value(\"CreatedAt\", DateTime.UtcNow);\n\n            var (insertSql, insertParams) = insertQuery.Build();\n            Console.WriteLine($\"   SQL: {insertSql}\");\n            Console.WriteLine($\"   Parameters: {string.Join(\", \", insertParams.Select(p => $\"{p.Name}={p.Value}\"))}\\n\");\n\n            // Example 7: UPDATE query\n            Console.WriteLine(\"7. UPDATE query:\");\n            var updateQuery = new UpdateQueryBuilder()\n                .Table(\"Products\")\n                .Set(\"Price\", 149.99m)\n                .Set(\"StockQuantity\", 50)\n                .Where(\"Id\", 1);\n\n            var (updateSql, updateParams) = updateQuery.Build();\n            Console.WriteLine($\"   SQL: {updateSql}\");\n            Console.WriteLine($\"   Parameters: {string.Join(\", \", updateParams.Select(p => $\"{p.Name}={p.Value}\"))}\\n\");\n\n            // Example 8: DELETE query\n            Console.WriteLine(\"8. DELETE query:\");\n            var deleteQuery = new DeleteQueryBuilder()\n                .From(\"Products\")\n                .Where(\"IsAvailable\", false)\n                .Where(\"StockQuantity\", 0);\n\n            var (deleteSql, deleteParams) = deleteQuery.Build();\n            Console.WriteLine($\"   SQL: {deleteSql}\");\n            Console.WriteLine($\"   Parameters: {string.Join(\", \", deleteParams.Select(p => $\"{p.Name}={p.Value}\"))}\");\n        }\n\n        /// <summary>\n        /// Demonstrates the Repository Pattern.\n        /// </summary>\n        static void DemonstrateRepository(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- Repository Pattern Demonstration ---\\n\");\n\n            var departmentRepo = new Repository<Department>(context);\n            var categoryRepo = new Repository<Category>(context);\n\n            // Get all departments\n            Console.WriteLine(\"1. Getting all departments:\");\n            var departments = departmentRepo.GetAll().ToList();\n            foreach (var dept in departments)\n            {\n                Console.WriteLine($\"   - {dept.Id}: {dept.Name} - {dept.Description}\");\n            }\n\n            // Get all categories with hierarchy\n            Console.WriteLine(\"\\n2. Getting all categories:\");\n            var categories = categoryRepo.GetAll().ToList();\n            var rootCategories = categories.Where(c => c.ParentCategoryId == null);\n            \n            foreach (var cat in rootCategories)\n            {\n                Console.WriteLine($\"   - {cat.Name}\");\n                var children = categories.Where(c => c.ParentCategoryId == cat.Id);\n                foreach (var child in children)\n                {\n                    Console.WriteLine($\"     └── {child.Name}\");\n                }\n            }\n\n            // Count example\n            Console.WriteLine(\"\\n3. Counting entities:\");\n            var totalDepts = departmentRepo.Count();\n            var totalCategories = categoryRepo.Count();\n            Console.WriteLine($\"   Total departments: {totalDepts}\");\n            Console.WriteLine($\"   Total categories: {totalCategories}\");\n\n            // Add a new department\n            Console.WriteLine(\"\\n4. Adding a new department:\");\n            var newDept = new Department\n            {\n                Name = \"Finance\",\n                Description = \"Financial Operations Team\"\n            };\n            departmentRepo.Add(newDept);\n            Console.WriteLine($\"   Added department: {newDept.Name} (ID: {newDept.Id})\");\n\n            // Cleanup\n            departmentRepo.Delete(newDept.Id);\n            Console.WriteLine($\"   Cleaned up: Deleted department {newDept.Id}\");\n        }\n\n        /// <summary>\n        /// Demonstrates the Unit of Work Pattern.\n        /// </summary>\n        static void DemonstrateUnitOfWork(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- Unit of Work Pattern Demonstration ---\\n\");\n\n            using var unitOfWork = new UnitOfWork(context);\n\n            // Get repositories from unit of work\n            var userRepo = unitOfWork.Repository<User>();\n            var deptRepo = unitOfWork.Repository<Department>();\n\n            Console.WriteLine(\"1. Adding multiple entities through Unit of Work:\");\n\n            // Add a department\n            var newDept = new Department\n            {\n                Name = \"Research\",\n                Description = \"Research and Development\"\n            };\n            deptRepo.Add(newDept);\n            Console.WriteLine($\"   Added department: {newDept.Name} (pending)\");\n\n            // Add users\n            var user1 = new User\n            {\n                Username = \"alice\",\n                Email = \"alice@example.com\",\n                PasswordHash = \"hash1\",\n                CreatedAt = DateTime.UtcNow,\n                IsActive = true\n            };\n\n            var user2 = new User\n            {\n                Username = \"bob\",\n                Email = \"bob@example.com\",\n                PasswordHash = \"hash2\",\n                CreatedAt = DateTime.UtcNow,\n                IsActive = true\n            };\n\n            userRepo.Add(user1);\n            userRepo.Add(user2);\n            Console.WriteLine($\"   Added users: {user1.Username}, {user2.Username} (pending)\");\n\n            // Save all changes in a single transaction\n            Console.WriteLine(\"\\n2. Saving all changes (single transaction):\");\n            var savedCount = unitOfWork.SaveChanges();\n            Console.WriteLine($\"   Saved {savedCount} entities\");\n\n            // Verify the IDs were generated\n            Console.WriteLine($\"   Department ID: {newDept.Id}\");\n            Console.WriteLine($\"   User 1 ID: {user1.Id}\");\n            Console.WriteLine($\"   User 2 ID: {user2.Id}\");\n\n            // Cleanup\n            Console.WriteLine(\"\\n3. Cleaning up test data:\");\n            userRepo.Delete(user1);\n            userRepo.Delete(user2);\n            deptRepo.Delete(newDept);\n            unitOfWork.SaveChanges();\n            Console.WriteLine(\"   Test data cleaned up\");\n        }\n\n        /// <summary>\n        /// Demonstrates LINQ-like expression queries.\n        /// </summary>\n        static void DemonstrateExpressionQueries(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- Expression Query Demonstration ---\\n\");\n\n            var deptRepo = new Repository<Department>(context);\n            var categoryRepo = new Repository<Category>(context);\n\n            // First, let's add some test data\n            Console.WriteLine(\"1. Setting up test data...\");\n            var testDept = new Department { Name = \"TestDept\", Description = \"Test Department\" };\n            deptRepo.Add(testDept);\n\n            // Simple equality\n            Console.WriteLine(\"\\n2. Finding departments by name (equality):\");\n            var engDept = deptRepo.FirstOrDefault(d => d.Name == \"Engineering\");\n            if (engDept != null)\n            {\n                Console.WriteLine($\"   Found: {engDept.Name} - {engDept.Description}\");\n            }\n\n            // String Contains (LIKE '%value%')\n            Console.WriteLine(\"\\n3. Finding departments containing 'ing' in name:\");\n            var deptWithIng = deptRepo.Find(d => d.Name.Contains(\"ing\")).ToList();\n            foreach (var dept in deptWithIng)\n            {\n                Console.WriteLine($\"   - {dept.Name}\");\n            }\n\n            // String StartsWith\n            Console.WriteLine(\"\\n4. Finding departments starting with 'M':\");\n            var deptStartingWithM = deptRepo.Find(d => d.Name.StartsWith(\"M\")).ToList();\n            foreach (var dept in deptStartingWithM)\n            {\n                Console.WriteLine($\"   - {dept.Name}\");\n            }\n\n            // Multiple conditions with AND\n            Console.WriteLine(\"\\n5. Finding categories with ParentCategoryId = 1:\");\n            var childCategories = categoryRepo.Find(c => c.ParentCategoryId == 1).ToList();\n            foreach (var cat in childCategories)\n            {\n                Console.WriteLine($\"   - {cat.Name} (Parent: {cat.ParentCategoryId})\");\n            }\n\n            // IS NULL check\n            Console.WriteLine(\"\\n6. Finding root categories (ParentCategoryId IS NULL):\");\n            var rootCategories = categoryRepo.Find(c => c.ParentCategoryId == null).ToList();\n            foreach (var cat in rootCategories)\n            {\n                Console.WriteLine($\"   - {cat.Name}\");\n            }\n\n            // Contains with list (IN clause)\n            Console.WriteLine(\"\\n7. Finding departments by name list (IN clause):\");\n            var namesToFind = new List<string> { \"Engineering\", \"Marketing\", \"HR\" };\n            var foundDepts = deptRepo.Find(d => namesToFind.Contains(d.Name)).ToList();\n            foreach (var dept in foundDepts)\n            {\n                Console.WriteLine($\"   - {dept.Name}\");\n            }\n\n            // Any() check\n            Console.WriteLine(\"\\n8. Checking if any department exists with name 'Sales':\");\n            var hasSales = deptRepo.Any(d => d.Name == \"Sales\");\n            Console.WriteLine($\"   Has 'Sales' department: {hasSales}\");\n\n            // Count with condition\n            Console.WriteLine(\"\\n9. Counting root categories:\");\n            var rootCount = categoryRepo.Count(c => c.ParentCategoryId == null);\n            Console.WriteLine($\"   Root category count: {rootCount}\");\n\n            // Cleanup\n            deptRepo.Delete(testDept.Id);\n            Console.WriteLine(\"\\n   Test data cleaned up\");\n        }\n\n        /// <summary>\n        /// Demonstrates transaction handling.\n        /// </summary>\n        static void DemonstrateTransactions(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- Transaction Demonstration ---\\n\");\n\n            var deptRepo = new Repository<Department>(context);\n\n            // Successful transaction\n            Console.WriteLine(\"1. Successful transaction:\");\n            try\n            {\n                context.BeginTransaction();\n                \n                var dept1 = new Department { Name = \"TxDept1\", Description = \"Transaction Test 1\" };\n                var dept2 = new Department { Name = \"TxDept2\", Description = \"Transaction Test 2\" };\n                \n                deptRepo.Add(dept1);\n                deptRepo.Add(dept2);\n                \n                context.Commit();\n                Console.WriteLine($\"   Transaction committed successfully\");\n                Console.WriteLine($\"   Created departments: {dept1.Id}, {dept2.Id}\");\n\n                // Cleanup\n                deptRepo.Delete(dept1.Id);\n                deptRepo.Delete(dept2.Id);\n            }\n            catch (Exception ex)\n            {\n                context.Rollback();\n                Console.WriteLine($\"   Transaction failed: {ex.Message}\");\n            }\n\n            // Rollback demonstration\n            Console.WriteLine(\"\\n2. Transaction rollback demonstration:\");\n            var countBefore = deptRepo.Count();\n            Console.WriteLine($\"   Departments before: {countBefore}\");\n\n            try\n            {\n                context.BeginTransaction();\n                \n                var dept = new Department { Name = \"RollbackTest\", Description = \"Will be rolled back\" };\n                deptRepo.Add(dept);\n                Console.WriteLine($\"   Added department (in transaction): {dept.Id}\");\n\n                // Simulate an error\n                throw new InvalidOperationException(\"Simulated error!\");\n            }\n            catch (InvalidOperationException)\n            {\n                context.Rollback();\n                Console.WriteLine(\"   Transaction rolled back due to error\");\n            }\n\n            var countAfter = deptRepo.Count();\n            Console.WriteLine($\"   Departments after rollback: {countAfter}\");\n            Console.WriteLine($\"   Count unchanged: {countBefore == countAfter}\");\n        }\n\n        /// <summary>\n        /// Demonstrates change tracking functionality.\n        /// </summary>\n        static void DemonstrateChangeTracking(DbContext context)\n        {\n            Console.WriteLine(\"\\n--- Change Tracking Demonstration ---\\n\");\n\n            using var unitOfWork = new UnitOfWork(context);\n            var deptRepo = unitOfWork.Repository<Department>();\n\n            // Add and save a department first\n            Console.WriteLine(\"1. Creating and tracking a new entity:\");\n            var dept = new Department \n            { \n                Name = \"TrackingTest\", \n                Description = \"Testing change tracking\" \n            };\n            \n            Console.WriteLine($\"   Initial state: {dept.State}\");\n            \n            deptRepo.Add(dept);\n            Console.WriteLine($\"   After Add(): {dept.State}\");\n            \n            unitOfWork.SaveChanges();\n            Console.WriteLine($\"   After SaveChanges(): {dept.State}\");\n\n            // Modify the entity\n            Console.WriteLine(\"\\n2. Modifying tracked entity:\");\n            dept.Description = \"Modified description\";\n            Console.WriteLine($\"   After modification: {dept.State}\");\n\n            // Check what properties changed\n            var entry = unitOfWork.ChangeTracker.GetEntry(dept);\n            if (entry != null)\n            {\n                var modifiedProps = entry.GetModifiedProperties().ToList();\n                Console.WriteLine($\"   Modified properties: {string.Join(\", \", modifiedProps)}\");\n            }\n\n            // Save modifications\n            unitOfWork.SaveChanges();\n            Console.WriteLine($\"   After SaveChanges(): {dept.State}\");\n\n            // Delete entity\n            Console.WriteLine(\"\\n3. Deleting tracked entity:\");\n            deptRepo.Delete(dept);\n            Console.WriteLine($\"   After Delete(): {dept.State}\");\n            \n            unitOfWork.SaveChanges();\n            Console.WriteLine(\"   Entity deleted and removed from tracking\");\n\n            // Show tracker statistics\n            Console.WriteLine($\"\\n4. Change Tracker Statistics:\");\n            Console.WriteLine($\"   Total tracked entities: {unitOfWork.ChangeTracker.Count}\");\n        }\n    }\n}\n```\n\n---\n\n## Design Patterns Summary\n\nHere's a comprehensive summary of all the design patterns used in our ORM:\n\n### 1. **Metadata Pattern** (Attributes)\n```\nLocation: Attributes/*.cs\nPurpose: Attach mapping metadata to entity classes and properties\nExample: [Table(\"Users\")], [Column(\"Id\")], [PrimaryKey]\n```\n\n### 2. **Singleton Pattern** (DbContext)\n```\nLocation: DbContext.cs\nPurpose: Ensure single database connection manager instance\nExample: DbContext.GetInstance(connectionFactory)\n```\n\n### 3. **Factory Pattern** (Connection Factory)\n```\nLocation: Connection/IDbConnectionFactory.cs\nPurpose: Abstract database connection creation\nExample: SqlConnectionFactory, SqliteConnectionFactory\n```\n\n### 4. **Builder Pattern** (Query Builders)\n```\nLocation: Query/*.cs\nPurpose: Construct complex SQL queries step by step\nExample: new SqlQueryBuilder().Select(\"*\").From(\"Users\").Where(\"Id\", 1)\n```\n\n### 5. **Repository Pattern**\n```\nLocation: Repository/*.cs\nPurpose: Abstract data access behind collection-like interface\nExample: userRepo.GetById(1), userRepo.Find(u => u.IsActive)\n```\n\n### 6. **Unit of Work Pattern**\n```\nLocation: UnitOfWork/*.cs\nPurpose: Coordinate multiple repository operations in single transaction\nExample: unitOfWork.SaveChanges()\n```\n\n### 7. **Flyweight Pattern** (Entity Metadata Caching)\n```\nLocation: EntityMapper.cs\nPurpose: Share and reuse entity metadata across operations\nExample: EntityMapper.GetMetadata<User>()\n```\n\n### 8. **Visitor Pattern** (Expression Parser)\n```\nLocation: Query/ExpressionParser.cs\nPurpose: Traverse expression trees and generate SQL\nExample: Parsing x => x.Name == \"John\" to SQL\n```\n\n### 9. **Observer Pattern** (Change Tracking)\n```\nLocation: UnitOfWork/ChangeTracker.cs\nPurpose: Track entity property changes automatically\nExample: INotifyPropertyChanged subscription\n```\n\n### 10. **Template Method Pattern** (EntityBase)\n```\nLocation: EntityBase.cs\nPurpose: Define skeleton for entity behavior\nExample: SetProperty<T>() method for change notification\n```\n\n---\n\n## Class Diagram\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              MiniORM Architecture                            │\n└─────────────────────────────────────────────────────────────────────────────┘\n\n                                 ┌──────────────┐\n                                 │  Entity",
                    "images": [],
                    "tokenCount": 4802,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the Main Program demonstration. Let me continue with the complete Program.cs file and then add more examples and explanations.",
                        "signature": "Et4CCkYIChgCKkDYyjnza1wc16znFbgpVZmuUCNZAZGUf4spOQXfxxfF+VG4rC9Z6zWn39DTWTbSkddoeN9CQ016qL8c2NxichnAEgyOpVIs/fDhb13zzCUaDJQkH+nQfc4SVvPqRiIwyGAtSOJRMukY9mDhahPqoEd5y9j8vEeQvtbIHasPSUmyY9q9r9yK/ts3O6R3opoUKsUBrGQJDC0qS+yLI5Hbc80e3yI/CN6HxUkIms79l2KissftTAicoNZAq5dirmM2huMvNlXuB1tF+5xB+upMU6O/J4GDaeeFgNlx8monymmOYLFPIGow0QHSbjJF1qW+5z9dMG41uD9gyZww8NY93IU+QpwhUuCV7PM2Y/F6NeK8XvbBfmK6nwnnmKWGhxAHU5ldP0C2U+4yDXvLEuerLwzBq9Ev9DC2yQXsCJR5yn/EX05XVv225h/DzZ7indIw+xkNo1/0K74YAQ=="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 6,
            "parentIdx": 5,
            "childrenIdxs": [
                7
            ],
            "createdAt": "2025-12-04T18:03:48.264Z",
            "updatedAt": "2025-12-04T18:04:45.876Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\n## Class Diagram (Complete)\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              MiniORM Architecture                            │\n└─────────────────────────────────────────────────────────────────────────────┘\n\n                                 ┌──────────────┐\n                                 │  EntityBase  │\n                                 │──────────────│\n                                 │ +State       │\n                                 │ +SetProperty │\n                                 └──────┬───────┘\n                                        │ inherits\n              ┌─────────────────────────┼─────────────────────────┐\n              │                         │                         │\n        ┌─────▼─────┐            ┌──────▼─────┐            ┌──────▼──────┐\n        │   User    │            │ Department │            │   Product   │\n        │───────────│            │────────────│            │─────────────│\n        │ +Id       │            │ +Id        │            │ +Id         │\n        │ +Username │            │ +Name      │            │ +Name       │\n        │ +Email    │            │ +Desc      │            │ +Price      │\n        └───────────┘            └────────────┘            └─────────────┘\n\n\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                               Core Components                                │\n└─────────────────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────┐         ┌─────────────────────┐\n│ IDbConnectionFactory│◄────────│  SqlConnectionFactory│\n│─────────────────────│         │─────────────────────│\n│ +CreateConnection() │         │ +ConnectionString   │\n│ +CreateOpenConn()   │         │ +CreateConnection() │\n└─────────────────────┘         └─────────────────────┘\n          ▲\n          │ uses\n┌─────────┴───────────┐\n│     DbContext       │\n│─────────────────────│\n│ -_connection        │\n│ -_transaction       │\n│ +GetConnection()    │\n│ +BeginTransaction() │\n│ +Commit()           │\n│ +Rollback()         │\n│ +CreateCommand()    │\n└──────────┬──────────┘\n           │\n           │ uses\n           ▼\n┌─────────────────────┐         ┌─────────────────────┐\n│   EntityMapper      │────────►│   EntityMetadata    │\n│─────────────────────│         │─────────────────────│\n│ +GetMetadata<T>()   │         │ +EntityType         │\n│ +MapFromReader<T>() │         │ +TableName          │\n│ +ToDictionary()     │         │ +PrimaryKey         │\n│ -_metadataCache     │         │ +Properties         │\n└─────────────────────┘         │ +MappedProperties   │\n                                └──────────┬──────────┘\n                                           │\n                                           │ contains\n                                           ▼\n                                ┌─────────────────────┐\n                                │  PropertyMetadata   │\n                                │─────────────────────│\n                                │ +PropertyName       │\n                                │ +ColumnName         │\n                                │ +IsPrimaryKey       │\n                                │ +IsAutoGenerated    │\n                                │ +GetValue()         │\n                                │ +SetValue()         │\n                                └─────────────────────┘\n\n\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              Query Builders                                  │\n└─────────────────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐\n│  SqlQueryBuilder    │    │ InsertQueryBuilder  │    │ UpdateQueryBuilder  │\n│─────────────────────│    │─────────────────────│    │─────────────────────│\n│ +Select()           │    │ +Into()             │    │ +Table()            │\n│ +From()             │    │ +Value()            │    │ +Set()              │\n│ +Where()            │    │ +Values()           │    │ +Where()            │\n│ +OrderBy()          │    │ +ReturnIdentity()   │    │ +Build()            │\n│ +Join()             │    │ +Build()            │    └─────────────────────┘\n│ +Page()             │    └─────────────────────┘\n│ +Build()            │                               ┌─────────────────────┐\n└─────────────────────┘                               │ DeleteQueryBuilder  │\n                                                      │─────────────────────│\n┌─────────────────────┐                               │ +From()             │\n│  ExpressionParser   │                               │ +Where()            │\n│─────────────────────│                               │ +Build()            │\n│ +ParsePredicate()   │                               └─────────────────────┘\n│ -Visit()            │\n│ -VisitBinary()      │\n│ -VisitMember()      │\n│ -VisitMethodCall()  │\n└─────────────────────┘\n\n\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                          Repository & Unit of Work                           │\n└─────────────────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────┐         ┌─────────────────────┐\n│ IRepository<T,TKey> │◄────────│    Repository<T>    │\n│─────────────────────│         │─────────────────────│\n│ +GetById()          │         │ -_context           │\n│ +GetAll()           │         │ -_metadata          │\n│ +Find()             │         │ +GetById()          │\n│ +Add()              │         │ +GetAll()           │\n│ +Update()           │         │ +Find()             │\n│ +Delete()           │         │ +Add()              │\n│ +Count()            │         │ +Update()           │\n└─────────────────────┘         │ +Delete()           │\n                                └──────────┬──────────┘\n                                           │\n                                           │ used by\n                                           ▼\n┌─────────────────────┐         ┌─────────────────────┐\n│    IUnitOfWork      │◄────────│     UnitOfWork      │\n│─────────────────────│         │─────────────────────│\n│ +Repository<T>()    │         │ -_context           │\n│ +SaveChanges()      │         │ -_repositories      │\n│ +BeginTransaction() │         │ -_changeTracker     │\n│ +Commit()           │         │ +Repository<T>()    │\n│ +Rollback()         │         │ +SaveChanges()      │\n└─────────────────────┘         └──────────┬──────────┘\n                                           │\n                                           │ uses\n                                           ▼\n                                ┌─────────────────────┐\n                                │   ChangeTracker     │\n                                │─────────────────────│\n                                │ -_trackedEntities   │\n                                │ +Track()            │\n                                │ +Add()              │\n                                │ +Update()           │\n                                │ +Delete()           │\n                                │ +DetectChanges()    │\n                                │ +AcceptAllChanges() │\n                                └─────────────────────┘\n```\n\n---\n\n## 12. Unit Testing the ORM\n\nLet's create comprehensive unit tests for our ORM components.\n\n### Setting Up the Test Project\n\n```bash\n# Create test project\ndotnet new xunit -n MiniORM.Tests\ndotnet sln add MiniORM.Tests\ndotnet add MiniORM.Tests reference MiniORM.Core\n\n# Add required packages\ncd MiniORM.Tests\ndotnet add package Moq\ndotnet add package FluentAssertions\ndotnet add package Microsoft.Data.Sqlite  # For in-memory testing\n```\n\n### EntityMetadataTests.cs\n\n```csharp\nusing System;\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class EntityMetadataTests\n    {\n        #region Test Entities\n\n        [Table(\"TestUsers\")]\n        public class TestUser : EntityBase\n        {\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id { get; set; }\n\n            [Column(\"UserName\", MaxLength = 50)]\n            public string Username { get; set; }\n\n            [Column(\"EmailAddress\")]\n            public string Email { get; set; }\n\n            [NotMapped]\n            public string FullName { get; set; }\n\n            public DateTime CreatedAt { get; set; }\n        }\n\n        public class EntityWithoutTableAttribute\n        {\n            public int Id { get; set; }\n            public string Name { get; set; }\n        }\n\n        public class EntityWithConventionalPrimaryKey\n        {\n            public int Id { get; set; }\n            public string Name { get; set; }\n        }\n\n        #endregion\n\n        [Fact]\n        public void GetMetadata_ShouldExtractTableName_FromAttribute()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<TestUser>();\n\n            // Assert\n            metadata.TableName.Should().Be(\"TestUsers\");\n        }\n\n        [Fact]\n        public void GetMetadata_ShouldUseClassName_WhenNoTableAttribute()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<EntityWithoutTableAttribute>();\n\n            // Assert\n            metadata.TableName.Should().Be(\"EntityWithoutTableAttribute\");\n        }\n\n        [Fact]\n        public void GetMetadata_ShouldIdentifyPrimaryKey()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<TestUser>();\n\n            // Assert\n            metadata.PrimaryKey.Should().NotBeNull();\n            metadata.PrimaryKey.PropertyName.Should().Be(\"Id\");\n            metadata.PrimaryKey.IsAutoGenerated.Should().BeTrue();\n        }\n\n        [Fact]\n        public void GetMetadata_ShouldFindPrimaryKeyByConvention()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<EntityWithConventionalPrimaryKey>();\n\n            // Assert\n            metadata.PrimaryKey.Should().NotBeNull();\n            metadata.PrimaryKey.PropertyName.Should().Be(\"Id\");\n        }\n\n        [Fact]\n        public void GetMetadata_ShouldMapColumnNames()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<TestUser>();\n\n            // Assert\n            var usernameProperty = metadata.MappedProperties\n                .FirstOrDefault(p => p.PropertyName == \"Username\");\n            \n            usernameProperty.Should().NotBeNull();\n            usernameProperty.ColumnName.Should().Be(\"UserName\");\n        }\n\n        [Fact]\n        public void GetMetadata_ShouldExcludeNotMappedProperties()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<TestUser>();\n\n            // Assert\n            var notMappedProperty = metadata.MappedProperties\n                .FirstOrDefault(p => p.PropertyName == \"FullName\");\n            \n            notMappedProperty.Should().BeNull();\n        }\n\n        [Fact]\n        public void GetMetadata_ShouldBeCached()\n        {\n            // Act\n            var metadata1 = EntityMapper.GetMetadata<TestUser>();\n            var metadata2 = EntityMapper.GetMetadata<TestUser>();\n\n            // Assert\n            metadata1.Should().BeSameAs(metadata2);\n        }\n\n        [Fact]\n        public void GetInsertProperties_ShouldExcludeAutoGeneratedPrimaryKey()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<TestUser>();\n            var insertProperties = metadata.GetInsertProperties().ToList();\n\n            // Assert\n            insertProperties.Should().NotContain(p => p.PropertyName == \"Id\");\n            insertProperties.Should().Contain(p => p.PropertyName == \"Username\");\n        }\n\n        [Fact]\n        public void GetUpdateProperties_ShouldExcludePrimaryKey()\n        {\n            // Act\n            var metadata = EntityMapper.GetMetadata<TestUser>();\n            var updateProperties = metadata.GetUpdateProperties().ToList();\n\n            // Assert\n            updateProperties.Should().NotContain(p => p.PropertyName == \"Id\");\n        }\n    }\n}\n```\n\n### SqlQueryBuilderTests.cs\n\n```csharp\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core.Query;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class SqlQueryBuilderTests\n    {\n        [Fact]\n        public void Select_ShouldBuildBasicSelectQuery()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .Select(\"Id\", \"Name\", \"Email\")\n                .From(\"Users\")\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"SELECT [Id], [Name], [Email]\");\n            sql.Should().Contain(\"FROM [Users]\");\n        }\n\n        [Fact]\n        public void SelectAll_ShouldUseAsterisk()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .SelectAll()\n                .From(\"Users\")\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"SELECT *\");\n        }\n\n        [Fact]\n        public void Where_ShouldAddWhereClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .SelectAll()\n                .From(\"Users\")\n                .Where(\"Id\", 1)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"WHERE ([Id] = @p0)\");\n            parameters.Should().HaveCount(1);\n            parameters.First().Value.Should().Be(1);\n        }\n\n        [Fact]\n        public void MultipleWhere_ShouldCombineWithAnd()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .SelectAll()\n                .From(\"Users\")\n                .Where(\"IsActive\", true)\n                .Where(\"Age\", 25)\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"WHERE ([IsActive] = @p0) AND ([Age] = @p1)\");\n        }\n\n        [Fact]\n        public void WhereIn_ShouldBuildInClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n            var ids = new[] { 1, 2, 3 };\n\n            // Act\n            var (sql, parameters) = builder\n                .SelectAll()\n                .From(\"Users\")\n                .WhereIn(\"Id\", ids)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"[Id] IN (@p0, @p1, @p2)\");\n            parameters.Should().HaveCount(3);\n        }\n\n        [Fact]\n        public void WhereLike_ShouldBuildLikeClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .SelectAll()\n                .From(\"Users\")\n                .WhereContains(\"Name\", \"john\")\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"[Name] LIKE @p0\");\n            parameters.First().Value.Should().Be(\"%john%\");\n        }\n\n        [Fact]\n        public void WhereNull_ShouldBuildIsNullClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .SelectAll()\n                .From(\"Users\")\n                .WhereNull(\"DeletedAt\")\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"[DeletedAt] IS NULL\");\n        }\n\n        [Fact]\n        public void OrderBy_ShouldAddOrderByClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .SelectAll()\n                .From(\"Users\")\n                .OrderBy(\"Name\")\n                .OrderByDescending(\"CreatedAt\")\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"ORDER BY [Name], [CreatedAt] DESC\");\n        }\n\n        [Fact]\n        public void Top_ShouldLimitResults()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .SelectAll()\n                .From(\"Users\")\n                .Top(10)\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"SELECT TOP 10 *\");\n        }\n\n        [Fact]\n        public void Page_ShouldAddOffsetFetch()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .SelectAll()\n                .From(\"Users\")\n                .OrderBy(\"Id\")\n                .Page(2, 10)\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"OFFSET 10 ROWS\");\n            sql.Should().Contain(\"FETCH NEXT 10 ROWS ONLY\");\n        }\n\n        [Fact]\n        public void Join_ShouldAddJoinClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .Select(\"u.Name\", \"d.Name\")\n                .From(\"Users\", \"u\")\n                .InnerJoin(\"Departments\", \"[u].[DepartmentId] = [d].[Id]\", \"d\")\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"INNER JOIN [Departments] AS [d] ON [u].[DepartmentId] = [d].[Id]\");\n        }\n\n        [Fact]\n        public void Distinct_ShouldAddDistinctKeyword()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .Select(\"DepartmentId\")\n                .From(\"Users\")\n                .Distinct()\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"SELECT DISTINCT [DepartmentId]\");\n        }\n\n        [Fact]\n        public void GroupBy_ShouldAddGroupByClause()\n        {\n            // Arrange\n            var builder = new SqlQueryBuilder();\n\n            // Act\n            var sql = builder\n                .Select(\"DepartmentId\")\n                .SelectCount(\"*\")\n                .From(\"Users\")\n                .GroupBy(\"DepartmentId\")\n                .Having(\"COUNT(*) > 5\")\n                .BuildSelect();\n\n            // Assert\n            sql.Should().Contain(\"GROUP BY [DepartmentId]\");\n            sql.Should().Contain(\"HAVING (COUNT(*) > 5)\");\n        }\n    }\n}\n```\n\n### InsertUpdateDeleteQueryBuilderTests.cs\n\n```csharp\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core.Query;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class InsertUpdateDeleteQueryBuilderTests\n    {\n        #region INSERT Tests\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldBuildBasicInsert()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .Value(\"Email\", \"john@example.com\")\n                .ReturnIdentity(false)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"INSERT INTO [Users]\");\n            sql.Should().Contain(\"[Name], [Email]\");\n            sql.Should().Contain(\"@p0, @p1\");\n            parameters.Should().HaveCount(2);\n        }\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldIncludeScopeIdentity_WhenReturnIdentityIsTrue()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, _) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .ReturnIdentity(true)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"SELECT SCOPE_IDENTITY()\");\n        }\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldNotIncludeScopeIdentity_WhenReturnIdentityIsFalse()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, _) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .ReturnIdentity(false)\n                .Build();\n\n            // Assert\n            sql.Should().NotContain(\"SELECT SCOPE_IDENTITY()\");\n        }\n\n        #endregion\n\n        #region UPDATE Tests\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldBuildBasicUpdate()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Table(\"Users\")\n                .Set(\"Name\", \"Jane\")\n                .Set(\"Email\", \"jane@example.com\")\n                .Where(\"Id\", 1)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"UPDATE [Users] SET\");\n            sql.Should().Contain(\"[Name] = @p0\");\n            sql.Should().Contain(\"[Email] = @p1\");\n            sql.Should().Contain(\"WHERE ([Id] = @p2)\");\n            parameters.Should().HaveCount(3);\n        }\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldHandleMultipleWhereConditions()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            var (sql, _) = builder\n                .Table(\"Users\")\n                .Set(\"IsActive\", false",
                    "images": [],
                    "tokenCount": 4438,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue with the class diagram and likely finish up the tutorial. Let me complete the class diagram and then add any remaining sections like testing, best practices, and potential extensions.",
                        "signature": "Ev4CCkYIChgCKkA3/MU5kgcP9ZidkJ4q76MmIlmMnNaQAUmja/nwhWn20RrrkP1nEZcvpvpIBGzm1/5ioY7fOeH4hCP+JLbFscXhEgwWxUmfTF/+c0CVcqsaDGUINMZlL659oJwfciIwL53beVOatolajaVz2HvkOfe4MTOHp6y1WsVeEm6/+0Sh2SJkqQbN+/4konBDyTlVKuUB++SwyeRlcAX8Woi+ks2jLz2Lh/DtshuhZISn5BT+cK5/58D5AwQtVyJ6LIXsOsJdPjDEjpKPkAh4v8igKr2anN5pGa4l2DrQHOaiPtIX03jhdPL2kAVGVb8V9lW13S3FgkQc9M8KH+MntXgVx/XIb59cSFqtryWlYUrkvHxVjvayGR1JxFVTEAbCyzrHL65ccMCAtcHz5tuIYcCy/pXlhLSYWmq8OXhxi71yDvIqZmN7Z1cpCORXnLNFMom8ytafq2E2PgvFE6+ijJLRwsXm9OWd6lZ91prGTpUSONgu7a+VUDC8XRgB"
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 7,
            "parentIdx": 6,
            "childrenIdxs": [
                8
            ],
            "createdAt": "2025-12-04T18:05:51.359Z",
            "updatedAt": "2025-12-04T18:06:55.007Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `InsertUpdateDeleteQueryBuilderTests.cs` file:\n\n### InsertUpdateDeleteQueryBuilderTests.cs (Continued)\n\n```csharp\nusing System;\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core.Query;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class InsertUpdateDeleteQueryBuilderTests\n    {\n        #region INSERT Tests\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldBuildBasicInsert()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .Value(\"Email\", \"john@example.com\")\n                .ReturnIdentity(false)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"INSERT INTO [Users]\");\n            sql.Should().Contain(\"[Name], [Email]\");\n            sql.Should().Contain(\"@p0, @p1\");\n            parameters.Should().HaveCount(2);\n        }\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldIncludeScopeIdentity_WhenReturnIdentityIsTrue()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, _) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .ReturnIdentity(true)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"SELECT SCOPE_IDENTITY()\");\n        }\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldNotIncludeScopeIdentity_WhenReturnIdentityIsFalse()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, _) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .ReturnIdentity(false)\n                .Build();\n\n            // Assert\n            sql.Should().NotContain(\"SELECT SCOPE_IDENTITY()\");\n        }\n\n        [Fact]\n        public void InsertQueryBuilder_ShouldHandleNullValues()\n        {\n            // Arrange\n            var builder = new InsertQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Into(\"Users\")\n                .Value(\"Name\", \"John\")\n                .Value(\"MiddleName\", null)\n                .ReturnIdentity(false)\n                .Build();\n\n            // Assert\n            parameters.Should().HaveCount(2);\n            parameters.Last().Value.Should().Be(DBNull.Value);\n        }\n\n        #endregion\n\n        #region UPDATE Tests\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldBuildBasicUpdate()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Table(\"Users\")\n                .Set(\"Name\", \"Jane\")\n                .Set(\"Email\", \"jane@example.com\")\n                .Where(\"Id\", 1)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"UPDATE [Users] SET\");\n            sql.Should().Contain(\"[Name] = @p0\");\n            sql.Should().Contain(\"[Email] = @p1\");\n            sql.Should().Contain(\"WHERE ([Id] = @p2)\");\n            parameters.Should().HaveCount(3);\n        }\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldHandleMultipleWhereConditions()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Table(\"Users\")\n                .Set(\"IsActive\", false)\n                .Where(\"DepartmentId\", 1)\n                .Where(\"IsActive\", true)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"WHERE ([DepartmentId] = @p1) AND ([IsActive] = @p2)\");\n            parameters.Should().HaveCount(3);\n        }\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldHandleNullValues()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .Table(\"Users\")\n                .Set(\"DeletedAt\", DateTime.UtcNow)\n                .Set(\"DeletedBy\", null)\n                .Where(\"Id\", 1)\n                .Build();\n\n            // Assert\n            parameters.Should().Contain(p => p.Value == DBNull.Value);\n        }\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldThrow_WhenNoTableSpecified()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            builder.Set(\"Name\", \"Test\");\n            builder.Where(\"Id\", 1);\n            Action act = () => builder.BuildUpdate();\n\n            // Assert\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*Table name must be specified*\");\n        }\n\n        [Fact]\n        public void UpdateQueryBuilder_ShouldThrow_WhenNoSetValues()\n        {\n            // Arrange\n            var builder = new UpdateQueryBuilder();\n\n            // Act\n            builder.Table(\"Users\");\n            builder.Where(\"Id\", 1);\n            Action act = () => builder.BuildUpdate();\n\n            // Assert\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*At least one SET value must be specified*\");\n        }\n\n        #endregion\n\n        #region DELETE Tests\n\n        [Fact]\n        public void DeleteQueryBuilder_ShouldBuildBasicDelete()\n        {\n            // Arrange\n            var builder = new DeleteQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .From(\"Users\")\n                .Where(\"Id\", 1)\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"DELETE FROM [Users]\");\n            sql.Should().Contain(\"WHERE ([Id] = @p0)\");\n            parameters.Should().HaveCount(1);\n        }\n\n        [Fact]\n        public void DeleteQueryBuilder_ShouldHandleMultipleWhereConditions()\n        {\n            // Arrange\n            var builder = new DeleteQueryBuilder();\n\n            // Act\n            var (sql, parameters) = builder\n                .From(\"Users\")\n                .Where(\"IsActive\", false)\n                .Where(\"CreatedAt\", DateTime.Parse(\"2020-01-01\"))\n                .Build();\n\n            // Assert\n            sql.Should().Contain(\"WHERE ([IsActive] = @p0) AND ([CreatedAt] = @p1)\");\n            parameters.Should().HaveCount(2);\n        }\n\n        [Fact]\n        public void DeleteQueryBuilder_ShouldThrow_WhenNoWhereClause()\n        {\n            // Arrange\n            var builder = new DeleteQueryBuilder();\n\n            // Act\n            builder.From(\"Users\");\n            Action act = () => builder.BuildDelete();\n\n            // Assert\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*DELETE without WHERE clause is not allowed*\");\n        }\n\n        [Fact]\n        public void DeleteQueryBuilder_BuildDeleteAll_ShouldNotRequireWhereClause()\n        {\n            // Arrange\n            var builder = new DeleteQueryBuilder();\n\n            // Act\n            builder.From(\"Users\");\n            var sql = builder.BuildDeleteAll();\n\n            // Assert\n            sql.Should().Be(\"DELETE FROM [Users]\");\n        }\n\n        [Fact]\n        public void DeleteQueryBuilder_ShouldThrow_WhenNoTableSpecified()\n        {\n            // Arrange\n            var builder = new DeleteQueryBuilder();\n\n            // Act\n            builder.Where(\"Id\", 1);\n            Action act = () => builder.BuildDelete();\n\n            // Assert\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*Table name must be specified*\");\n        }\n\n        #endregion\n    }\n}\n```\n\n### ExpressionParserTests.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.Query;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class ExpressionParserTests\n    {\n        #region Test Entity\n\n        [Table(\"TestProducts\")]\n        public class TestProduct : EntityBase\n        {\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id { get; set; }\n\n            [Column(\"ProductName\")]\n            public string Name { get; set; }\n\n            public decimal Price { get; set; }\n\n            public int? CategoryId { get; set; }\n\n            public bool IsAvailable { get; set; }\n\n            public DateTime CreatedAt { get; set; }\n\n            public string Description { get; set; }\n        }\n\n        #endregion\n\n        private readonly ExpressionParser _parser;\n\n        public ExpressionParserTests()\n        {\n            _parser = new ExpressionParser();\n        }\n\n        #region Equality Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleEquality()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Id == 1, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Id] = @p0\");\n            queryBuilder.Parameters.Should().HaveCount(1);\n            queryBuilder.Parameters.First().Value.Should().Be(1);\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleInequality()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Id != 1, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Id] <> @p0\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleStringEquality()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name == \"Widget\", queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[ProductName] = @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(\"Widget\");\n        }\n\n        #endregion\n\n        #region Comparison Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleGreaterThan()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price > 100, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Price] > @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(100m);\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleGreaterThanOrEqual()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price >= 100, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Price] >= @p0\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleLessThan()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price < 50, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Price] < @p0\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleLessThanOrEqual()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price <= 50, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Price] <= @p0\");\n        }\n\n        #endregion\n\n        #region Logical Operators Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleAndOperator()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price > 100 && p.IsAvailable == true, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"AND\");\n            whereClause.Should().Contain(\"[Price] > @p0\");\n            whereClause.Should().Contain(\"[IsAvailable] = @p1\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleOrOperator()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price < 10 || p.Price > 1000, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"OR\");\n            whereClause.Should().Contain(\"[Price] < @p0\");\n            whereClause.Should().Contain(\"[Price] > @p1\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleComplexLogicalExpressions()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => (p.Price > 100 && p.IsAvailable) || p.CategoryId == 1, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"AND\");\n            whereClause.Should().Contain(\"OR\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleNotOperator()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => !p.IsAvailable, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"NOT\");\n        }\n\n        #endregion\n\n        #region Null Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleNullEquality()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.CategoryId == null, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"IS NULL\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleNullInequality()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.CategoryId != null, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"IS NOT NULL\");\n        }\n\n        #endregion\n\n        #region String Method Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleStringContains()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name.Contains(\"widget\"), queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[ProductName] LIKE @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(\"%widget%\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleStringStartsWith()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name.StartsWith(\"Pro\"), queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[ProductName] LIKE @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(\"Pro%\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleStringEndsWith()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name.EndsWith(\"duct\"), queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[ProductName] LIKE @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(\"%duct\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleStringToUpper()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name.ToUpper() == \"WIDGET\", queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"UPPER([ProductName])\");\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleStringToLower()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name.ToLower() == \"widget\", queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"LOWER([ProductName])\");\n        }\n\n        #endregion\n\n        #region Contains (IN clause) Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleListContains()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n            var categoryIds = new List<int> { 1, 2, 3 };\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => categoryIds.Contains(p.CategoryId.Value), queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"IN\");\n            queryBuilder.Parameters.Should().HaveCount(3);\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleArrayContains()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n            var names = new[] { \"Widget\", \"Gadget\", \"Tool\" };\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => names.Contains(p.Name), queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[ProductName] IN\");\n            queryBuilder.Parameters.Should().HaveCount(3);\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleEmptyListContains()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n            var emptyList = new List<int>();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => emptyList.Contains(p.Id), queryBuilder);\n\n            // Assert\n            // Empty IN clause should result in always false condition\n            whereClause.Should().Contain(\"1 = 0\");\n        }\n\n        #endregion\n\n        #region Captured Variable Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleCapturedVariables()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n            var minPrice = 50m;\n            var maxPrice = 200m;\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Price >= minPrice && p.Price <= maxPrice, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[Price] >= @p0\");\n            whereClause.Should().Contain(\"[Price] <= @p1\");\n            queryBuilder.Parameters.Should().Contain(p => (decimal)p.Value == 50m);\n            queryBuilder.Parameters.Should().Contain(p => (decimal)p.Value == 200m);\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleCapturedStringVariable()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n            var searchTerm = \"widget\";\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.Name.Contains(searchTerm), queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[ProductName] LIKE @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(\"%widget%\");\n        }\n\n        #endregion\n\n        #region Boolean Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleBooleanProperty()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.IsAvailable, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[IsAvailable] = @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(true);\n        }\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleNegatedBooleanProperty()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => !p.IsAvailable, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"NOT\");\n        }\n\n        #endregion\n\n        #region DateTime Tests\n\n        [Fact]\n        public void ParsePredicate_ShouldHandleDateTimeComparison()\n        {\n            // Arrange\n            var queryBuilder = new SqlQueryBuilder();\n            var cutoffDate = new DateTime(2023, 1, 1);\n\n            // Act\n            var whereClause = _parser.ParsePredicate<TestProduct>(\n                p => p.CreatedAt >= cutoffDate, queryBuilder);\n\n            // Assert\n            whereClause.Should().Contain(\"[CreatedAt] >= @p0\");\n            queryBuilder.Parameters.First().Value.Should().Be(cutoffDate);\n        }\n\n        #endregion\n    }\n}\n```\n\n### ChangeTrackerTests.cs\n\n```csharp\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.UnitOfWork;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class ChangeTrackerTests\n    {\n        #region Test Entity\n\n        [Table(\"TestEntities\")]\n        public class TestEntity : EntityBase\n        {\n            private int _id;\n            private string _name;\n            private string _description;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            public string Name\n            {\n                get => _name;\n                set => SetProperty(ref _name, value);\n            }\n\n            public string Description\n            {\n                get => _description;\n                set => SetProperty(ref _description, value);\n            }\n        }\n\n        #endregion\n\n        private readonly ChangeTracker _changeTracker;\n\n        public ChangeTrackerTests()\n        {\n            _changeTracker = new ChangeTracker();\n        }\n\n        #region Tracking Tests\n\n        [Fact]\n        public void Track_ShouldAddEntityToTrackedEntities()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Test\" };\n\n            // Act\n            _changeTracker.Track(entity, EntityState.Added);\n\n            // Assert\n            _changeTracker.Count.Should().Be(1);\n            _changeTracker.IsTracking(entity).Should().BeTrue();\n        }\n\n        [Fact]\n        public void Track_ShouldSetCorrectState()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Test\" };\n\n            // Act\n            var entry = _changeTracker.Track(entity, EntityState.Added);\n\n            // Assert\n            entry.State.Should().Be(EntityState.Added);\n            entity.State.Should().Be(EntityState.Added);\n        }\n\n        [Fact]\n        public void Track_ShouldUpdateState_WhenEntityAlreadyTracked()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Test\" };\n            _changeTracker.Track(entity, EntityState.Unchanged);\n\n            // Act\n            var entry = _changeTracker.Track(entity, EntityState.Modified);\n\n            // Assert\n            entry.State.Should().Be(EntityState.Modified);\n            _changeTracker.Count.Should().Be(1);\n        }\n\n        [Fact]\n        public void Track_ShouldCaptureOriginalValues()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\", Description = \"Original Desc\" };\n\n            // Act\n            var entry = _changeTracker.Track(entity, EntityState.Unchanged);\n\n            // Assert\n            entry.OriginalValues.Should().ContainKey(\"Name\");\n            entry.OriginalValues[\"Name\"].Should().Be(\"Original\");\n            entry.OriginalValues[\"Description\"].Should().Be(\"Original Desc\");\n        }\n\n        #endregion\n\n        #region Add/Update/Delete Tests\n\n        [Fact]\n        public void Add_ShouldMarkEntityAsAdded()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"New Entity\" };\n\n            // Act\n            var entry = _changeTracker.Add(entity);\n\n            // Assert\n            entry.State.Should().Be(EntityState.Added);\n        }\n\n        [Fact]\n        public void Update_ShouldMarkEntityAsModified()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Existing Entity\" };\n\n            // Act\n            var entry = _changeTracker.Update(entity);\n\n            // Assert\n            entry.State.Should().Be(EntityState.Modified);\n        }\n\n        [Fact]\n        public void Delete_ShouldMarkEntityAsDeleted()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"To Delete\" };\n\n            // Act\n            var entry = _changeTracker.Delete(entity);\n\n            // Assert\n            entry.State.Should().Be(EntityState.Deleted);\n        }\n\n        [Fact]\n        public void Attach_ShouldMarkEntityAsUnchanged()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Attached Entity\" };\n\n            // Act\n            var entry = _changeTracker.Attach(entity);\n\n            // Assert\n            entry.State.Should().Be(EntityState.Unchanged);\n        }\n\n        #endregion\n\n        #region Detach Tests\n\n        [Fact]\n        public void Detach_ShouldRemoveEntityFromTracking()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Test\" };\n            _changeTracker.Add(entity);\n\n            // Act\n            _changeTracker.Detach(entity);\n\n            // Assert\n            _changeTracker.IsTracking(entity).Should().BeFalse();\n            _changeTracker.Count.Should().Be(0);\n            entity.State.Should().Be(EntityState.Detached);\n        }\n\n        [Fact]\n        public void Detach_ShouldNotThrow_WhenEntityNotTracked()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Test\" };\n\n            // Act & Assert\n            var act = () => _changeTracker.Detach(entity);\n            act.Should().NotThrow();\n        }\n\n        #endregion\n\n        #region GetChangedEntries Tests\n\n        [Fact]\n        public void GetChangedEntries_ShouldReturnOnlyChangedEntities()\n        {\n            // Arrange\n            var added = new TestEntity { Name = \"Added\" };\n            var modified = new TestEntity { Name = \"Modified\" };\n            var deleted = new TestEntity { Name = \"Deleted\" };\n            var unchanged = new TestEntity { Name = \"Unchanged\" };\n\n            _changeTracker.Add(added);\n            _changeTracker.Update(modified);\n            _changeTracker.Delete(deleted);\n            _changeTracker.Attach(unchanged);\n\n            // Act\n            var changedEntries = _changeTracker.GetChangedEntries().ToList();\n\n            // Assert\n            changedEntries.Should().HaveCount(3);\n            changedEntries.Should().Contain(e => e.Entity == added);\n            changedEntries.Should().Contain(e => e.Entity == modified);\n            changedEntries.Should().Contain(e => e.Entity == deleted);\n            changedEntries.Should().NotContain(e => e.Entity == unchanged);\n        }\n\n        [Fact]\n        public void GetAddedEntries_ShouldReturnOnlyAddedEntities()\n        {\n            // Arrange\n            var added = new TestEntity { Name = \"Added\" };\n            var modified = new TestEntity { Name = \"Modified\" };\n\n            _changeTracker.Add(added);\n            _changeTracker.Update(modified);\n\n            // Act\n            var addedEntries = _changeTracker.GetAddedEntries().ToList();\n\n            // Assert\n            addedEntries.Should().HaveCount(1);\n            adde",
                    "images": [],
                    "tokenCount": 5681,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the test file. I was in the middle of writing the UpdateQueryBuilder tests and then need to continue with DELETE tests and other test files.",
                        "signature": "EuwCCkYIChgCKkDOwdjRgpzKQV5g5j7OwGkM9MqLKH7xJrEwirwxWRAmSrPDnQnbyweD/CBhGnMGs5lOAweKGpMqOfrAH0FwvfoEEgxBkHPUiSzTYdzd+aoaDPGUDBLETrvx9JsRECIwV9cG8Mfs4DCyYQcxbiY+bpecvkFGNfGIgTrxhuZ9RAuaXNDKZsL7/ht14D1cDe8MKtMBns/BLn5CQ1CMH14BcRyImtATTA2tzaCxHNF2+BqRR4nKMe7EMPbmLlMycwlWm8XYKgryZZAyArkHEx0v0HCC366j1C68CmZ+qVhMP7rlHXi1FpbSvYW40VxD9K7D6UpkcZfAvXbE32roPMZCT0XZPfO6p6l2yd5/Gu5L+btlzIDv2Z7OBRvo+xEDIaUvbtmPK3n5i+qlgp5ABlGMa4XlrT3NhcM19dQbFoSYLRjjnI4Wi67DNv1quT/QtisbL0OY+jSblux7ZcnMXZz087HF9WlQwRgB"
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 8,
            "parentIdx": 7,
            "childrenIdxs": [
                9
            ],
            "createdAt": "2025-12-04T18:08:00.644Z",
            "updatedAt": "2025-12-04T18:14:32.423Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `ChangeTrackerTests.cs` file:\n\n### ChangeTrackerTests.cs (Continued)\n\n```csharp\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.UnitOfWork;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class ChangeTrackerTests\n    {\n        #region Test Entity\n\n        [Table(\"TestEntities\")]\n        public class TestEntity : EntityBase\n        {\n            private int _id;\n            private string _name;\n            private string _description;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            public string Name\n            {\n                get => _name;\n                set => SetProperty(ref _name, value);\n            }\n\n            public string Description\n            {\n                get => _description;\n                set => SetProperty(ref _description, value);\n            }\n        }\n\n        #endregion\n\n        private readonly ChangeTracker _changeTracker;\n\n        public ChangeTrackerTests()\n        {\n            _changeTracker = new ChangeTracker();\n        }\n\n        #region GetAddedEntries Tests (Continued)\n\n        [Fact]\n        public void GetAddedEntries_ShouldReturnOnlyAddedEntities()\n        {\n            // Arrange\n            var added = new TestEntity { Name = \"Added\" };\n            var modified = new TestEntity { Name = \"Modified\" };\n\n            _changeTracker.Add(added);\n            _changeTracker.Update(modified);\n\n            // Act\n            var addedEntries = _changeTracker.GetAddedEntries().ToList();\n\n            // Assert\n            addedEntries.Should().HaveCount(1);\n            addedEntries.First().Entity.Should().Be(added);\n        }\n\n        [Fact]\n        public void GetModifiedEntries_ShouldReturnOnlyModifiedEntities()\n        {\n            // Arrange\n            var added = new TestEntity { Name = \"Added\" };\n            var modified = new TestEntity { Name = \"Modified\" };\n\n            _changeTracker.Add(added);\n            _changeTracker.Update(modified);\n\n            // Act\n            var modifiedEntries = _changeTracker.GetModifiedEntries().ToList();\n\n            // Assert\n            modifiedEntries.Should().HaveCount(1);\n            modifiedEntries.First().Entity.Should().Be(modified);\n        }\n\n        [Fact]\n        public void GetDeletedEntries_ShouldReturnOnlyDeletedEntities()\n        {\n            // Arrange\n            var added = new TestEntity { Name = \"Added\" };\n            var deleted = new TestEntity { Name = \"Deleted\" };\n\n            _changeTracker.Add(added);\n            _changeTracker.Delete(deleted);\n\n            // Act\n            var deletedEntries = _changeTracker.GetDeletedEntries().ToList();\n\n            // Assert\n            deletedEntries.Should().HaveCount(1);\n            deletedEntries.First().Entity.Should().Be(deleted);\n        }\n\n        #endregion\n\n        #region AcceptAllChanges Tests\n\n        [Fact]\n        public void AcceptAllChanges_ShouldMarkAddedAsUnchanged()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Added\" };\n            _changeTracker.Add(entity);\n\n            // Act\n            _changeTracker.AcceptAllChanges();\n\n            // Assert\n            var entry = _changeTracker.GetEntry(entity);\n            entry.State.Should().Be(EntityState.Unchanged);\n            entity.State.Should().Be(EntityState.Unchanged);\n        }\n\n        [Fact]\n        public void AcceptAllChanges_ShouldMarkModifiedAsUnchanged()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Modified\" };\n            _changeTracker.Update(entity);\n\n            // Act\n            _changeTracker.AcceptAllChanges();\n\n            // Assert\n            var entry = _changeTracker.GetEntry(entity);\n            entry.State.Should().Be(EntityState.Unchanged);\n        }\n\n        [Fact]\n        public void AcceptAllChanges_ShouldRemoveDeletedEntities()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Deleted\" };\n            _changeTracker.Delete(entity);\n\n            // Act\n            _changeTracker.AcceptAllChanges();\n\n            // Assert\n            _changeTracker.IsTracking(entity).Should().BeFalse();\n        }\n\n        [Fact]\n        public void AcceptAllChanges_ShouldUpdateOriginalValues()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\" };\n            var entry = _changeTracker.Attach(entity);\n            \n            // Simulate modification\n            entity.Name = \"Modified\";\n            entry.State = EntityState.Modified;\n\n            // Act\n            _changeTracker.AcceptAllChanges();\n\n            // Assert\n            entry.OriginalValues[\"Name\"].Should().Be(\"Modified\");\n        }\n\n        #endregion\n\n        #region RejectAllChanges Tests\n\n        [Fact]\n        public void RejectAllChanges_ShouldRemoveAddedEntities()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Added\" };\n            _changeTracker.Add(entity);\n\n            // Act\n            _changeTracker.RejectAllChanges();\n\n            // Assert\n            _changeTracker.IsTracking(entity).Should().BeFalse();\n        }\n\n        [Fact]\n        public void RejectAllChanges_ShouldRestoreModifiedEntities()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\", Description = \"Original Desc\" };\n            _changeTracker.Attach(entity);\n            \n            // Modify the entity\n            entity.Name = \"Modified\";\n            entity.Description = \"Modified Desc\";\n            _changeTracker.Update(entity);\n\n            // Act\n            _changeTracker.RejectAllChanges();\n\n            // Assert\n            entity.Name.Should().Be(\"Original\");\n            entity.Description.Should().Be(\"Original Desc\");\n            var entry = _changeTracker.GetEntry(entity);\n            entry.State.Should().Be(EntityState.Unchanged);\n        }\n\n        [Fact]\n        public void RejectAllChanges_ShouldMarkDeletedAsUnchanged()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"To Delete\" };\n            _changeTracker.Attach(entity);\n            _changeTracker.Delete(entity);\n\n            // Act\n            _changeTracker.RejectAllChanges();\n\n            // Assert\n            var entry = _changeTracker.GetEntry(entity);\n            entry.State.Should().Be(EntityState.Unchanged);\n        }\n\n        #endregion\n\n        #region DetectChanges Tests\n\n        [Fact]\n        public void DetectChanges_ShouldMarkModifiedEntities()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\" };\n            _changeTracker.Attach(entity);\n            \n            // Modify without using SetProperty (simulating external modification)\n            var entry = _changeTracker.GetEntry(entity);\n            // Directly change the backing store to simulate changes not caught by INotifyPropertyChanged\n            entity.Name = \"Changed\";\n            entry.State = EntityState.Unchanged; // Reset state for test\n\n            // Act\n            _changeTracker.DetectChanges();\n\n            // Assert\n            entry.State.Should().Be(EntityState.Modified);\n        }\n\n        [Fact]\n        public void DetectChanges_ShouldNotChangeUnmodifiedEntities()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Unchanged\" };\n            _changeTracker.Attach(entity);\n\n            // Act\n            _changeTracker.DetectChanges();\n\n            // Assert\n            var entry = _changeTracker.GetEntry(entity);\n            entry.State.Should().Be(EntityState.Unchanged);\n        }\n\n        #endregion\n\n        #region GetModifiedProperties Tests\n\n        [Fact]\n        public void GetModifiedProperties_ShouldReturnChangedPropertyNames()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\", Description = \"Original Desc\" };\n            var entry = _changeTracker.Attach(entity);\n            \n            // Modify entity\n            entity.Name = \"Modified\";\n            // Description unchanged\n\n            // Act\n            var modifiedProps = entry.GetModifiedProperties().ToList();\n\n            // Assert\n            modifiedProps.Should().Contain(\"Name\");\n            modifiedProps.Should().NotContain(\"Description\");\n        }\n\n        [Fact]\n        public void GetModifiedProperties_ShouldReturnEmpty_WhenNoChanges()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\" };\n            var entry = _changeTracker.Attach(entity);\n\n            // Act\n            var modifiedProps = entry.GetModifiedProperties().ToList();\n\n            // Assert\n            modifiedProps.Should().BeEmpty();\n        }\n\n        #endregion\n\n        #region Clear Tests\n\n        [Fact]\n        public void Clear_ShouldRemoveAllTrackedEntities()\n        {\n            // Arrange\n            var entity1 = new TestEntity { Name = \"Entity1\" };\n            var entity2 = new TestEntity { Name = \"Entity2\" };\n            _changeTracker.Add(entity1);\n            _changeTracker.Add(entity2);\n\n            // Act\n            _changeTracker.Clear();\n\n            // Assert\n            _changeTracker.Count.Should().Be(0);\n            entity1.State.Should().Be(EntityState.Detached);\n            entity2.State.Should().Be(EntityState.Detached);\n        }\n\n        #endregion\n\n        #region Automatic Change Detection Tests\n\n        [Fact]\n        public void Entity_ShouldAutoDetectChanges_WhenUsingSetProperty()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Original\" };\n            _changeTracker.Attach(entity);\n            \n            // Verify initial state\n            entity.State.Should().Be(EntityState.Unchanged);\n\n            // Act - Modify using property setter (which uses SetProperty)\n            entity.Name = \"Modified\";\n\n            // Assert - State should automatically change to Modified\n            entity.State.Should().Be(EntityState.Modified);\n        }\n\n        #endregion\n\n        #region Entries Filtering Tests\n\n        [Fact]\n        public void Entries_ShouldReturnAllTrackedEntities()\n        {\n            // Arrange\n            var entity1 = new TestEntity { Name = \"Entity1\" };\n            var entity2 = new TestEntity { Name = \"Entity2\" };\n            _changeTracker.Add(entity1);\n            _changeTracker.Attach(entity2);\n\n            // Act\n            var entries = _changeTracker.Entries.ToList();\n\n            // Assert\n            entries.Should().HaveCount(2);\n        }\n\n        [Fact]\n        public void EntriesOfType_ShouldReturnOnlyMatchingType()\n        {\n            // Arrange\n            var entity = new TestEntity { Name = \"Test\" };\n            _changeTracker.Add(entity);\n\n            // Act\n            var entries = _changeTracker.Entries<TestEntity>().ToList();\n\n            // Assert\n            entries.Should().HaveCount(1);\n            entries.First().Entity.Should().Be(entity);\n        }\n\n        #endregion\n    }\n}\n```\n\n### RepositoryTests.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.Connection;\nusing MiniORM.Core.Repository;\nusing Moq;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    public class RepositoryTests : IDisposable\n    {\n        #region Test Entities\n\n        [Table(\"Products\")]\n        public class Product : EntityBase\n        {\n            private int _id;\n            private string _name;\n            private decimal _price;\n            private bool _isActive;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            [Column(\"ProductName\")]\n            public string Name\n            {\n                get => _name;\n                set => SetProperty(ref _name, value);\n            }\n\n            public decimal Price\n            {\n                get => _price;\n                set => SetProperty(ref _price, value);\n            }\n\n            public bool IsActive\n            {\n                get => _isActive;\n                set => SetProperty(ref _isActive, value);\n            }\n        }\n\n        #endregion\n\n        private readonly DbContext _context;\n        private readonly Repository<Product> _repository;\n\n        public RepositoryTests()\n        {\n            // Use SQLite in-memory database for testing\n            var connectionString = \"Data Source=:memory:\";\n            var connectionFactory = new SqliteConnectionFactory(connectionString);\n            _context = new DbContext(connectionFactory);\n\n            // Create test table\n            CreateTestTable();\n\n            _repository = new Repository<Product>(_context);\n        }\n\n        private void CreateTestTable()\n        {\n            var createTableSql = @\"\n                CREATE TABLE IF NOT EXISTS Products (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    ProductName TEXT NOT NULL,\n                    Price REAL NOT NULL,\n                    IsActive INTEGER NOT NULL DEFAULT 1\n                )\";\n\n            _context.ExecuteNonQuery(createTableSql);\n        }\n\n        private void SeedTestData()\n        {\n            var seedSql = @\"\n                INSERT INTO Products (ProductName, Price, IsActive) VALUES \n                    ('Widget', 19.99, 1),\n                    ('Gadget', 29.99, 1),\n                    ('Tool', 9.99, 0),\n                    ('Device', 99.99, 1),\n                    ('Component', 4.99, 1)\";\n\n            _context.ExecuteNonQuery(seedSql);\n        }\n\n        public void Dispose()\n        {\n            _context?.Dispose();\n        }\n\n        #region GetById Tests\n\n        [Fact]\n        public void GetById_ShouldReturnEntity_WhenExists()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var product = _repository.GetById(1);\n\n            // Assert\n            product.Should().NotBeNull();\n            product.Id.Should().Be(1);\n            product.Name.Should().Be(\"Widget\");\n        }\n\n        [Fact]\n        public void GetById_ShouldReturnNull_WhenNotExists()\n        {\n            // Act\n            var product = _repository.GetById(999);\n\n            // Assert\n            product.Should().BeNull();\n        }\n\n        [Fact]\n        public void GetById_ShouldSetEntityStateToUnchanged()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var product = _repository.GetById(1);\n\n            // Assert\n            product.State.Should().Be(EntityState.Unchanged);\n        }\n\n        #endregion\n\n        #region GetAll Tests\n\n        [Fact]\n        public void GetAll_ShouldReturnAllEntities()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var products = _repository.GetAll().ToList();\n\n            // Assert\n            products.Should().HaveCount(5);\n        }\n\n        [Fact]\n        public void GetAll_ShouldReturnEmpty_WhenNoData()\n        {\n            // Act\n            var products = _repository.GetAll().ToList();\n\n            // Assert\n            products.Should().BeEmpty();\n        }\n\n        #endregion\n\n        #region Find Tests\n\n        [Fact]\n        public void Find_ShouldReturnMatchingEntities()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var activeProducts = _repository.Find(p => p.IsActive == true).ToList();\n\n            // Assert\n            activeProducts.Should().HaveCount(4);\n            activeProducts.Should().OnlyContain(p => p.IsActive);\n        }\n\n        [Fact]\n        public void Find_ShouldSupportPriceComparison()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var expensiveProducts = _repository.Find(p => p.Price > 20).ToList();\n\n            // Assert\n            expensiveProducts.Should().HaveCount(2); // Gadget and Device\n        }\n\n        [Fact]\n        public void Find_ShouldSupportStringContains()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var products = _repository.Find(p => p.Name.Contains(\"get\")).ToList();\n\n            // Assert\n            products.Should().HaveCount(2); // Widget and Gadget\n        }\n\n        [Fact]\n        public void Find_ShouldSupportComplexConditions()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var products = _repository.Find(p => p.IsActive && p.Price < 30).ToList();\n\n            // Assert\n            products.Should().HaveCount(3); // Widget, Gadget, Component\n        }\n\n        #endregion\n\n        #region FirstOrDefault Tests\n\n        [Fact]\n        public void FirstOrDefault_ShouldReturnFirstMatch()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var product = _repository.FirstOrDefault(p => p.Price > 50);\n\n            // Assert\n            product.Should().NotBeNull();\n            product.Name.Should().Be(\"Device\");\n        }\n\n        [Fact]\n        public void FirstOrDefault_ShouldReturnNull_WhenNoMatch()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var product = _repository.FirstOrDefault(p => p.Price > 1000);\n\n            // Assert\n            product.Should().BeNull();\n        }\n\n        #endregion\n\n        #region Count Tests\n\n        [Fact]\n        public void Count_ShouldReturnTotalCount_WhenNoCondition()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var count = _repository.Count();\n\n            // Assert\n            count.Should().Be(5);\n        }\n\n        [Fact]\n        public void Count_ShouldReturnFilteredCount_WhenConditionProvided()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var count = _repository.Count(p => p.IsActive);\n\n            // Assert\n            count.Should().Be(4);\n        }\n\n        #endregion\n\n        #region Any Tests\n\n        [Fact]\n        public void Any_ShouldReturnTrue_WhenMatchExists()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var exists = _repository.Any(p => p.Name == \"Widget\");\n\n            // Assert\n            exists.Should().BeTrue();\n        }\n\n        [Fact]\n        public void Any_ShouldReturnFalse_WhenNoMatch()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            var exists = _repository.Any(p => p.Name == \"NonExistent\");\n\n            // Assert\n            exists.Should().BeFalse();\n        }\n\n        #endregion\n\n        #region Add Tests\n\n        [Fact]\n        public void Add_ShouldInsertEntity()\n        {\n            // Arrange\n            var product = new Product\n            {\n                Name = \"New Product\",\n                Price = 49.99m,\n                IsActive = true\n            };\n\n            // Act\n            var added = _repository.Add(product);\n\n            // Assert\n            added.Id.Should().BeGreaterThan(0);\n            \n            // Verify in database\n            var fromDb = _repository.GetById(added.Id);\n            fromDb.Should().NotBeNull();\n            fromDb.Name.Should().Be(\"New Product\");\n        }\n\n        [Fact]\n        public void Add_ShouldSetGeneratedId()\n        {\n            // Arrange\n            var product = new Product\n            {\n                Name = \"Test Product\",\n                Price = 10m,\n                IsActive = true\n            };\n\n            // Act\n            _repository.Add(product);\n\n            // Assert\n            product.Id.Should().BeGreaterThan(0);\n        }\n\n        [Fact]\n        public void Add_ShouldSetStateToUnchanged_AfterInsert()\n        {\n            // Arrange\n            var product = new Product\n            {\n                Name = \"Test Product\",\n                Price = 10m,\n                IsActive = true\n            };\n\n            // Act\n            _repository.Add(product);\n\n            // Assert\n            product.State.Should().Be(EntityState.Unchanged);\n        }\n\n        [Fact]\n        public void Add_ShouldThrow_WhenEntityIsNull()\n        {\n            // Act\n            Action act = () => _repository.Add(null);\n\n            // Assert\n            act.Should().Throw<ArgumentNullException>();\n        }\n\n        #endregion\n\n        #region Update Tests\n\n        [Fact]\n        public void Update_ShouldModifyExistingEntity()\n        {\n            // Arrange\n            SeedTestData();\n            var product = _repository.GetById(1);\n            product.Name = \"Updated Widget\";\n            product.Price = 24.99m;\n\n            // Act\n            _repository.Update(product);\n\n            // Assert\n            var updated = _repository.GetById(1);\n            updated.Name.Should().Be(\"Updated Widget\");\n            updated.Price.Should().Be(24.99m);\n        }\n\n        [Fact]\n        public void Update_ShouldThrow_WhenEntityNotFound()\n        {\n            // Arrange\n            var product = new Product\n            {\n                Id = 999,\n                Name = \"Non-existent\",\n                Price = 10m,\n                IsActive = true\n            };\n\n            // Act\n            Action act = () => _repository.Update(product);\n\n            // Assert\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*not found*\");\n        }\n\n        [Fact]\n        public void Update_ShouldSetStateToUnchanged_AfterUpdate()\n        {\n            // Arrange\n            SeedTestData();\n            var product = _repository.GetById(1);\n            product.Name = \"Updated\";\n\n            // Act\n            _repository.Update(product);\n\n            // Assert\n            product.State.Should().Be(EntityState.Unchanged);\n        }\n\n        #endregion\n\n        #region Delete Tests\n\n        [Fact]\n        public void Delete_ById_ShouldRemoveEntity()\n        {\n            // Arrange\n            SeedTestData();\n            var countBefore = _repository.Count();\n\n            // Act\n            _repository.Delete(1);\n\n            // Assert\n            var countAfter = _repository.Count();\n            countAfter.Should().Be(countBefore - 1);\n            _repository.GetById(1).Should().BeNull();\n        }\n\n        [Fact]\n        public void Delete_ByEntity_ShouldRemoveEntity()\n        {\n            // Arrange\n            SeedTestData();\n            var product = _repository.GetById(1);\n\n            // Act\n            _repository.Delete(product);\n\n            // Assert\n            _repository.GetById(1).Should().BeNull();\n        }\n\n        [Fact]\n        public void DeleteWhere_ShouldRemoveMatchingEntities()\n        {\n            // Arrange\n            SeedTestData();\n\n            // Act\n            _repository.DeleteWhere(p => !p.IsActive);\n\n            // Assert\n            _repository.Count().Should().Be(4);\n            _repository.Any(p => !p.IsActive).Should().BeFalse();\n        }\n\n        #endregion\n\n        #region AddRange Tests\n\n        [Fact]\n        public void AddRange_ShouldInsertMultipleEntities()\n        {\n            // Arrange\n            var products = new List<Product>\n            {\n                new Product { Name = \"Product 1\", Price = 10m, IsActive = true },\n                new Product { Name = \"Product 2\", Price = 20m, IsActive = true },\n                new Product { Name = \"Product 3\", Price = 30m, IsActive = false }\n            };\n\n            // Act\n            _repository.AddRange(products);\n\n            // Assert\n            _repository.Count().Should().Be(3);\n            products.Should().OnlyContain(p => p.Id > 0);\n        }\n\n        #endregion\n    }\n}\n```\n\n### IntegrationTests.cs\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.Connection;\nusing MiniORM.Core.Repository;\nusing MiniORM.Core.UnitOfWork;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    /// <summary>\n    /// Integration tests that test multiple components working together.\n    /// </summary>\n    public class IntegrationTests : IDisposable\n    {\n        #region Test Entities\n\n        [Table(\"Customers\")]\n        public class Customer : EntityBase\n        {\n            private int _id;\n            private string _name;\n            private string _email;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            public string Name\n            {\n                get => _name;\n                set => SetProperty(ref _name, value);\n            }\n\n            public string Email\n            {\n                get => _email;\n                set => SetProperty(ref _email, value);\n            }\n        }\n\n        [Table(\"Orders\")]\n        public class Order : EntityBase\n        {\n            private int _id;\n            private int _customerId;\n            private DateTime _orderDate;\n            private decimal _totalAmount;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            [ForeignKey(typeof(Customer))]\n            public int CustomerId\n            {\n                get => _customerId;\n                set => SetProperty(ref _customerId, value);\n            }\n\n            public DateTime OrderDate\n            {\n                get => _orderDate;\n                set => SetProperty(ref _orderDate, value);\n            }\n\n            public decimal TotalAmount\n            {\n                get => _totalAmount;\n                set => SetProperty(ref _totalAmount, value);\n            }\n\n            [NotMapped]\n            public Customer Customer { get; set; }\n        }\n\n        #endregion\n\n        private readonly DbContext _context;\n\n        public IntegrationTests()\n        {\n            var connectionString = \"Data Source=:memory:\";\n            var connectionFactory = new SqliteConnectionFactory(connectionString);\n            _context = new DbContext(connectionFactory);\n            \n            CreateTestTables();\n        }\n\n        private void CreateTestTables()\n        {\n            _context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Customers (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    Name TEXT NOT NULL,\n                    Email TEXT NOT NULL\n                )\");\n\n            _context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Orders (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    CustomerId INTEGER NOT NULL,\n                    OrderDate TEXT NOT NULL,\n                    TotalAmount REAL NOT NULL,\n                    FOREIGN KEY (CustomerId) REFERENCES Customers(Id)\n                )\");\n        }\n\n        public void Dispose()\n        {\n            _context?.Dispose();\n        }\n\n        #region U",
                    "images": [],
                    "tokenCount": 5398,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the ChangeTrackerTests.cs file. I was in the middle of a test method. Let me continue from there and then provide the remaining parts of the ORM tutorial, including:\n\n1. Complete the ChangeTrackerTests.cs\n2. RepositoryTests.cs\n3. Integration tests\n4. Final summary and advanced topics\n\nLet me continue...",
                        "signature": "Eo8ECkYIChgCKkDUz6IInBjqetjwkVfZPGmfqKUfWR6U3VM6i9QONMrtCeMts4k0wdyy4s8MFpz7OOwwMq/M7ZaSpANWTwUWigzyEgw6aPTbMXy9emIDSIwaDJjrzZWQnR2t2YTTyyIwgDyD5MGZvtyRc3RCvRrmnW4ejSyU7TKA/K3ueP6936ZrwuBXxuoa7FNAF3kJbT1jKvYC4frJb75S1hENlU+AugsJeD3Od3od8Lg8/nRcnLKSTLqbwOHwv+k00kHnameG7WKv9AHbjgoyZEo1wfJqZ0TBPacRROn4PZ1/Tn80XU/oUiDloQ1SpmaFu7vdthg08rsx3alEYUHapStArpiim2f1WfwGnGBZBynALiC3vUbsBZ+RmvoghCJ8fu+4/6LVvX/1E3kxYQCPjYjGFzymPTnuW21wYLJ5bEustk3qMjjIW2njCkIwXHqAHTbFYuquRT5RzDAIMc4hOZgtg939g/Y+Ph7mMb4PQQe8/4svNljaHG7R1ozfnNQClME4wpbEGLopNuH1JnfyY5TwXiBMJbtkD0kDBT1xnH5ghu1qNZBe0Ca7xUJF599O1LxZ1f6UdzeLB+ECdqI3CHfsE8B9VE39t/3+Hcphij1Lu1CNM6GrOTiTXLsqiCm3eEVdrUHtYYzaYYU1pPnHJztGVcRqNRdbgg1CVxLzn6Gmnm52JLc5byNY28w+OMwYAQ=="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 9,
            "parentIdx": 8,
            "childrenIdxs": [
                10
            ],
            "createdAt": "2025-12-04T18:15:37.910Z",
            "updatedAt": "2025-12-04T18:16:33.050Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `IntegrationTests.cs` file:\n\n### IntegrationTests.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.Connection;\nusing MiniORM.Core.Repository;\nusing MiniORM.Core.UnitOfWork;\nusing Xunit;\n\nnamespace MiniORM.Tests\n{\n    /// <summary>\n    /// Integration tests that test multiple components working together.\n    /// </summary>\n    public class IntegrationTests : IDisposable\n    {\n        #region Test Entities\n\n        [Table(\"Customers\")]\n        public class Customer : EntityBase\n        {\n            private int _id;\n            private string _name;\n            private string _email;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            public string Name\n            {\n                get => _name;\n                set => SetProperty(ref _name, value);\n            }\n\n            public string Email\n            {\n                get => _email;\n                set => SetProperty(ref _email, value);\n            }\n        }\n\n        [Table(\"Orders\")]\n        public class Order : EntityBase\n        {\n            private int _id;\n            private int _customerId;\n            private DateTime _orderDate;\n            private decimal _totalAmount;\n\n            [PrimaryKey(AutoGenerate = true)]\n            public int Id\n            {\n                get => _id;\n                set => SetProperty(ref _id, value);\n            }\n\n            [ForeignKey(typeof(Customer))]\n            public int CustomerId\n            {\n                get => _customerId;\n                set => SetProperty(ref _customerId, value);\n            }\n\n            public DateTime OrderDate\n            {\n                get => _orderDate;\n                set => SetProperty(ref _orderDate, value);\n            }\n\n            public decimal TotalAmount\n            {\n                get => _totalAmount;\n                set => SetProperty(ref _totalAmount, value);\n            }\n\n            [NotMapped]\n            public Customer Customer { get; set; }\n        }\n\n        #endregion\n\n        private readonly DbContext _context;\n\n        public IntegrationTests()\n        {\n            var connectionString = \"Data Source=:memory:\";\n            var connectionFactory = new SqliteConnectionFactory(connectionString);\n            _context = new DbContext(connectionFactory);\n            \n            CreateTestTables();\n        }\n\n        private void CreateTestTables()\n        {\n            _context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Customers (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    Name TEXT NOT NULL,\n                    Email TEXT NOT NULL\n                )\");\n\n            _context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Orders (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    CustomerId INTEGER NOT NULL,\n                    OrderDate TEXT NOT NULL,\n                    TotalAmount REAL NOT NULL,\n                    FOREIGN KEY (CustomerId) REFERENCES Customers(Id)\n                )\");\n        }\n\n        public void Dispose()\n        {\n            _context?.Dispose();\n        }\n\n        #region Unit of Work Integration Tests\n\n        [Fact]\n        public void UnitOfWork_ShouldSaveMultipleEntities_InSingleTransaction()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n            var orderRepo = uow.Repository<Order>();\n\n            var customer = new Customer { Name = \"John Doe\", Email = \"john@example.com\" };\n            customerRepo.Add(customer);\n\n            // Act\n            uow.SaveChanges();\n\n            // Add order after customer is saved (to get the ID)\n            var order = new Order\n            {\n                CustomerId = customer.Id,\n                OrderDate = DateTime.UtcNow,\n                TotalAmount = 150.00m\n            };\n            orderRepo.Add(order);\n            uow.SaveChanges();\n\n            // Assert\n            customer.Id.Should().BeGreaterThan(0);\n            order.Id.Should().BeGreaterThan(0);\n\n            // Verify in database\n            var savedCustomer = customerRepo.GetById(customer.Id);\n            savedCustomer.Should().NotBeNull();\n            savedCustomer.Name.Should().Be(\"John Doe\");\n\n            var savedOrder = orderRepo.GetById(order.Id);\n            savedOrder.Should().NotBeNull();\n            savedOrder.CustomerId.Should().Be(customer.Id);\n        }\n\n        [Fact]\n        public void UnitOfWork_ShouldRollbackAllChanges_OnError()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customer1 = new Customer { Name = \"Customer 1\", Email = \"c1@example.com\" };\n            var customer2 = new Customer { Name = \"Customer 2\", Email = \"c2@example.com\" };\n\n            customerRepo.Add(customer1);\n            customerRepo.Add(customer2);\n            uow.SaveChanges();\n\n            var initialCount = customerRepo.Count();\n\n            // Act - Start a new unit of work for rollback test\n            using var uow2 = new UnitOfWork(_context);\n            var repo2 = uow2.Repository<Customer>();\n\n            try\n            {\n                uow2.BeginTransaction();\n\n                var customer3 = new Customer { Name = \"Customer 3\", Email = \"c3@example.com\" };\n                repo2.Add(customer3);\n\n                // Simulate error\n                throw new Exception(\"Simulated error\");\n            }\n            catch\n            {\n                uow2.Rollback();\n            }\n\n            // Assert - Count should remain the same\n            var finalCount = customerRepo.Count();\n            finalCount.Should().Be(initialCount);\n        }\n\n        [Fact]\n        public void UnitOfWork_ShouldTrackEntityChanges()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customer = new Customer { Name = \"Original Name\", Email = \"test@example.com\" };\n            customerRepo.Add(customer);\n            uow.SaveChanges();\n\n            // Act - Modify the entity\n            customer.Name = \"Modified Name\";\n\n            // Assert - Change tracker should detect modification\n            uow.ChangeTracker.GetModifiedEntries().Should().HaveCount(1);\n            \n            // Save and verify\n            uow.SaveChanges();\n            \n            var updated = customerRepo.GetById(customer.Id);\n            updated.Name.Should().Be(\"Modified Name\");\n        }\n\n        [Fact]\n        public void UnitOfWork_ShouldHandleMultipleRepositories()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n            var orderRepo = uow.Repository<Order>();\n\n            // Act - Add customer and orders\n            var customer = new Customer { Name = \"Multi-Order Customer\", Email = \"multi@example.com\" };\n            customerRepo.Add(customer);\n            uow.SaveChanges();\n\n            var orders = new[]\n            {\n                new Order { CustomerId = customer.Id, OrderDate = DateTime.UtcNow.AddDays(-2), TotalAmount = 100m },\n                new Order { CustomerId = customer.Id, OrderDate = DateTime.UtcNow.AddDays(-1), TotalAmount = 200m },\n                new Order { CustomerId = customer.Id, OrderDate = DateTime.UtcNow, TotalAmount = 300m }\n            };\n\n            foreach (var order in orders)\n            {\n                orderRepo.Add(order);\n            }\n            uow.SaveChanges();\n\n            // Assert\n            var customerOrders = orderRepo.Find(o => o.CustomerId == customer.Id).ToList();\n            customerOrders.Should().HaveCount(3);\n            customerOrders.Sum(o => o.TotalAmount).Should().Be(600m);\n        }\n\n        #endregion\n\n        #region Repository Pattern Integration Tests\n\n        [Fact]\n        public void Repository_ShouldSupportComplexQueries()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customers = new[]\n            {\n                new Customer { Name = \"Alice Smith\", Email = \"alice@example.com\" },\n                new Customer { Name = \"Bob Johnson\", Email = \"bob@example.com\" },\n                new Customer { Name = \"Charlie Brown\", Email = \"charlie@gmail.com\" },\n                new Customer { Name = \"Diana Smith\", Email = \"diana@example.com\" }\n            };\n\n            foreach (var c in customers)\n            {\n                customerRepo.Add(c);\n            }\n            uow.SaveChanges();\n\n            // Act & Assert - Various queries\n            \n            // Find by name containing\n            var smiths = customerRepo.Find(c => c.Name.Contains(\"Smith\")).ToList();\n            smiths.Should().HaveCount(2);\n\n            // Find by email domain\n            var exampleEmails = customerRepo.Find(c => c.Email.EndsWith(\"@example.com\")).ToList();\n            exampleEmails.Should().HaveCount(3);\n\n            // Find by exact name\n            var alice = customerRepo.FirstOrDefault(c => c.Name == \"Alice Smith\");\n            alice.Should().NotBeNull();\n            alice.Email.Should().Be(\"alice@example.com\");\n\n            // Count with condition\n            var count = customerRepo.Count(c => c.Name.StartsWith(\"D\"));\n            count.Should().Be(1);\n        }\n\n        [Fact]\n        public void Repository_ShouldSupportInClause()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customers = new[]\n            {\n                new Customer { Name = \"Customer A\", Email = \"a@test.com\" },\n                new Customer { Name = \"Customer B\", Email = \"b@test.com\" },\n                new Customer { Name = \"Customer C\", Email = \"c@test.com\" },\n                new Customer { Name = \"Customer D\", Email = \"d@test.com\" }\n            };\n\n            foreach (var c in customers)\n            {\n                customerRepo.Add(c);\n            }\n            uow.SaveChanges();\n\n            var ids = customers.Take(2).Select(c => c.Id).ToList();\n\n            // Act\n            var found = customerRepo.Find(c => ids.Contains(c.Id)).ToList();\n\n            // Assert\n            found.Should().HaveCount(2);\n            found.Select(c => c.Id).Should().BeEquivalentTo(ids);\n        }\n\n        #endregion\n\n        #region Transaction Integration Tests\n\n        [Fact]\n        public void Transaction_ShouldCommitSuccessfully()\n        {\n            // Arrange\n            var customerRepo = new Repository<Customer>(_context);\n            var initialCount = customerRepo.Count();\n\n            // Act\n            _context.BeginTransaction();\n            \n            var customer = new Customer { Name = \"Transaction Test\", Email = \"tx@test.com\" };\n            customerRepo.Add(customer);\n            \n            _context.Commit();\n\n            // Assert\n            var finalCount = customerRepo.Count();\n            finalCount.Should().Be(initialCount + 1);\n        }\n\n        [Fact]\n        public void Transaction_ShouldRollbackOnFailure()\n        {\n            // Arrange\n            var customerRepo = new Repository<Customer>(_context);\n            var initialCount = customerRepo.Count();\n\n            // Act\n            _context.BeginTransaction();\n            \n            var customer = new Customer { Name = \"Rollback Test\", Email = \"rollback@test.com\" };\n            customerRepo.Add(customer);\n            \n            _context.Rollback();\n\n            // Assert\n            var finalCount = customerRepo.Count();\n            finalCount.Should().Be(initialCount);\n        }\n\n        [Fact]\n        public void NestedOperations_ShouldWorkWithinTransaction()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n            var orderRepo = uow.Repository<Order>();\n\n            // Act\n            uow.BeginTransaction();\n\n            try\n            {\n                // Create customer\n                var customer = new Customer { Name = \"Nested Ops Customer\", Email = \"nested@test.com\" };\n                customerRepo.Add(customer);\n                uow.SaveChanges();\n\n                // Create multiple orders\n                for (int i = 0; i < 5; i++)\n                {\n                    var order = new Order\n                    {\n                        CustomerId = customer.Id,\n                        OrderDate = DateTime.UtcNow.AddDays(-i),\n                        TotalAmount = (i + 1) * 50m\n                    };\n                    orderRepo.Add(order);\n                }\n                uow.SaveChanges();\n\n                uow.Commit();\n\n                // Assert\n                var savedOrders = orderRepo.Find(o => o.CustomerId == customer.Id).ToList();\n                savedOrders.Should().HaveCount(5);\n                savedOrders.Sum(o => o.TotalAmount).Should().Be(750m); // 50 + 100 + 150 + 200 + 250\n            }\n            catch\n            {\n                uow.Rollback();\n                throw;\n            }\n        }\n\n        #endregion\n\n        #region Change Tracking Integration Tests\n\n        [Fact]\n        public void ChangeTracking_ShouldDetectPropertyChanges()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customer = new Customer { Name = \"Track Me\", Email = \"track@test.com\" };\n            customerRepo.Add(customer);\n            uow.SaveChanges();\n\n            // Verify initial state\n            customer.State.Should().Be(EntityState.Unchanged);\n\n            // Act - Modify properties\n            customer.Name = \"Modified Name\";\n            customer.Email = \"modified@test.com\";\n\n            // Assert\n            customer.State.Should().Be(EntityState.Modified);\n            \n            var entry = uow.ChangeTracker.GetEntry(customer);\n            var modifiedProps = entry.GetModifiedProperties().ToList();\n            modifiedProps.Should().Contain(\"Name\");\n            modifiedProps.Should().Contain(\"Email\");\n        }\n\n        [Fact]\n        public void ChangeTracking_ShouldOnlyUpdateModifiedProperties()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customer = new Customer { Name = \"Original\", Email = \"original@test.com\" };\n            customerRepo.Add(customer);\n            uow.SaveChanges();\n\n            // Act - Modify only name\n            customer.Name = \"Updated\";\n            uow.SaveChanges();\n\n            // Assert - Email should remain unchanged\n            var reloaded = new Repository<Customer>(_context).GetById(customer.Id);\n            reloaded.Name.Should().Be(\"Updated\");\n            reloaded.Email.Should().Be(\"original@test.com\");\n        }\n\n        #endregion\n\n        #region Async Integration Tests\n\n        [Fact]\n        public async Task Repository_ShouldSupportAsyncOperations()\n        {\n            // Arrange\n            var customerRepo = new Repository<Customer>(_context);\n\n            var customer = new Customer { Name = \"Async Customer\", Email = \"async@test.com\" };\n\n            // Act\n            var added = await customerRepo.AddAsync(customer);\n            var found = await customerRepo.GetByIdAsync(added.Id);\n            var all = await customerRepo.GetAllAsync();\n\n            // Assert\n            added.Id.Should().BeGreaterThan(0);\n            found.Should().NotBeNull();\n            found.Name.Should().Be(\"Async Customer\");\n            all.Should().Contain(c => c.Id == added.Id);\n        }\n\n        [Fact]\n        public async Task UnitOfWork_ShouldSupportAsyncSaveChanges()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var customerRepo = uow.Repository<Customer>();\n\n            var customer = new Customer { Name = \"Async UoW\", Email = \"asyncuow@test.com\" };\n            customerRepo.Add(customer);\n\n            // Act\n            var savedCount = await uow.SaveChangesAsync();\n\n            // Assert\n            savedCount.Should().Be(1);\n            customer.Id.Should().BeGreaterThan(0);\n        }\n\n        #endregion\n\n        #region Edge Cases and Error Handling\n\n        [Fact]\n        public void Repository_ShouldHandleEmptyResults()\n        {\n            // Arrange\n            var customerRepo = new Repository<Customer>(_context);\n\n            // Act\n            var results = customerRepo.Find(c => c.Name == \"NonExistent\").ToList();\n\n            // Assert\n            results.Should().BeEmpty();\n        }\n\n        [Fact]\n        public void Repository_ShouldHandleNullPropertyComparison()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            var orderRepo = uow.Repository<Order>();\n            var customerRepo = uow.Repository<Customer>();\n\n            var customer = new Customer { Name = \"Null Test\", Email = \"null@test.com\" };\n            customerRepo.Add(customer);\n            uow.SaveChanges();\n\n            var order = new Order\n            {\n                CustomerId = customer.Id,\n                OrderDate = DateTime.UtcNow,\n                TotalAmount = 0\n            };\n            orderRepo.Add(order);\n            uow.SaveChanges();\n\n            // Act\n            var zeroOrders = orderRepo.Find(o => o.TotalAmount == 0).ToList();\n\n            // Assert\n            zeroOrders.Should().HaveCount(1);\n        }\n\n        [Fact]\n        public void UnitOfWork_ShouldPreventDoubleCommit()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            uow.BeginTransaction();\n            uow.Commit();\n\n            // Act & Assert\n            Action act = () => uow.Commit();\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*No transaction*\");\n        }\n\n        [Fact]\n        public void UnitOfWork_ShouldPreventDoubleRollback()\n        {\n            // Arrange\n            using var uow = new UnitOfWork(_context);\n            uow.BeginTransaction();\n            uow.Rollback();\n\n            // Act & Assert\n            Action act = () => uow.Rollback();\n            act.Should().Throw<InvalidOperationException>()\n                .WithMessage(\"*No transaction*\");\n        }\n\n        #endregion\n    }\n}\n```\n\n---\n\n## 13. Performance Optimizations\n\nLet's add some performance optimizations to our ORM.\n\n### CompiledExpressionCache.cs\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Linq.Expressions;\n\nnamespace MiniORM.Core.Performance\n{\n    /// <summary>\n    /// Caches compiled expressions for improved performance.\n    /// \n    /// Design Pattern: Flyweight Pattern\n    /// - Shares compiled delegates across multiple invocations\n    /// </summary>\n    public static class CompiledExpressionCache\n    {\n        private static readonly ConcurrentDictionary<string, Delegate> _cache \n            = new ConcurrentDictionary<string, Delegate>();\n\n        /// <summary>\n        /// Gets or creates a compiled getter for a property.\n        /// </summary>\n        public static Func<TEntity, TProperty> GetPropertyGetter<TEntity, TProperty>(\n            string propertyName)\n        {\n            var key = $\"{typeof(TEntity).FullName}.{propertyName}.Getter\";\n\n            return (Func<TEntity, TProperty>)_cache.GetOrAdd(key, _ =>\n            {\n                var parameter = Expression.Parameter(typeof(TEntity), \"entity\");\n                var property = Expression.Property(parameter, propertyName);\n                var lambda = Expression.Lambda<Func<TEntity, TProperty>>(property, parameter);\n                return lambda.Compile();\n            });\n        }\n\n        /// <summary>\n        /// Gets or creates a compiled setter for a property.\n        /// </summary>\n        public static Action<TEntity, TProperty> GetPropertySetter<TEntity, TProperty>(\n            string propertyName)\n        {\n            var key = $\"{typeof(TEntity).FullName}.{propertyName}.Setter\";\n\n            return (Action<TEntity, TProperty>)_cache.GetOrAdd(key, _ =>\n            {\n                var entityParam = Expression.Parameter(typeof(TEntity), \"entity\");\n                var valueParam = Expression.Parameter(typeof(TProperty), \"value\");\n                var property = Expression.Property(entityParam, propertyName);\n                var assign = Expression.Assign(property, valueParam);\n                var lambda = Expression.Lambda<Action<TEntity, TProperty>>(assign, entityParam, valueParam);\n                return lambda.Compile();\n            });\n        }\n\n        /// <summary>\n        /// Gets or creates a compiled factory for creating entity instances.\n        /// </summary>\n        public static Func<TEntity> GetFactory<TEntity>() where TEntity : new()\n        {\n            var key = $\"{typeof(TEntity).FullName}.Factory\";\n\n            return (Func<TEntity>)_cache.GetOrAdd(key, _ =>\n            {\n                var newExpr = Expression.New(typeof(TEntity));\n                var lambda = Expression.Lambda<Func<TEntity>>(newExpr);\n                return lambda.Compile();\n            });\n        }\n\n        /// <summary>\n        /// Clears the expression cache.\n        /// </summary>\n        public static void Clear()\n        {\n            _cache.Clear();\n        }\n\n        /// <summary>\n        /// Gets the number of cached expressions.\n        /// </summary>\n        public static int Count => _cache.Count;\n    }\n}\n```\n\n### BulkOperations.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\nusing MiniORM.Core.Query;\n\nnamespace MiniORM.Core.Performance\n{\n    /// <summary>\n    /// Provides bulk operation support for improved performance\n    /// when working with large datasets.\n    /// </summary>\n    public class BulkOperations<TEntity> where TEntity : class\n    {\n        private readonly DbContext _context;\n        private readonly EntityMetadata _metadata;\n\n        public BulkOperations(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n            _metadata = EntityMapper.GetMetadata<TEntity>();\n        }\n\n        /// <summary>\n        /// Bulk inserts entities using batched INSERT statements.\n        /// Much faster than inserting one at a time.\n        /// </summary>\n        /// <param name=\"entities\">Entities to insert.</param>\n        /// <param name=\"batchSize\">Number of entities per batch.</param>\n        public void BulkInsert(IEnumerable<TEntity> entities, int batchSize = 100)\n        {\n            var entityList = entities.ToList();\n            if (!entityList.Any()) return;\n\n            var insertProperties = _metadata.GetInsertProperties().ToList();\n            var columns = string.Join(\", \", insertProperties.Select(p => $\"[{p.ColumnName}]\"));\n\n            for (int i = 0; i < entityList.Count; i += batchSize)\n            {\n                var batch = entityList.Skip(i).Take(batchSize).ToList();\n                ExecuteBatchInsert(batch, insertProperties, columns);\n            }\n        }\n\n        private void ExecuteBatchInsert(\n            List<TEntity> batch, \n            List<PropertyMetadata> properties,\n            string columns)\n        {\n            var sql = new StringBuilder();\n            var parameters = new List<QueryParameter>();\n            var paramIndex = 0;\n\n            sql.Append($\"INSERT INTO [{_metadata.TableName}] ({columns}) VALUES \");\n\n            var valueGroups = new List<string>();\n            foreach (var entity in batch)\n            {\n                var values = new List<string>();\n                foreach (var prop in properties)\n                {\n                    var paramName = $\"@p{paramIndex++}\";\n                    values.Add(paramName);\n                    parameters.Add(new QueryParameter\n                    {\n                        Name = paramName,\n                        Value = prop.GetValue(entity) ?? DBNull.Value\n                    });\n                }\n                valueGroups.Add($\"({string.Join(\", \", values)})\");\n            }\n\n            sql.Append(string.Join(\", \", valueGroups));\n\n            using var command = _context.CreateCommand();\n            command.CommandText = sql.ToString();\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            command.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// Bulk updates entities using a single UPDATE statement with CASE expressions.\n        /// </summary>\n        public void BulkUpdate(IEnumerable<TEntity> entities, params string[] propertyNames)\n        {\n            var entityList = entities.ToList();\n            if (!entityList.Any()) return;\n\n            var pkName = _metadata.PrimaryKey.ColumnName;\n            var propertiesToUpdate = _metadata.GetUpdateProperties()\n                .Where(p => propertyNames.Length == 0 || propertyNames.Contains(p.PropertyName))\n                .ToList();",
                    "images": [],
                    "tokenCount": 4994,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue from where I left off in the IntegrationTests.cs file. I was in the middle of writing integration tests for the ORM.",
                        "signature": "ErsCCkYIChgCKkBIllkzBOILWIyfyH0P3hqvK9MjEdhT0tvxYBmVM/rQmRURUCMo0cDnuUv9zmhSbEIG2EqqBGuNTgAf4iqtPe2pEgzISVOIOVypaKu0NWgaDEknJwuK56m8obYDQiIwlAh6UzToipttPgcfDq0I0xn2gvGZSpn/mhKgXOgSGdngP6Q8Jur0AcKQLT6lFBs+KqIBiLC+grtbG/8m5j44IhR4Emf0JivUpsndX9gFTZuSkDOrSfG+bjRiqiF1xI0FJj/gfM6nsWKwEw2VN+V/GELl7GoeXBtcm6ITh4KveRr2b3Mud2Hrd+89wN+ziB/v8Ce/8ghgILsD0XN6qFtiKc8jK1IOHrgUoPhUBEbC8qFaFDLgzm5xrh12ca3B1wb/oGo+4S7ybE8+Apd/0y2VhV7aUM9sGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 10,
            "parentIdx": 9,
            "childrenIdxs": [
                11
            ],
            "createdAt": "2025-12-04T18:17:38.554Z",
            "updatedAt": "2025-12-04T18:18:16.731Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `BulkOperations.cs` file:\n\n### BulkOperations.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\nusing MiniORM.Core.Query;\n\nnamespace MiniORM.Core.Performance\n{\n    /// <summary>\n    /// Provides bulk operation support for improved performance\n    /// when working with large datasets.\n    /// </summary>\n    public class BulkOperations<TEntity> where TEntity : class\n    {\n        private readonly DbContext _context;\n        private readonly EntityMetadata _metadata;\n\n        public BulkOperations(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n            _metadata = EntityMapper.GetMetadata<TEntity>();\n        }\n\n        /// <summary>\n        /// Bulk inserts entities using batched INSERT statements.\n        /// Much faster than inserting one at a time.\n        /// </summary>\n        /// <param name=\"entities\">Entities to insert.</param>\n        /// <param name=\"batchSize\">Number of entities per batch.</param>\n        public void BulkInsert(IEnumerable<TEntity> entities, int batchSize = 100)\n        {\n            var entityList = entities.ToList();\n            if (!entityList.Any()) return;\n\n            var insertProperties = _metadata.GetInsertProperties().ToList();\n            var columns = string.Join(\", \", insertProperties.Select(p => $\"[{p.ColumnName}]\"));\n\n            for (int i = 0; i < entityList.Count; i += batchSize)\n            {\n                var batch = entityList.Skip(i).Take(batchSize).ToList();\n                ExecuteBatchInsert(batch, insertProperties, columns);\n            }\n        }\n\n        private void ExecuteBatchInsert(\n            List<TEntity> batch, \n            List<PropertyMetadata> properties,\n            string columns)\n        {\n            var sql = new StringBuilder();\n            var parameters = new List<QueryParameter>();\n            var paramIndex = 0;\n\n            sql.Append($\"INSERT INTO [{_metadata.TableName}] ({columns}) VALUES \");\n\n            var valueGroups = new List<string>();\n            foreach (var entity in batch)\n            {\n                var values = new List<string>();\n                foreach (var prop in properties)\n                {\n                    var paramName = $\"@p{paramIndex++}\";\n                    values.Add(paramName);\n                    parameters.Add(new QueryParameter\n                    {\n                        Name = paramName,\n                        Value = prop.GetValue(entity) ?? DBNull.Value\n                    });\n                }\n                valueGroups.Add($\"({string.Join(\", \", values)})\");\n            }\n\n            sql.Append(string.Join(\", \", valueGroups));\n\n            using var command = _context.CreateCommand();\n            command.CommandText = sql.ToString();\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            command.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// Bulk updates entities using a single UPDATE statement with CASE expressions.\n        /// </summary>\n        public void BulkUpdate(IEnumerable<TEntity> entities, params string[] propertyNames)\n        {\n            var entityList = entities.ToList();\n            if (!entityList.Any()) return;\n\n            var pkName = _metadata.PrimaryKey.ColumnName;\n            var propertiesToUpdate = _metadata.GetUpdateProperties()\n                .Where(p => propertyNames.Length == 0 || propertyNames.Contains(p.PropertyName))\n                .ToList();\n\n            if (!propertiesToUpdate.Any()) return;\n\n            var sql = new StringBuilder();\n            var parameters = new List<QueryParameter>();\n            var paramIndex = 0;\n\n            sql.Append($\"UPDATE [{_metadata.TableName}] SET \");\n\n            // Build CASE expressions for each property\n            var setClauses = new List<string>();\n            foreach (var prop in propertiesToUpdate)\n            {\n                var caseBuilder = new StringBuilder();\n                caseBuilder.Append($\"[{prop.ColumnName}] = CASE [{pkName}] \");\n\n                foreach (var entity in entityList)\n                {\n                    var pkValue = _metadata.PrimaryKey.GetValue(entity);\n                    var propValue = prop.GetValue(entity);\n\n                    var pkParamName = $\"@pk{paramIndex}\";\n                    var valueParamName = $\"@v{paramIndex}\";\n                    paramIndex++;\n\n                    caseBuilder.Append($\"WHEN {pkParamName} THEN {valueParamName} \");\n\n                    parameters.Add(new QueryParameter { Name = pkParamName, Value = pkValue });\n                    parameters.Add(new QueryParameter { Name = valueParamName, Value = propValue ?? DBNull.Value });\n                }\n\n                caseBuilder.Append($\"ELSE [{prop.ColumnName}] END\");\n                setClauses.Add(caseBuilder.ToString());\n            }\n\n            sql.Append(string.Join(\", \", setClauses));\n\n            // Add WHERE clause to limit to the specific IDs\n            var pkIds = entityList.Select((e, idx) =>\n            {\n                var paramName = $\"@id{idx}\";\n                parameters.Add(new QueryParameter\n                {\n                    Name = paramName,\n                    Value = _metadata.PrimaryKey.GetValue(e)\n                });\n                return paramName;\n            });\n\n            sql.Append($\" WHERE [{pkName}] IN ({string.Join(\", \", pkIds)})\");\n\n            ExecuteWithParameters(sql.ToString(), parameters);\n        }\n\n        /// <summary>\n        /// Bulk deletes entities by their primary keys.\n        /// </summary>\n        public void BulkDelete(IEnumerable<TEntity> entities)\n        {\n            var entityList = entities.ToList();\n            if (!entityList.Any()) return;\n\n            var pkName = _metadata.PrimaryKey.ColumnName;\n            var parameters = new List<QueryParameter>();\n\n            var pkParams = entityList.Select((e, idx) =>\n            {\n                var paramName = $\"@p{idx}\";\n                parameters.Add(new QueryParameter\n                {\n                    Name = paramName,\n                    Value = _metadata.PrimaryKey.GetValue(e)\n                });\n                return paramName;\n            });\n\n            var sql = $\"DELETE FROM [{_metadata.TableName}] WHERE [{pkName}] IN ({string.Join(\", \", pkParams)})\";\n\n            ExecuteWithParameters(sql, parameters);\n        }\n\n        /// <summary>\n        /// Bulk deletes entities matching a condition.\n        /// </summary>\n        public int BulkDeleteWhere(string whereClause, params (string name, object value)[] parameters)\n        {\n            var sql = $\"DELETE FROM [{_metadata.TableName}] WHERE {whereClause}\";\n            \n            var queryParams = parameters.Select(p => new QueryParameter\n            {\n                Name = p.name.StartsWith(\"@\") ? p.name : $\"@{p.name}\",\n                Value = p.value ?? DBNull.Value\n            }).ToList();\n\n            return ExecuteWithParameters(sql, queryParams);\n        }\n\n        /// <summary>\n        /// Bulk updates entities matching a condition.\n        /// </summary>\n        public int BulkUpdateWhere(\n            Dictionary<string, object> setValues,\n            string whereClause,\n            params (string name, object value)[] whereParameters)\n        {\n            var sql = new StringBuilder();\n            var parameters = new List<QueryParameter>();\n            var paramIndex = 0;\n\n            sql.Append($\"UPDATE [{_metadata.TableName}] SET \");\n\n            var setClauses = new List<string>();\n            foreach (var kvp in setValues)\n            {\n                var paramName = $\"@set{paramIndex++}\";\n                setClauses.Add($\"[{kvp.Key}] = {paramName}\");\n                parameters.Add(new QueryParameter { Name = paramName, Value = kvp.Value ?? DBNull.Value });\n            }\n\n            sql.Append(string.Join(\", \", setClauses));\n            sql.Append($\" WHERE {whereClause}\");\n\n            foreach (var (name, value) in whereParameters)\n            {\n                parameters.Add(new QueryParameter\n                {\n                    Name = name.StartsWith(\"@\") ? name : $\"@{name}\",\n                    Value = value ?? DBNull.Value\n                });\n            }\n\n            return ExecuteWithParameters(sql.ToString(), parameters);\n        }\n\n        /// <summary>\n        /// Executes a SQL command with parameters.\n        /// </summary>\n        private int ExecuteWithParameters(string sql, List<QueryParameter> parameters)\n        {\n            using var command = _context.CreateCommand();\n            command.CommandText = sql;\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            return command.ExecuteNonQuery();\n        }\n    }\n}\n```\n\n### ConnectionPool.cs\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Data;\nusing System.Threading;\n\nnamespace MiniORM.Core.Performance\n{\n    /// <summary>\n    /// Simple connection pool implementation.\n    /// Note: ADO.NET already provides connection pooling, but this demonstrates the pattern.\n    /// \n    /// Design Pattern: Object Pool Pattern\n    /// - Reuses expensive-to-create objects (connections)\n    /// </summary>\n    public class ConnectionPool : IDisposable\n    {\n        private readonly IDbConnectionFactory _connectionFactory;\n        private readonly ConcurrentBag<IDbConnection> _availableConnections;\n        private readonly SemaphoreSlim _semaphore;\n        private readonly int _maxPoolSize;\n        private int _currentPoolSize;\n        private bool _disposed;\n\n        public ConnectionPool(IDbConnectionFactory connectionFactory, int maxPoolSize = 10)\n        {\n            _connectionFactory = connectionFactory ?? throw new ArgumentNullException(nameof(connectionFactory));\n            _maxPoolSize = maxPoolSize;\n            _availableConnections = new ConcurrentBag<IDbConnection>();\n            _semaphore = new SemaphoreSlim(maxPoolSize, maxPoolSize);\n        }\n\n        /// <summary>\n        /// Gets a connection from the pool, or creates a new one if needed.\n        /// </summary>\n        public IDbConnection GetConnection()\n        {\n            _semaphore.Wait();\n\n            if (_availableConnections.TryTake(out var connection))\n            {\n                if (connection.State == ConnectionState.Closed)\n                {\n                    connection.Open();\n                }\n                return connection;\n            }\n\n            // Create new connection\n            connection = _connectionFactory.CreateConnection();\n            connection.Open();\n            Interlocked.Increment(ref _currentPoolSize);\n            return connection;\n        }\n\n        /// <summary>\n        /// Returns a connection to the pool.\n        /// </summary>\n        public void ReturnConnection(IDbConnection connection)\n        {\n            if (connection == null) return;\n\n            if (connection.State == ConnectionState.Open && !_disposed)\n            {\n                _availableConnections.Add(connection);\n            }\n            else\n            {\n                connection.Dispose();\n                Interlocked.Decrement(ref _currentPoolSize);\n            }\n\n            _semaphore.Release();\n        }\n\n        /// <summary>\n        /// Gets the current number of connections in the pool.\n        /// </summary>\n        public int CurrentPoolSize => _currentPoolSize;\n\n        /// <summary>\n        /// Gets the number of available connections.\n        /// </summary>\n        public int AvailableConnections => _availableConnections.Count;\n\n        public void Dispose()\n        {\n            if (_disposed) return;\n            _disposed = true;\n\n            while (_availableConnections.TryTake(out var connection))\n            {\n                connection.Dispose();\n            }\n\n            _semaphore.Dispose();\n        }\n    }\n\n    /// <summary>\n    /// Wrapper for pooled connections that returns to pool on dispose.\n    /// </summary>\n    public class PooledConnection : IDbConnection\n    {\n        private readonly IDbConnection _innerConnection;\n        private readonly ConnectionPool _pool;\n        private bool _disposed;\n\n        public PooledConnection(IDbConnection innerConnection, ConnectionPool pool)\n        {\n            _innerConnection = innerConnection;\n            _pool = pool;\n        }\n\n        public string ConnectionString\n        {\n            get => _innerConnection.ConnectionString;\n            set => _innerConnection.ConnectionString = value;\n        }\n\n        public int ConnectionTimeout => _innerConnection.ConnectionTimeout;\n        public string Database => _innerConnection.Database;\n        public ConnectionState State => _innerConnection.State;\n\n        public IDbTransaction BeginTransaction() => _innerConnection.BeginTransaction();\n        public IDbTransaction BeginTransaction(IsolationLevel il) => _innerConnection.BeginTransaction(il);\n        public void ChangeDatabase(string databaseName) => _innerConnection.ChangeDatabase(databaseName);\n        public void Close() => _innerConnection.Close();\n        public IDbCommand CreateCommand() => _innerConnection.CreateCommand();\n        public void Open() => _innerConnection.Open();\n\n        public void Dispose()\n        {\n            if (_disposed) return;\n            _disposed = true;\n            _pool.ReturnConnection(_innerConnection);\n        }\n    }\n}\n```\n\n### QueryCache.cs\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace MiniORM.Core.Performance\n{\n    /// <summary>\n    /// Caches query results for improved performance on repeated queries.\n    /// \n    /// Design Pattern: Cache-Aside Pattern\n    /// - Application code is responsible for loading data into cache\n    /// </summary>\n    public class QueryCache\n    {\n        private readonly ConcurrentDictionary<string, CacheEntry> _cache;\n        private readonly TimeSpan _defaultExpiration;\n        private readonly int _maxCacheSize;\n\n        public QueryCache(TimeSpan? defaultExpiration = null, int maxCacheSize = 1000)\n        {\n            _cache = new ConcurrentDictionary<string, CacheEntry>();\n            _defaultExpiration = defaultExpiration ?? TimeSpan.FromMinutes(5);\n            _maxCacheSize = maxCacheSize;\n        }\n\n        /// <summary>\n        /// Gets a cached result or executes the query.\n        /// </summary>\n        public TResult GetOrSet<TResult>(\n            string sql,\n            IReadOnlyList<QueryParameter> parameters,\n            Func<TResult> queryExecutor,\n            TimeSpan? expiration = null)\n        {\n            var key = GenerateCacheKey(sql, parameters);\n\n            if (_cache.TryGetValue(key, out var entry))\n            {\n                if (!entry.IsExpired)\n                {\n                    return (TResult)entry.Value;\n                }\n                \n                // Remove expired entry\n                _cache.TryRemove(key, out _);\n            }\n\n            // Execute query and cache result\n            var result = queryExecutor();\n            \n            if (_cache.Count < _maxCacheSize)\n            {\n                var newEntry = new CacheEntry\n                {\n                    Value = result,\n                    ExpiresAt = DateTime.UtcNow.Add(expiration ?? _defaultExpiration)\n                };\n                _cache.TryAdd(key, newEntry);\n            }\n\n            return result;\n        }\n\n        /// <summary>\n        /// Invalidates cache entries for a specific table.\n        /// </summary>\n        public void InvalidateTable(string tableName)\n        {\n            var keysToRemove = new List<string>();\n\n            foreach (var kvp in _cache)\n            {\n                if (kvp.Key.Contains(tableName, StringComparison.OrdinalIgnoreCase))\n                {\n                    keysToRemove.Add(kvp.Key);\n                }\n            }\n\n            foreach (var key in keysToRemove)\n            {\n                _cache.TryRemove(key, out _);\n            }\n        }\n\n        /// <summary>\n        /// Clears all cached entries.\n        /// </summary>\n        public void Clear()\n        {\n            _cache.Clear();\n        }\n\n        /// <summary>\n        /// Removes expired entries from the cache.\n        /// </summary>\n        public void CleanupExpired()\n        {\n            var keysToRemove = new List<string>();\n\n            foreach (var kvp in _cache)\n            {\n                if (kvp.Value.IsExpired)\n                {\n                    keysToRemove.Add(kvp.Key);\n                }\n            }\n\n            foreach (var key in keysToRemove)\n            {\n                _cache.TryRemove(key, out _);\n            }\n        }\n\n        /// <summary>\n        /// Gets the number of cached entries.\n        /// </summary>\n        public int Count => _cache.Count;\n\n        /// <summary>\n        /// Generates a cache key from SQL and parameters.\n        /// </summary>\n        private static string GenerateCacheKey(string sql, IReadOnlyList<QueryParameter> parameters)\n        {\n            var sb = new StringBuilder(sql);\n\n            if (parameters != null)\n            {\n                foreach (var param in parameters)\n                {\n                    sb.Append($\"|{param.Name}={param.Value}\");\n                }\n            }\n\n            // Generate hash for shorter key\n            using var sha256 = SHA256.Create();\n            var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(sb.ToString()));\n            return Convert.ToBase64String(hashBytes);\n        }\n\n        private class CacheEntry\n        {\n            public object Value { get; set; }\n            public DateTime ExpiresAt { get; set; }\n            public bool IsExpired => DateTime.UtcNow > ExpiresAt;\n        }\n    }\n}\n```\n\n---\n\n## 14. Lazy Loading and Eager Loading\n\n### LazyLoader.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing MiniORM.Core.Attributes;\n\nnamespace MiniORM.Core.Loading\n{\n    /// <summary>\n    /// Provides lazy loading support for navigation properties.\n    /// \n    /// Design Pattern: Proxy Pattern / Virtual Proxy\n    /// - Delays loading of related entities until accessed\n    /// </summary>\n    public class LazyLoader\n    {\n        private readonly DbContext _context;\n        private readonly Dictionary<string, bool> _loadedProperties = new Dictionary<string, bool>();\n\n        public LazyLoader(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n        }\n\n        /// <summary>\n        /// Loads a related entity (many-to-one relationship).\n        /// </summary>\n        public TRelated LoadReference<TEntity, TRelated>(\n            TEntity entity,\n            string navigationPropertyName,\n            string foreignKeyPropertyName)\n            where TEntity : class\n            where TRelated : class, new()\n        {\n            var key = $\"{typeof(TEntity).Name}.{entity.GetHashCode()}.{navigationPropertyName}\";\n\n            if (_loadedProperties.ContainsKey(key))\n            {\n                return GetPropertyValue<TRelated>(entity, navigationPropertyName);\n            }\n\n            // Get the foreign key value\n            var fkValue = GetPropertyValue<object>(entity, foreignKeyPropertyName);\n            if (fkValue == null) return null;\n\n            // Load the related entity\n            var relatedMetadata = EntityMapper.GetMetadata<TRelated>();\n            var pkColumn = relatedMetadata.PrimaryKey.ColumnName;\n\n            var query = new Query.SqlQueryBuilder()\n                .Select<TRelated>()\n                .From<TRelated>()\n                .Where(pkColumn, fkValue);\n\n            var (sql, parameters) = query.Build();\n\n            using var command = _context.CreateCommand();\n            command.CommandText = sql;\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value ?? DBNull.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            using var reader = command.ExecuteReader();\n            TRelated related = null;\n\n            if (reader.Read())\n            {\n                related = EntityMapper.MapFromReader<TRelated>(reader);\n            }\n\n            // Set the navigation property\n            SetPropertyValue(entity, navigationPropertyName, related);\n            _loadedProperties[key] = true;\n\n            return related;\n        }\n\n        /// <summary>\n        /// Loads a collection of related entities (one-to-many relationship).\n        /// </summary>\n        public ICollection<TRelated> LoadCollection<TEntity, TRelated>(\n            TEntity entity,\n            string navigationPropertyName,\n            string foreignKeyPropertyName)\n            where TEntity : class\n            where TRelated : class, new()\n        {\n            var key = $\"{typeof(TEntity).Name}.{entity.GetHashCode()}.{navigationPropertyName}\";\n\n            if (_loadedProperties.ContainsKey(key))\n            {\n                return GetPropertyValue<ICollection<TRelated>>(entity, navigationPropertyName);\n            }\n\n            // Get the primary key value of the parent entity\n            var entityMetadata = EntityMapper.GetMetadata<TEntity>();\n            var pkValue = entityMetadata.PrimaryKey.GetValue(entity);\n\n            // Load the related entities\n            var query = new Query.SqlQueryBuilder()\n                .Select<TRelated>()\n                .From<TRelated>()\n                .Where(foreignKeyPropertyName, pkValue);\n\n            var (sql, parameters) = query.Build();\n\n            using var command = _context.CreateCommand();\n            command.CommandText = sql;\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value ?? DBNull.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            using var reader = command.ExecuteReader();\n            var relatedEntities = EntityMapper.MapAllFromReader<TRelated>(reader);\n\n            // Set the navigation property\n            var collection = new List<TRelated>(relatedEntities);\n            SetPropertyValue(entity, navigationPropertyName, collection);\n            _loadedProperties[key] = true;\n\n            return collection;\n        }\n\n        private static T GetPropertyValue<T>(object entity, string propertyName)\n        {\n            var property = entity.GetType().GetProperty(propertyName);\n            return (T)property?.GetValue(entity);\n        }\n\n        private static void SetPropertyValue(object entity, string propertyName, object value)\n        {\n            var property = entity.GetType().GetProperty(propertyName);\n            property?.SetValue(entity, value);\n        }\n    }\n}\n```\n\n### EagerLoader.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing MiniORM.Core.Query;\n\nnamespace MiniORM.Core.Loading\n{\n    /// <summary>\n    /// Provides eager loading support to load related entities in a single query.\n    /// \n    /// Design Pattern: Strategy Pattern\n    /// - Different loading strategies can be applied\n    /// </summary>\n    public class EagerLoader<TEntity> where TEntity : class, new()\n    {\n        private readonly DbContext _context;\n        private readonly EntityMetadata _metadata;\n        private readonly List<IncludeDefinition> _includes = new List<IncludeDefinition>();\n\n        public EagerLoader(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n            _metadata = EntityMapper.GetMetadata<TEntity>();\n        }\n\n        /// <summary>\n        /// Specifies a related entity to include in the query results.\n        /// </summary>\n        public EagerLoader<TEntity> Include<TRelated>(\n            Expression<Func<TEntity, TRelated>> navigationProperty,\n            string foreignKeyProperty,\n            string relatedPrimaryKey = \"Id\")\n            where TRelated : class\n        {\n            var memberExpression = navigationProperty.Body as MemberExpression;\n            if (memberExpression == null)\n            {\n                throw new ArgumentException(\"Expression must be a member expression\");\n            }\n\n            _includes.Add(new IncludeDefinition\n            {\n                NavigationPropertyName = memberExpression.Member.Name,\n                RelatedType = typeof(TRelated),\n                ForeignKeyProperty = foreignKeyProperty,\n                RelatedPrimaryKey = relatedPrimaryKey,\n                IsCollection = false\n            });\n\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies a collection of related entities to include.\n        /// </summary>\n        public EagerLoader<TEntity> IncludeCollection<TRelated>(\n            Expression<Func<TEntity, IEnumerable<TRelated>>> navigationProperty,\n            string foreignKeyProperty)\n            where TRelated : class\n        {\n            var memberExpression = navigationProperty.Body as MemberExpression;\n            if (memberExpression == null)\n            {\n                throw new ArgumentException(\"Expression must be a member expression\");\n            }\n\n            _includes.Add(new IncludeDefinition\n            {\n                NavigationPropertyName = memberExpression.Member.Name,\n                RelatedType = typeof(TRelated),\n                ForeignKeyProperty = foreignKeyProperty,\n                IsCollection = true\n            });\n\n            return this;\n        }\n\n        /// <summary>\n        /// Executes the query and loads all entities with their related data.\n        /// </summary>\n        public List",
                    "images": [],
                    "tokenCount": 4976,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue with the BulkOperations.cs file and then complete the tutorial with any remaining sections. Let me continue from where I left off.",
                        "signature": "EskCCkYIChgCKkDCYt4uxp0cOAqa0SXWsKB0ElUvL6+nC9UmtnkDRm0aqpwZLr//AuNIsO6C7+hLyzCCMcjxZwlWYAxdsrpunVZSEgxntEPO9HI5RdmGQpEaDEjSjgvfeCexaQoFlyIwfowQygm/dNcmOR1ERVSEkf3vPp2zHzc7HSYtXSv4ROgi/EFBs/J6wfdUW3w0UikfKrABkdz5KFSg3uaNVh1/dTpzPgyhtTFozMU/pI9dRKjr7ebA6JqnNbOYnF9jgel5wuNE/S0HbkXLEIUcXSfplnw4IpVU4L7IYRMNfVCsbOzpRDInvyN4v2mZdx+80WNvhbokzm+8FtMVajwLSCer8ZXsHyOKcSitefMqn2BFibgngdzhwaxfCw2NaHqTa6QThFLSu3eN4R4F8Tl0iuFnvWrQavXkch0CjYFWzjqip1FUJnsYAQ=="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 11,
            "parentIdx": 10,
            "childrenIdxs": [
                12
            ],
            "createdAt": "2025-12-04T18:19:21.978Z",
            "updatedAt": "2025-12-04T18:20:17.696Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `EagerLoader.cs` file:\n\n### EagerLoader.cs (Continued)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing MiniORM.Core.Query;\n\nnamespace MiniORM.Core.Loading\n{\n    /// <summary>\n    /// Provides eager loading support to load related entities in a single query.\n    /// \n    /// Design Pattern: Strategy Pattern\n    /// - Different loading strategies can be applied\n    /// </summary>\n    public class EagerLoader<TEntity> where TEntity : class, new()\n    {\n        private readonly DbContext _context;\n        private readonly EntityMetadata _metadata;\n        private readonly List<IncludeDefinition> _includes = new List<IncludeDefinition>();\n        private readonly SqlQueryBuilder _queryBuilder = new SqlQueryBuilder();\n\n        public EagerLoader(DbContext context)\n        {\n            _context = context ?? throw new ArgumentNullException(nameof(context));\n            _metadata = EntityMapper.GetMetadata<TEntity>();\n        }\n\n        /// <summary>\n        /// Specifies a related entity to include in the query results.\n        /// </summary>\n        public EagerLoader<TEntity> Include<TRelated>(\n            Expression<Func<TEntity, TRelated>> navigationProperty,\n            string foreignKeyProperty,\n            string relatedPrimaryKey = \"Id\")\n            where TRelated : class\n        {\n            var memberExpression = navigationProperty.Body as MemberExpression;\n            if (memberExpression == null)\n            {\n                throw new ArgumentException(\"Expression must be a member expression\");\n            }\n\n            _includes.Add(new IncludeDefinition\n            {\n                NavigationPropertyName = memberExpression.Member.Name,\n                RelatedType = typeof(TRelated),\n                ForeignKeyProperty = foreignKeyProperty,\n                RelatedPrimaryKey = relatedPrimaryKey,\n                IsCollection = false\n            });\n\n            return this;\n        }\n\n        /// <summary>\n        /// Specifies a collection of related entities to include.\n        /// </summary>\n        public EagerLoader<TEntity> IncludeCollection<TRelated>(\n            Expression<Func<TEntity, IEnumerable<TRelated>>> navigationProperty,\n            string foreignKeyProperty)\n            where TRelated : class\n        {\n            var memberExpression = navigationProperty.Body as MemberExpression;\n            if (memberExpression == null)\n            {\n                throw new ArgumentException(\"Expression must be a member expression\");\n            }\n\n            _includes.Add(new IncludeDefinition\n            {\n                NavigationPropertyName = memberExpression.Member.Name,\n                RelatedType = typeof(TRelated),\n                ForeignKeyProperty = foreignKeyProperty,\n                IsCollection = true\n            });\n\n            return this;\n        }\n\n        /// <summary>\n        /// Adds a WHERE condition.\n        /// </summary>\n        public EagerLoader<TEntity> Where(Expression<Func<TEntity, bool>> predicate)\n        {\n            var parser = new ExpressionParser();\n            var whereClause = parser.ParsePredicate(predicate, _queryBuilder);\n            _queryBuilder.Where(whereClause);\n            return this;\n        }\n\n        /// <summary>\n        /// Adds ordering.\n        /// </summary>\n        public EagerLoader<TEntity> OrderBy<TKey>(\n            Expression<Func<TEntity, TKey>> keySelector,\n            bool descending = false)\n        {\n            var memberExpression = keySelector.Body as MemberExpression;\n            if (memberExpression != null)\n            {\n                var property = _metadata.MappedProperties\n                    .FirstOrDefault(p => p.PropertyName == memberExpression.Member.Name);\n                \n                if (property != null)\n                {\n                    _queryBuilder.OrderBy(property.ColumnName, descending);\n                }\n            }\n            return this;\n        }\n\n        /// <summary>\n        /// Executes the query and loads all entities with their related data.\n        /// Uses multiple queries strategy (one per include).\n        /// </summary>\n        public List<TEntity> ToList()\n        {\n            // First, load the main entities\n            _queryBuilder.Select<TEntity>().From<TEntity>();\n            var (sql, parameters) = _queryBuilder.Build();\n\n            List<TEntity> entities;\n            using (var command = CreateCommand(sql, parameters))\n            using (var reader = command.ExecuteReader())\n            {\n                entities = EntityMapper.MapAllFromReader<TEntity>(reader);\n            }\n\n            if (!entities.Any() || !_includes.Any())\n            {\n                return entities;\n            }\n\n            // Load related entities for each include\n            foreach (var include in _includes)\n            {\n                if (include.IsCollection)\n                {\n                    LoadCollectionRelationship(entities, include);\n                }\n                else\n                {\n                    LoadSingleRelationship(entities, include);\n                }\n            }\n\n            return entities;\n        }\n\n        /// <summary>\n        /// Executes the query and returns the first entity or null.\n        /// </summary>\n        public TEntity FirstOrDefault()\n        {\n            _queryBuilder.Top(1);\n            var results = ToList();\n            return results.FirstOrDefault();\n        }\n\n        /// <summary>\n        /// Loads single navigation properties (many-to-one).\n        /// </summary>\n        private void LoadSingleRelationship(List<TEntity> entities, IncludeDefinition include)\n        {\n            // Get all foreign key values\n            var fkProperty = _metadata.MappedProperties\n                .FirstOrDefault(p => p.PropertyName == include.ForeignKeyProperty);\n\n            if (fkProperty == null) return;\n\n            var fkValues = entities\n                .Select(e => fkProperty.GetValue(e))\n                .Where(v => v != null)\n                .Distinct()\n                .ToList();\n\n            if (!fkValues.Any()) return;\n\n            // Load all related entities in one query\n            var relatedMetadata = EntityMapper.GetMetadata(include.RelatedType);\n            var relatedQuery = new SqlQueryBuilder()\n                .SelectAll()\n                .From(relatedMetadata.TableName)\n                .WhereIn(include.RelatedPrimaryKey, fkValues);\n\n            var (sql, parameters) = relatedQuery.Build();\n\n            Dictionary<object, object> relatedEntitiesMap;\n            using (var command = CreateCommand(sql, parameters))\n            using (var reader = command.ExecuteReader())\n            {\n                var relatedEntities = MapAllFromReaderDynamic(reader, include.RelatedType);\n                var pkProp = relatedMetadata.PrimaryKey;\n                relatedEntitiesMap = relatedEntities.ToDictionary(e => pkProp.GetValue(e));\n            }\n\n            // Set navigation properties\n            var navProperty = typeof(TEntity).GetProperty(include.NavigationPropertyName);\n            foreach (var entity in entities)\n            {\n                var fkValue = fkProperty.GetValue(entity);\n                if (fkValue != null && relatedEntitiesMap.TryGetValue(fkValue, out var related))\n                {\n                    navProperty.SetValue(entity, related);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Loads collection navigation properties (one-to-many).\n        /// </summary>\n        private void LoadCollectionRelationship(List<TEntity> entities, IncludeDefinition include)\n        {\n            // Get all primary key values\n            var pkValues = entities\n                .Select(e => _metadata.PrimaryKey.GetValue(e))\n                .Distinct()\n                .ToList();\n\n            if (!pkValues.Any()) return;\n\n            // Load all related entities in one query\n            var relatedMetadata = EntityMapper.GetMetadata(include.RelatedType);\n            var relatedQuery = new SqlQueryBuilder()\n                .SelectAll()\n                .From(relatedMetadata.TableName)\n                .WhereIn(include.ForeignKeyProperty, pkValues);\n\n            var (sql, parameters) = relatedQuery.Build();\n\n            List<object> relatedEntities;\n            using (var command = CreateCommand(sql, parameters))\n            using (var reader = command.ExecuteReader())\n            {\n                relatedEntities = MapAllFromReaderDynamic(reader, include.RelatedType);\n            }\n\n            // Group related entities by foreign key\n            var fkProp = relatedMetadata.MappedProperties\n                .FirstOrDefault(p => p.PropertyName == include.ForeignKeyProperty \n                                  || p.ColumnName == include.ForeignKeyProperty);\n\n            if (fkProp == null) return;\n\n            var groupedRelated = relatedEntities\n                .GroupBy(e => fkProp.GetValue(e))\n                .ToDictionary(g => g.Key, g => g.ToList());\n\n            // Set navigation properties\n            var navProperty = typeof(TEntity).GetProperty(include.NavigationPropertyName);\n            var listType = typeof(List<>).MakeGenericType(include.RelatedType);\n\n            foreach (var entity in entities)\n            {\n                var pkValue = _metadata.PrimaryKey.GetValue(entity);\n                \n                if (groupedRelated.TryGetValue(pkValue, out var related))\n                {\n                    var list = Activator.CreateInstance(listType);\n                    var addMethod = listType.GetMethod(\"AddRange\");\n                    addMethod.Invoke(list, new object[] { related });\n                    navProperty.SetValue(entity, list);\n                }\n                else\n                {\n                    // Set empty collection\n                    navProperty.SetValue(entity, Activator.CreateInstance(listType));\n                }\n            }\n        }\n\n        /// <summary>\n        /// Maps all rows from a reader to objects of a specific type.\n        /// </summary>\n        private List<object> MapAllFromReaderDynamic(System.Data.IDataReader reader, Type entityType)\n        {\n            var results = new List<object>();\n            var metadata = EntityMapper.GetMetadata(entityType);\n\n            // Get column names\n            var columnNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            for (int i = 0; i < reader.FieldCount; i++)\n            {\n                columnNames.Add(reader.GetName(i));\n            }\n\n            while (reader.Read())\n            {\n                var entity = Activator.CreateInstance(entityType);\n\n                foreach (var property in metadata.MappedProperties)\n                {\n                    if (columnNames.Contains(property.ColumnName))\n                    {\n                        var ordinal = reader.GetOrdinal(property.ColumnName);\n                        var value = reader.IsDBNull(ordinal) ? null : reader.GetValue(ordinal);\n                        property.SetValue(entity, value);\n                    }\n                }\n\n                if (entity is EntityBase entityBase)\n                {\n                    entityBase.State = EntityState.Unchanged;\n                }\n\n                results.Add(entity);\n            }\n\n            return results;\n        }\n\n        private System.Data.IDbCommand CreateCommand(string sql, IReadOnlyList<QueryParameter> parameters)\n        {\n            var command = _context.CreateCommand();\n            command.CommandText = sql;\n\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value ?? DBNull.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            return command;\n        }\n\n        /// <summary>\n        /// Definition for an include operation.\n        /// </summary>\n        private class IncludeDefinition\n        {\n            public string NavigationPropertyName { get; set; }\n            public Type RelatedType { get; set; }\n            public string ForeignKeyProperty { get; set; }\n            public string RelatedPrimaryKey { get; set; }\n            public bool IsCollection { get; set; }\n        }\n    }\n}\n```\n\n---\n\n## 15. Final Demo Application\n\nLet's create a comprehensive demo that showcases all the features of our ORM.\n\n### Program.cs (Complete Demo)\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing MiniORM.Core;\nusing MiniORM.Core.Attributes;\nusing MiniORM.Core.Connection;\nusing MiniORM.Core.Loading;\nusing MiniORM.Core.Performance;\nusing MiniORM.Core.Query;\nusing MiniORM.Core.Repository;\nusing MiniORM.Core.UnitOfWork;\n\nnamespace MiniORM.Demo\n{\n    #region Entity Definitions\n\n    [Table(\"Authors\")]\n    public class Author : EntityBase\n    {\n        private int _id;\n        private string _name;\n        private string _email;\n        private DateTime _birthDate;\n\n        [PrimaryKey(AutoGenerate = true)]\n        public int Id { get => _id; set => SetProperty(ref _id, value); }\n\n        [Column(\"FullName\", MaxLength = 100)]\n        public string Name { get => _name; set => SetProperty(ref _name, value); }\n\n        [Column(\"Email\", MaxLength = 150)]\n        public string Email { get => _email; set => SetProperty(ref _email, value); }\n\n        public DateTime BirthDate { get => _birthDate; set => SetProperty(ref _birthDate, value); }\n\n        [NotMapped]\n        public List<Book> Books { get; set; } = new List<Book>();\n\n        [NotMapped]\n        public int Age => DateTime.Now.Year - BirthDate.Year;\n    }\n\n    [Table(\"Books\")]\n    public class Book : EntityBase\n    {\n        private int _id;\n        private string _title;\n        private string _isbn;\n        private decimal _price;\n        private int _authorId;\n        private int _categoryId;\n        private DateTime _publishedDate;\n        private bool _isAvailable;\n\n        [PrimaryKey(AutoGenerate = true)]\n        public int Id { get => _id; set => SetProperty(ref _id, value); }\n\n        [Column(\"Title\", MaxLength = 200)]\n        public string Title { get => _title; set => SetProperty(ref _title, value); }\n\n        [Column(\"ISBN\", MaxLength = 20)]\n        public string Isbn { get => _isbn; set => SetProperty(ref _isbn, value); }\n\n        public decimal Price { get => _price; set => SetProperty(ref _price, value); }\n\n        [ForeignKey(typeof(Author))]\n        public int AuthorId { get => _authorId; set => SetProperty(ref _authorId, value); }\n\n        [ForeignKey(typeof(Category))]\n        public int CategoryId { get => _categoryId; set => SetProperty(ref _categoryId, value); }\n\n        public DateTime PublishedDate { get => _publishedDate; set => SetProperty(ref _publishedDate, value); }\n\n        public bool IsAvailable { get => _isAvailable; set => SetProperty(ref _isAvailable, value); }\n\n        [NotMapped]\n        public Author Author { get; set; }\n\n        [NotMapped]\n        public Category Category { get; set; }\n    }\n\n    [Table(\"Categories\")]\n    public class Category : EntityBase\n    {\n        private int _id;\n        private string _name;\n        private string _description;\n\n        [PrimaryKey(AutoGenerate = true)]\n        public int Id { get => _id; set => SetProperty(ref _id, value); }\n\n        [Column(\"Name\", MaxLength = 50)]\n        public string Name { get => _name; set => SetProperty(ref _name, value); }\n\n        [Column(\"Description\", MaxLength = 500)]\n        public string Description { get => _description; set => SetProperty(ref _description, value); }\n\n        [NotMapped]\n        public List<Book> Books { get; set; } = new List<Book>();\n    }\n\n    #endregion\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"╔════════════════════════════════════════════════════════════╗\");\n            Console.WriteLine(\"║          MiniORM - Complete Feature Demonstration          ║\");\n            Console.WriteLine(\"╚════════════════════════════════════════════════════════════╝\\n\");\n\n            // Use SQLite for demo (easy setup, no server required)\n            var connectionString = \"Data Source=miniorm_demo.db\";\n            var connectionFactory = new SqliteConnectionFactory(connectionString);\n\n            using var context = new DbContext(connectionFactory);\n\n            try\n            {\n                // Setup\n                SetupDatabase(context);\n                SeedData(context);\n\n                // Demonstrations\n                DemoBasicCrud(context);\n                DemoQueryBuilder(context);\n                DemoExpressionQueries(context);\n                DemoUnitOfWork(context);\n                DemoChangeTracking(context);\n                DemoEagerLoading(context);\n                DemoBulkOperations(context);\n                DemoTransactions(context);\n                DemoCaching(context);\n\n                Console.WriteLine(\"\\n╔════════════════════════════════════════════════════════════╗\");\n                Console.WriteLine(\"║              All Demonstrations Completed!                  ║\");\n                Console.WriteLine(\"╚════════════════════════════════════════════════════════════╝\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"\\n❌ Error: {ex.Message}\");\n                Console.WriteLine(ex.StackTrace);\n            }\n\n            Console.WriteLine(\"\\nPress any key to exit...\");\n            Console.ReadKey();\n        }\n\n        static void SetupDatabase(DbContext context)\n        {\n            Console.WriteLine(\"📦 Setting up database schema...\\n\");\n\n            context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Authors (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    FullName TEXT NOT NULL,\n                    Email TEXT NOT NULL,\n                    BirthDate TEXT NOT NULL\n                )\");\n\n            context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Categories (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    Name TEXT NOT NULL,\n                    Description TEXT\n                )\");\n\n            context.ExecuteNonQuery(@\"\n                CREATE TABLE IF NOT EXISTS Books (\n                    Id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    Title TEXT NOT NULL,\n                    ISBN TEXT NOT NULL,\n                    Price REAL NOT NULL,\n                    AuthorId INTEGER NOT NULL,\n                    CategoryId INTEGER NOT NULL,\n                    PublishedDate TEXT NOT NULL,\n                    IsAvailable INTEGER NOT NULL DEFAULT 1,\n                    FOREIGN KEY (AuthorId) REFERENCES Authors(Id),\n                    FOREIGN KEY (CategoryId) REFERENCES Categories(Id)\n                )\");\n\n            // Clear existing data for fresh demo\n            context.ExecuteNonQuery(\"DELETE FROM Books\");\n            context.ExecuteNonQuery(\"DELETE FROM Authors\");\n            context.ExecuteNonQuery(\"DELETE FROM Categories\");\n\n            Console.WriteLine(\"   ✓ Database schema created\\n\");\n        }\n\n        static void SeedData(DbContext context)\n        {\n            Console.WriteLine(\"🌱 Seeding sample data...\\n\");\n\n            var authorRepo = new Repository<Author>(context);\n            var categoryRepo = new Repository<Category>(context);\n            var bookRepo = new Repository<Book>(context);\n\n            // Authors\n            var authors = new[]\n            {\n                new Author { Name = \"George Orwell\", Email = \"orwell@books.com\", BirthDate = new DateTime(1903, 6, 25) },\n                new Author { Name = \"Jane Austen\", Email = \"austen@books.com\", BirthDate = new DateTime(1775, 12, 16) },\n                new Author { Name = \"Mark Twain\", Email = \"twain@books.com\", BirthDate = new DateTime(1835, 11, 30) },\n                new Author { Name = \"Virginia Woolf\", Email = \"woolf@books.com\", BirthDate = new DateTime(1882, 1, 25) },\n                new Author { Name = \"Ernest Hemingway\", Email = \"hemingway@books.com\", BirthDate = new DateTime(1899, 7, 21) }\n            };\n\n            foreach (var author in authors)\n            {\n                authorRepo.Add(author);\n            }\n\n            // Categories\n            var categories = new[]\n            {\n                new Category { Name = \"Fiction\", Description = \"Literary fiction and novels\" },\n                new Category { Name = \"Classic\", Description = \"Classic literature\" },\n                new Category { Name = \"Dystopian\", Description = \"Dystopian and speculative fiction\" },\n                new Category { Name = \"Romance\", Description = \"Romance novels\" },\n                new Category { Name = \"Adventure\", Description = \"Adventure stories\" }\n            };\n\n            foreach (var category in categories)\n            {\n                categoryRepo.Add(category);\n            }\n\n            // Books\n            var books = new[]\n            {\n                new Book { Title = \"1984\", Isbn = \"978-0451524935\", Price = 15.99m, AuthorId = authors[0].Id, CategoryId = categories[2].Id, PublishedDate = new DateTime(1949, 6, 8), IsAvailable = true },\n                new Book { Title = \"Animal Farm\", Isbn = \"978-0451526342\", Price = 12.99m, AuthorId = authors[0].Id, CategoryId = categories[2].Id, PublishedDate = new DateTime(1945, 8, 17), IsAvailable = true },\n                new Book { Title = \"Pride and Prejudice\", Isbn = \"978-0141439518\", Price = 10.99m, AuthorId = authors[1].Id, CategoryId = categories[3].Id, PublishedDate = new DateTime(1813, 1, 28), IsAvailable = true },\n                new Book { Title = \"Sense and Sensibility\", Isbn = \"978-0141439662\", Price = 11.99m, AuthorId = authors[1].Id, CategoryId = categories[3].Id, PublishedDate = new DateTime(1811, 10, 30), IsAvailable = false },\n                new Book { Title = \"The Adventures of Tom Sawyer\", Isbn = \"978-0486400778\", Price = 8.99m, AuthorId = authors[2].Id, CategoryId = categories[4].Id, PublishedDate = new DateTime(1876, 6, 1), IsAvailable = true },\n                new Book { Title = \"Mrs Dalloway\", Isbn = \"978-0156628709\", Price = 14.99m, AuthorId = authors[3].Id, CategoryId = categories[0].Id, PublishedDate = new DateTime(1925, 5, 14), IsAvailable = true },\n                new Book { Title = \"The Old Man and the Sea\", Isbn = \"978-0684801223\", Price = 13.99m, AuthorId = authors[4].Id, CategoryId = categories[0].Id, PublishedDate = new DateTime(1952, 9, 1), IsAvailable = true },\n                new Book { Title = \"A Farewell to Arms\", Isbn = \"978-0684801469\", Price = 15.99m, AuthorId = authors[4].Id, CategoryId = categories[0].Id, PublishedDate = new DateTime(1929, 9, 27), IsAvailable = false }\n            };\n\n            foreach (var book in books)\n            {\n                bookRepo.Add(book);\n            }\n\n            Console.WriteLine($\"   ✓ Added {authors.Length} authors\");\n            Console.WriteLine($\"   ✓ Added {categories.Length} categories\");\n            Console.WriteLine($\"   ✓ Added {books.Length} books\\n\");\n        }\n\n        static void DemoBasicCrud(DbContext context)\n        {\n            PrintSection(\"1. Basic CRUD Operations\");\n\n            var bookRepo = new Repository<Book>(context);\n\n            // CREATE\n            Console.WriteLine(\"   📝 Creating a new book...\");\n            var newBook = new Book\n            {\n                Title = \"Test Book\",\n                Isbn = \"978-1234567890\",\n                Price = 19.99m,\n                AuthorId = 1,\n                CategoryId = 1,\n                PublishedDate = DateTime.Now,\n                IsAvailable = true\n            };\n            bookRepo.Add(newBook);\n            Console.WriteLine($\"      Created book with ID: {newBook.Id}\");\n\n            // READ\n            Console.WriteLine(\"\\n   📖 Reading book by ID...\");\n            var fetchedBook = bookRepo.GetById(newBook.Id);\n            Console.WriteLine($\"      Found: {fetchedBook.Title} (${fetchedBook.Price})\");\n\n            // UPDATE\n            Console.WriteLine(\"\\n   ✏️  Updating book price...\");\n            fetchedBook.Price = 24.99m;\n            bookRepo.Update(fetchedBook);\n            var updatedBook = bookRepo.GetById(fetchedBook.Id);\n            Console.WriteLine($\"      New price: ${updatedBook.Price}\");\n\n            // DELETE\n            Console.WriteLine(\"\\n   🗑️  Deleting test",
                    "images": [],
                    "tokenCount": 4964,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue with the EagerLoader.cs file and then continue with the rest of the tutorial. Let me continue from where I left off.",
                        "signature": "ErsCCkYIChgCKkAuW+KxlARKr5hh02OtYvB6ylFL0dLJTH5xNfB4nlp+AXYwlNSWjgVIIgexsPDlYLtcx6CxrP4eUIhLpDODikSUEgzTwksDqqRjWKzeGN0aDOEG8pdQTG0C9Q8ClyIwM2d72gePEHpSa6U4cJky4VaRWQbcLgjbJnpBj/B67wTvbLgfmcCcfboeHgiytvY/KqIB4WL7N1ujedei0Sgw1kQm4IT43madAziuGM3RnLTr6WtvEGO9OThbZJrmltKh1Q8ppdloTsYkOGIp/thq4XpR3ZyNmHAi//C3wNqmqratnAXcTf1es1hWGLwHmK8UhH+4SJb5QwTFD7NUd1bWcF+I4PPQndvJ02a94PaUnJnYoVqXdbWO+NxryIY2il5GZ4RbFFB2hY4fmMTn9bJhSZZgWqSPGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 12,
            "parentIdx": 11,
            "childrenIdxs": [
                13
            ],
            "createdAt": "2025-12-04T18:21:23.195Z",
            "updatedAt": "2025-12-04T18:22:02.713Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `Program.cs` Demo Application:\n\n### Program.cs (Complete Demo - Continued)\n\n```csharp\n        static void DemoBasicCrud(DbContext context)\n        {\n            PrintSection(\"1. Basic CRUD Operations\");\n\n            var bookRepo = new Repository<Book>(context);\n\n            // CREATE\n            Console.WriteLine(\"   📝 Creating a new book...\");\n            var newBook = new Book\n            {\n                Title = \"Test Book\",\n                Isbn = \"978-1234567890\",\n                Price = 19.99m,\n                AuthorId = 1,\n                CategoryId = 1,\n                PublishedDate = DateTime.Now,\n                IsAvailable = true\n            };\n            bookRepo.Add(newBook);\n            Console.WriteLine($\"      Created book with ID: {newBook.Id}\");\n\n            // READ\n            Console.WriteLine(\"\\n   📖 Reading book by ID...\");\n            var fetchedBook = bookRepo.GetById(newBook.Id);\n            Console.WriteLine($\"      Found: {fetchedBook.Title} (${fetchedBook.Price})\");\n\n            // UPDATE\n            Console.WriteLine(\"\\n   ✏️  Updating book price...\");\n            fetchedBook.Price = 24.99m;\n            bookRepo.Update(fetchedBook);\n            var updatedBook = bookRepo.GetById(fetchedBook.Id);\n            Console.WriteLine($\"      New price: ${updatedBook.Price}\");\n\n            // DELETE\n            Console.WriteLine(\"\\n   🗑️  Deleting test book...\");\n            bookRepo.Delete(newBook.Id);\n            var deletedBook = bookRepo.GetById(newBook.Id);\n            Console.WriteLine($\"      Book exists after delete: {deletedBook != null}\");\n\n            // READ ALL\n            Console.WriteLine(\"\\n   📚 Reading all books...\");\n            var allBooks = bookRepo.GetAll().ToList();\n            Console.WriteLine($\"      Total books in database: {allBooks.Count}\");\n            foreach (var book in allBooks.Take(3))\n            {\n                Console.WriteLine($\"      - {book.Title} (${book.Price})\");\n            }\n            if (allBooks.Count > 3)\n            {\n                Console.WriteLine($\"      ... and {allBooks.Count - 3} more\");\n            }\n        }\n\n        static void DemoQueryBuilder(DbContext context)\n        {\n            PrintSection(\"2. SQL Query Builder (Builder Pattern)\");\n\n            // Simple SELECT\n            Console.WriteLine(\"   🔨 Building queries with fluent API:\\n\");\n\n            var query1 = new SqlQueryBuilder()\n                .Select(\"Title\", \"Price\", \"ISBN\")\n                .From(\"Books\")\n                .WhereGreaterThan(\"Price\", 10)\n                .OrderBy(\"Price\")\n                .Top(5);\n\n            Console.WriteLine(\"   Query 1 - Select with conditions:\");\n            Console.WriteLine($\"   SQL: {query1.BuildSelect()}\\n\");\n\n            // JOIN query\n            var query2 = new SqlQueryBuilder()\n                .Select(\"b.Title\", \"a.FullName AS AuthorName\", \"c.Name AS Category\")\n                .From(\"Books\", \"b\")\n                .InnerJoin(\"Authors\", \"[b].[AuthorId] = [a].[Id]\", \"a\")\n                .InnerJoin(\"Categories\", \"[b].[CategoryId] = [c].[Id]\", \"c\")\n                .Where(\"b.IsAvailable\", 1)\n                .OrderBy(\"b.Title\");\n\n            Console.WriteLine(\"   Query 2 - JOIN query:\");\n            Console.WriteLine($\"   SQL: {query2.BuildSelect()}\\n\");\n\n            // Pagination query\n            var query3 = new SqlQueryBuilder()\n                .SelectAll()\n                .From(\"Books\")\n                .OrderBy(\"PublishedDate\", descending: true)\n                .Page(pageNumber: 2, pageSize: 5);\n\n            Console.WriteLine(\"   Query 3 - Pagination (Page 2, 5 items):\");\n            Console.WriteLine($\"   SQL: {query3.BuildSelect()}\\n\");\n\n            // Aggregation query\n            var query4 = new SqlQueryBuilder()\n                .Select(\"AuthorId\")\n                .SelectCount(\"*\")\n                .SelectAvg(\"Price\")\n                .From(\"Books\")\n                .GroupBy(\"AuthorId\")\n                .Having(\"COUNT(*) > 1\");\n\n            Console.WriteLine(\"   Query 4 - Aggregation:\");\n            Console.WriteLine($\"   SQL: {query4.BuildSelect()}\\n\");\n\n            // Execute a query and show results\n            Console.WriteLine(\"   📊 Executing query and fetching results:\");\n            var execQuery = new SqlQueryBuilder()\n                .Select(\"Title\", \"Price\")\n                .From(\"Books\")\n                .WhereLessThan(\"Price\", 15)\n                .OrderBy(\"Price\");\n\n            var (sql, parameters) = execQuery.Build();\n            \n            using var command = context.CreateCommand();\n            command.CommandText = sql;\n            foreach (var param in parameters)\n            {\n                var dbParam = command.CreateParameter();\n                dbParam.ParameterName = param.Name;\n                dbParam.Value = param.Value ?? DBNull.Value;\n                command.Parameters.Add(dbParam);\n            }\n\n            using var reader = command.ExecuteReader();\n            Console.WriteLine(\"   Books under $15:\");\n            while (reader.Read())\n            {\n                Console.WriteLine($\"      - {reader[\"Title\"]}: ${reader[\"Price\"]}\");\n            }\n        }\n\n        static void DemoExpressionQueries(DbContext context)\n        {\n            PrintSection(\"3. LINQ-Style Expression Queries (Visitor Pattern)\");\n\n            var bookRepo = new Repository<Book>(context);\n            var authorRepo = new Repository<Author>(context);\n\n            // Simple equality\n            Console.WriteLine(\"   🔍 Finding books by exact title:\");\n            var book1984 = bookRepo.FirstOrDefault(b => b.Title == \"1984\");\n            Console.WriteLine($\"      Found: {book1984?.Title} by Author ID {book1984?.AuthorId}\\n\");\n\n            // String Contains (LIKE)\n            Console.WriteLine(\"   🔍 Finding books containing 'the' in title:\");\n            var booksWithThe = bookRepo.Find(b => b.Title.Contains(\"the\")).ToList();\n            foreach (var book in booksWithThe)\n            {\n                Console.WriteLine($\"      - {book.Title}\");\n            }\n\n            // Price comparisons\n            Console.WriteLine(\"\\n   🔍 Finding books between $10 and $15:\");\n            var midPriceBooks = bookRepo.Find(b => b.Price >= 10 && b.Price <= 15).ToList();\n            foreach (var book in midPriceBooks)\n            {\n                Console.WriteLine($\"      - {book.Title}: ${book.Price}\");\n            }\n\n            // Boolean property\n            Console.WriteLine(\"\\n   🔍 Finding available books:\");\n            var availableBooks = bookRepo.Find(b => b.IsAvailable).ToList();\n            Console.WriteLine($\"      {availableBooks.Count} books are available\");\n\n            // NOT available\n            Console.WriteLine(\"\\n   🔍 Finding unavailable books:\");\n            var unavailableBooks = bookRepo.Find(b => !b.IsAvailable).ToList();\n            foreach (var book in unavailableBooks)\n            {\n                Console.WriteLine($\"      - {book.Title}\");\n            }\n\n            // IN clause with list\n            Console.WriteLine(\"\\n   🔍 Finding books by specific author IDs (IN clause):\");\n            var authorIds = new List<int> { 1, 2 };\n            var booksByAuthors = bookRepo.Find(b => authorIds.Contains(b.AuthorId)).ToList();\n            foreach (var book in booksByAuthors)\n            {\n                Console.WriteLine($\"      - {book.Title} (Author ID: {book.AuthorId})\");\n            }\n\n            // String StartsWith\n            Console.WriteLine(\"\\n   🔍 Finding authors whose name starts with 'J':\");\n            var authorsJ = authorRepo.Find(a => a.Name.StartsWith(\"J\")).ToList();\n            foreach (var author in authorsJ)\n            {\n                Console.WriteLine($\"      - {author.Name}\");\n            }\n\n            // Complex conditions\n            Console.WriteLine(\"\\n   🔍 Complex query - Available fiction books under $15:\");\n            var complexQuery = bookRepo.Find(b => \n                b.IsAvailable && \n                b.Price < 15 && \n                b.CategoryId == 1).ToList();\n            Console.WriteLine($\"      Found {complexQuery.Count} matching books\");\n\n            // Count and Any\n            Console.WriteLine(\"\\n   📊 Aggregations:\");\n            var totalBooks = bookRepo.Count();\n            var availableCount = bookRepo.Count(b => b.IsAvailable);\n            var hasExpensiveBooks = bookRepo.Any(b => b.Price > 20);\n            Console.WriteLine($\"      Total books: {totalBooks}\");\n            Console.WriteLine($\"      Available books: {availableCount}\");\n            Console.WriteLine($\"      Has books over $20: {hasExpensiveBooks}\");\n        }\n\n        static void DemoUnitOfWork(DbContext context)\n        {\n            PrintSection(\"4. Unit of Work Pattern\");\n\n            Console.WriteLine(\"   🔄 Demonstrating coordinated operations:\\n\");\n\n            using var uow = new UnitOfWork(context);\n\n            var authorRepo = uow.Repository<Author>();\n            var bookRepo = uow.Repository<Book>();\n            var categoryRepo = uow.Repository<Category>();\n\n            // Add new author\n            Console.WriteLine(\"   Adding new author...\");\n            var newAuthor = new Author\n            {\n                Name = \"Test Author\",\n                Email = \"test@example.com\",\n                BirthDate = new DateTime(1980, 1, 1)\n            };\n            authorRepo.Add(newAuthor);\n            Console.WriteLine($\"      Author '{newAuthor.Name}' added (pending)\");\n\n            // Add new category\n            Console.WriteLine(\"   Adding new category...\");\n            var newCategory = new Category\n            {\n                Name = \"Test Category\",\n                Description = \"A test category\"\n            };\n            categoryRepo.Add(newCategory);\n            Console.WriteLine($\"      Category '{newCategory.Name}' added (pending)\");\n\n            // Save to get IDs\n            Console.WriteLine(\"\\n   💾 Saving changes (first batch)...\");\n            var saved1 = uow.SaveChanges();\n            Console.WriteLine($\"      Saved {saved1} entities\");\n            Console.WriteLine($\"      Author ID: {newAuthor.Id}\");\n            Console.WriteLine($\"      Category ID: {newCategory.Id}\");\n\n            // Add books for the new author\n            Console.WriteLine(\"\\n   Adding books for new author...\");\n            var book1 = new Book\n            {\n                Title = \"Test Book 1\",\n                Isbn = \"111-1111111111\",\n                Price = 29.99m,\n                AuthorId = newAuthor.Id,\n                CategoryId = newCategory.Id,\n                PublishedDate = DateTime.Now,\n                IsAvailable = true\n            };\n            var book2 = new Book\n            {\n                Title = \"Test Book 2\",\n                Isbn = \"222-2222222222\",\n                Price = 34.99m,\n                AuthorId = newAuthor.Id,\n                CategoryId = newCategory.Id,\n                PublishedDate = DateTime.Now,\n                IsAvailable = true\n            };\n\n            bookRepo.Add(book1);\n            bookRepo.Add(book2);\n            Console.WriteLine($\"      Added 2 books (pending)\");\n\n            // Save all changes\n            Console.WriteLine(\"\\n   💾 Saving changes (second batch)...\");\n            var saved2 = uow.SaveChanges();\n            Console.WriteLine($\"      Saved {saved2} entities\");\n\n            // Verify\n            Console.WriteLine(\"\\n   ✅ Verification:\");\n            var authorBooks = bookRepo.Find(b => b.AuthorId == newAuthor.Id).ToList();\n            Console.WriteLine($\"      Books by '{newAuthor.Name}': {authorBooks.Count}\");\n\n            // Cleanup\n            Console.WriteLine(\"\\n   🧹 Cleaning up test data...\");\n            foreach (var book in authorBooks)\n            {\n                bookRepo.Delete(book);\n            }\n            uow.SaveChanges();\n            \n            authorRepo.Delete(newAuthor);\n            categoryRepo.Delete(newCategory);\n            uow.SaveChanges();\n            Console.WriteLine(\"      Test data removed\");\n        }\n\n        static void DemoChangeTracking(DbContext context)\n        {\n            PrintSection(\"5. Change Tracking (Observer Pattern)\");\n\n            using var uow = new UnitOfWork(context);\n            var bookRepo = uow.Repository<Book>();\n\n            // Fetch and track an entity\n            Console.WriteLine(\"   👁️ Fetching and tracking an entity:\\n\");\n            var book = bookRepo.GetById(1);\n            Console.WriteLine($\"      Book: {book.Title}\");\n            Console.WriteLine($\"      Initial State: {book.State}\");\n            Console.WriteLine($\"      Initial Price: ${book.Price}\");\n\n            // Modify the entity\n            Console.WriteLine(\"\\n   ✏️  Modifying entity...\");\n            var originalPrice = book.Price;\n            book.Price = 99.99m;\n            Console.WriteLine($\"      State after modification: {book.State}\");\n\n            // Check change tracker\n            var entry = uow.ChangeTracker.GetEntry(book);\n            var modifiedProps = entry.GetModifiedProperties().ToList();\n            Console.WriteLine($\"      Modified properties: {string.Join(\", \", modifiedProps)}\");\n\n            // Show original vs current values\n            Console.WriteLine(\"\\n   📋 Original vs Current values:\");\n            Console.WriteLine($\"      Original Price: {entry.OriginalValues[\"Price\"]}\");\n            Console.WriteLine($\"      Current Price: {entry.CurrentValues[\"Price\"]}\");\n\n            // Save and verify state changes\n            Console.WriteLine(\"\\n   💾 Saving changes...\");\n            uow.SaveChanges();\n            Console.WriteLine($\"      State after save: {book.State}\");\n\n            // Restore original value\n            Console.WriteLine(\"\\n   🔄 Restoring original price...\");\n            book.Price = originalPrice;\n            uow.SaveChanges();\n            Console.WriteLine($\"      Price restored to: ${book.Price}\");\n        }\n\n        static void DemoEagerLoading(DbContext context)\n        {\n            PrintSection(\"6. Eager Loading\");\n\n            Console.WriteLine(\"   📦 Loading books with related entities:\\n\");\n\n            var eagerLoader = new EagerLoader<Book>(context)\n                .Include<Author>(b => b.Author, \"AuthorId\", \"Id\")\n                .Include<Category>(b => b.Category, \"CategoryId\", \"Id\")\n                .Where(b => b.IsAvailable)\n                .OrderBy(b => b.Title);\n\n            var booksWithRelated = eagerLoader.ToList();\n\n            Console.WriteLine($\"   Loaded {booksWithRelated.Count} books with authors and categories:\\n\");\n\n            foreach (var book in booksWithRelated.Take(5))\n            {\n                Console.WriteLine($\"   📖 {book.Title}\");\n                Console.WriteLine($\"      Author: {book.Author?.Name ?? \"N/A\"}\");\n                Console.WriteLine($\"      Category: {book.Category?.Name ?? \"N/A\"}\");\n                Console.WriteLine($\"      Price: ${book.Price}\");\n                Console.WriteLine();\n            }\n\n            // Demonstrate loading author with their books\n            Console.WriteLine(\"   📦 Loading authors with their books:\\n\");\n\n            var authorLoader = new EagerLoader<Author>(context)\n                .IncludeCollection<Book>(a => a.Books, \"AuthorId\")\n                .Where(a => a.Name.Contains(\"Hemingway\"));\n\n            var authorsWithBooks = authorLoader.ToList();\n\n            foreach (var author in authorsWithBooks)\n            {\n                Console.WriteLine($\"   👤 {author.Name}\");\n                Console.WriteLine($\"      Email: {author.Email}\");\n                Console.WriteLine($\"      Books: {author.Books.Count}\");\n                foreach (var book in author.Books)\n                {\n                    Console.WriteLine($\"         - {book.Title} (${book.Price})\");\n                }\n            }\n        }\n\n        static void DemoBulkOperations(DbContext context)\n        {\n            PrintSection(\"7. Bulk Operations (Performance)\");\n\n            var bulkOps = new BulkOperations<Book>(context);\n            var bookRepo = new Repository<Book>(context);\n\n            // Bulk Insert\n            Console.WriteLine(\"   ⚡ Bulk inserting 100 books...\\n\");\n\n            var bulkBooks = Enumerable.Range(1, 100).Select(i => new Book\n            {\n                Title = $\"Bulk Book {i}\",\n                Isbn = $\"BULK-{i:D10}\",\n                Price = 9.99m + (i % 10),\n                AuthorId = ((i - 1) % 5) + 1,\n                CategoryId = ((i - 1) % 5) + 1,\n                PublishedDate = DateTime.Now.AddDays(-i),\n                IsAvailable = i % 2 == 0\n            }).ToList();\n\n            var startTime = DateTime.Now;\n            bulkOps.BulkInsert(bulkBooks, batchSize: 50);\n            var elapsed = DateTime.Now - startTime;\n\n            Console.WriteLine($\"      Inserted 100 books in {elapsed.TotalMilliseconds:F2}ms\");\n\n            var totalCount = bookRepo.Count();\n            Console.WriteLine($\"      Total books now: {totalCount}\");\n\n            // Bulk Update\n            Console.WriteLine(\"\\n   ⚡ Bulk updating prices...\");\n            var updateResult = bulkOps.BulkUpdateWhere(\n                new Dictionary<string, object> { { \"Price\", 5.99m } },\n                \"Title LIKE @pattern\",\n                (\"@pattern\", \"Bulk Book%\"));\n            Console.WriteLine($\"      Updated {updateResult} books\");\n\n            // Bulk Delete\n            Console.WriteLine(\"\\n   ⚡ Bulk deleting test books...\");\n            var deleteResult = bulkOps.BulkDeleteWhere(\n                \"Title LIKE @pattern\",\n                (\"@pattern\", \"Bulk Book%\"));\n            Console.WriteLine($\"      Deleted {deleteResult} books\");\n\n            var finalCount = bookRepo.Count();\n            Console.WriteLine($\"      Final book count: {finalCount}\");\n        }\n\n        static void DemoTransactions(DbContext context)\n        {\n            PrintSection(\"8. Transaction Management\");\n\n            var bookRepo = new Repository<Book>(context);\n            var initialCount = bookRepo.Count();\n\n            // Successful transaction\n            Console.WriteLine(\"   ✅ Demonstrating successful transaction:\\n\");\n\n            context.BeginTransaction();\n            try\n            {\n                var book = new Book\n                {\n                    Title = \"Transaction Test\",\n                    Isbn = \"TX-123456\",\n                    Price = 19.99m,\n                    AuthorId = 1,\n                    CategoryId = 1,\n                    PublishedDate = DateTime.Now,\n                    IsAvailable = true\n                };\n                bookRepo.Add(book);\n                Console.WriteLine($\"      Added book (in transaction): {book.Title}\");\n\n                context.Commit();\n                Console.WriteLine(\"      Transaction committed successfully\");\n\n                // Cleanup\n                bookRepo.Delete(book.Id);\n            }\n            catch\n            {\n                context.Rollback();\n                throw;\n            }\n\n            // Failed transaction (rollback)\n            Console.WriteLine(\"\\n   ❌ Demonstrating transaction rollback:\\n\");\n\n            var countBeforeRollback = bookRepo.Count();\n            Console.WriteLine($\"      Books before transaction: {countBeforeRollback}\");\n\n            context.BeginTransaction();\n            try\n            {\n                var book1 = new Book\n                {\n                    Title = \"Will Be Rolled Back 1\",\n                    Isbn = \"RB-1\",\n                    Price = 10m,\n                    AuthorId = 1,\n                    CategoryId = 1,\n                    PublishedDate = DateTime.Now,\n                    IsAvailable = true\n                };\n                bookRepo.Add(book1);\n                Console.WriteLine($\"      Added: {book1.Title}\");\n\n                var book2 = new Book\n                {\n                    Title = \"Will Be Rolled Back 2\",\n                    Isbn = \"RB-2\",\n                    Price = 20m,\n                    AuthorId = 1,\n                    CategoryId = 1,\n                    PublishedDate = DateTime.Now,\n                    IsAvailable = true\n                };\n                bookRepo.Add(book2);\n                Console.WriteLine($\"      Added: {book2.Title}\");\n\n                // Simulate an error\n                throw new InvalidOperationException(\"Simulated error - rolling back!\");\n            }\n            catch (InvalidOperationException ex)\n            {\n                Console.WriteLine($\"      Error occurred: {ex.Message}\");\n                context.Rollback();\n                Console.WriteLine(\"      Transaction rolled back\");\n            }\n\n            var countAfterRollback = bookRepo.Count();\n            Console.WriteLine($\"      Books after rollback: {countAfterRollback}\");\n            Console.WriteLine($\"      Count unchanged: {countBeforeRollback == countAfterRollback}\");\n        }\n\n        static void DemoCaching(DbContext context)\n        {\n            PrintSection(\"9. Query Caching\");\n\n            var cache = new QueryCache(defaultExpiration: TimeSpan.FromMinutes(5));\n            var bookRepo = new Repository<Book>(context);\n\n            Console.WriteLine(\"   💾 Demonstrating query result caching:\\n\");\n\n            // First query - cache miss\n            Console.WriteLine(\"   First query (cache miss):\");\n            var startTime1 = DateTime.Now;\n            \n            var query = new SqlQueryBuilder()\n                .SelectAll()\n                .From(\"Books\")\n                .Where(\"IsAvailable\", 1);\n            var (sql, parameters) = query.Build();\n\n            var result1 = cache.GetOrSet(sql, parameters, () =>\n            {\n                System.Threading.Thread.Sleep(100); // Simulate slow query\n                return bookRepo.Find(b => b.IsAvailable).ToList();\n            });\n            \n            var elapsed1 = DateTime.Now - startTime1;\n            Console.WriteLine($\"      Retrieved {result1.Count} books in {elapsed1.TotalMilliseconds:F2}ms\");\n            Console.WriteLine($\"      Cache entries: {cache.Count}\");\n\n            // Second query - cache hit\n            Console.WriteLine(\"\\n   Second query (cache hit):\");\n            var startTime2 = DateTime.Now;\n            \n            var result2 = cache.GetOrSet",
                    "images": [],
                    "tokenCount": 4555,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue the demo application. I'll continue from where I left off in the Program.cs file with the DemoBasicCrud method and then continue with the remaining demo methods.",
                        "signature": "EugCCkYIChgCKkBeGQZuIfuHXBlhj+8DRvBtaBmXNRqE2+DV6uFqWvUcva8maSCJSn89Qvmhc16O+8RQH+OiRKkMzJVjVf0AeyZlEgwJ1mncSP6WHdR/3AwaDHmh0Rx/oSQ4YtVF9iIwP3FbjL8HSQCN87RTlzYAf/kCf4QZrIOwYgYbht45terlsac/18PBn4Lgmcc1myPkKs8ByMrjb6IMsLGiRyyYzDk/304U9jc4aGXQjfi26tSuHTgxcvPb0G0nDIYglGfgblHeDFxB3dtkJzr9pRn43ZcGWEMeutanResFneTVRW9a+Wa4l4TQ4psReDlA++ECavYKOSEO/rE5KPl3IIAmB/D1rCKt/HmtOnHzLjwqLTFzhCCgBRsoG6GWoL7LkM3oA88vuT2fqwT+SUTrcUYiejDrq8eEY89x5eJobqojOxdMdgQEO7bL/yKj5jod745lyejRSrUvBbFL+i9q2Md19uHYGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0,
            "nodeIdx": 13,
            "parentIdx": 12,
            "childrenIdxs": [
                14
            ],
            "createdAt": "2025-12-04T18:23:08.075Z",
            "updatedAt": "2025-12-04T18:26:55.040Z"
        },
        {
            "prompt": {
                "text": "continue",
                "images": [],
                "tokenCount": 1,
                "enableThinking": true
            },
            "responses": [
                {
                    "text": "# Building a Simple ORM in C# (Continued)\n\nContinuing from the `Program.cs` Demo Application - Caching section:\n\n### Program.cs (Complete Demo - Final Part)\n\n```csharp\n        static void DemoCaching(DbContext context)\n        {\n            PrintSection(\"9. Query Caching\");\n\n            var cache = new QueryCache(defaultExpiration: TimeSpan.FromMinutes(5));\n            var bookRepo = new Repository<Book>(context);\n\n            Console.WriteLine(\"   💾 Demonstrating query result caching:\\n\");\n\n            // First query - cache miss\n            Console.WriteLine(\"   First query (cache miss):\");\n            var startTime1 = DateTime.Now;\n            \n            var query = new SqlQueryBuilder()\n                .SelectAll()\n                .From(\"Books\")\n                .Where(\"IsAvailable\", 1);\n            var (sql, parameters) = query.Build();\n\n            var result1 = cache.GetOrSet(sql, parameters, () =>\n            {\n                System.Threading.Thread.Sleep(100); // Simulate slow query\n                return bookRepo.Find(b => b.IsAvailable).ToList();\n            });\n            \n            var elapsed1 = DateTime.Now - startTime1;\n            Console.WriteLine($\"      Retrieved {result1.Count} books in {elapsed1.TotalMilliseconds:F2}ms\");\n            Console.WriteLine($\"      Cache entries: {cache.Count}\");\n\n            // Second query - cache hit\n            Console.WriteLine(\"\\n   Second query (cache hit):\");\n            var startTime2 = DateTime.Now;\n            \n            var result2 = cache.GetOrSet(sql, parameters, () =>\n            {\n                System.Threading.Thread.Sleep(100); // This won't execute - cached!\n                return bookRepo.Find(b => b.IsAvailable).ToList();\n            });\n            \n            var elapsed2 = DateTime.Now - startTime2;\n            Console.WriteLine($\"      Retrieved {result2.Count} books in {elapsed2.TotalMilliseconds:F2}ms\");\n            Console.WriteLine($\"      Speed improvement: {(elapsed1.TotalMilliseconds / elapsed2.TotalMilliseconds):F1}x faster\");\n\n            // Cache invalidation\n            Console.WriteLine(\"\\n   🔄 Cache invalidation:\");\n            Console.WriteLine($\"      Cache entries before: {cache.Count}\");\n            cache.InvalidateTable(\"Books\");\n            Console.WriteLine($\"      Cache entries after invalidation: {cache.Count}\");\n\n            // Different query parameters = different cache entry\n            Console.WriteLine(\"\\n   📊 Different parameters create separate cache entries:\");\n            \n            var query2 = new SqlQueryBuilder()\n                .SelectAll()\n                .From(\"Books\")\n                .Where(\"IsAvailable\", 0);\n            var (sql2, params2) = query2.Build();\n\n            cache.GetOrSet(sql, parameters, () => bookRepo.Find(b => b.IsAvailable).ToList());\n            cache.GetOrSet(sql2, params2, () => bookRepo.Find(b => !b.IsAvailable).ToList());\n            \n            Console.WriteLine($\"      Cache entries with 2 different queries: {cache.Count}\");\n\n            // Cleanup\n            cache.Clear();\n        }\n\n        static void PrintSection(string title)\n        {\n            Console.WriteLine($\"\\n{'═'.ToString().PadRight(60, '═')}\");\n            Console.WriteLine($\"  {title}\");\n            Console.WriteLine($\"{'═'.ToString().PadRight(60, '═')}\\n\");\n        }\n    }\n}\n```\n\n---\n\n## 16. Summary: Design Patterns Reference\n\nHere's a comprehensive reference of all the design patterns implemented in our ORM:\n\n### DesignPatternsSummary.md\n\n```markdown\n# MiniORM Design Patterns Reference\n\n## 1. Creational Patterns\n\n### Singleton Pattern\n**Location:** `DbContext.cs`\n**Purpose:** Ensure only one database context instance exists (optional usage)\n```csharp\npublic static DbContext GetInstance(IDbConnectionFactory connectionFactory)\n{\n    if (_instance == null)\n    {\n        lock (_lock)\n        {\n            if (_instance == null)\n            {\n                _instance = new DbContext(connectionFactory);\n            }\n        }\n    }\n    return _instance;\n}\n```\n\n### Factory Pattern\n**Location:** `IDbConnectionFactory.cs`, `SqlConnectionFactory.cs`\n**Purpose:** Encapsulate database connection creation\n```csharp\npublic interface IDbConnectionFactory\n{\n    IDbConnection CreateConnection();\n    IDbConnection CreateOpenConnection();\n}\n```\n\n### Builder Pattern\n**Location:** `SqlQueryBuilder.cs`, `InsertQueryBuilder.cs`, etc.\n**Purpose:** Construct complex SQL queries step-by-step\n```csharp\nvar query = new SqlQueryBuilder()\n    .Select(\"Id\", \"Name\")\n    .From(\"Users\")\n    .Where(\"IsActive\", true)\n    .OrderBy(\"Name\")\n    .Build();\n```\n\n## 2. Structural Patterns\n\n### Repository Pattern\n**Location:** `IRepository.cs`, `Repository.cs`\n**Purpose:** Abstract data access behind a collection-like interface\n```csharp\npublic interface IRepository<TEntity, TKey>\n{\n    TEntity GetById(TKey id);\n    IEnumerable<TEntity> GetAll();\n    IEnumerable<TEntity> Find(Expression<Func<TEntity, bool>> predicate);\n    TEntity Add(TEntity entity);\n    void Update(TEntity entity);\n    void Delete(TEntity entity);\n}\n```\n\n### Facade Pattern\n**Location:** `DbContext.cs`\n**Purpose:** Provide simplified interface to complex subsystem\n```csharp\npublic class DbContext\n{\n    public IDbConnection GetConnection() { ... }\n    public IDbTransaction BeginTransaction() { ... }\n    public int ExecuteNonQuery(string sql, params ...) { ... }\n}\n```\n\n### Flyweight Pattern\n**Location:** `EntityMapper.cs`, `EntityMetadata.cs`\n**Purpose:** Share entity metadata across multiple operations\n```csharp\nprivate static readonly ConcurrentDictionary<Type, EntityMetadata> _metadataCache;\n\npublic static EntityMetadata GetMetadata<TEntity>()\n{\n    return _metadataCache.GetOrAdd(typeof(TEntity), t => new EntityMetadata(t));\n}\n```\n\n### Proxy Pattern (Virtual Proxy)\n**Location:** `LazyLoader.cs`\n**Purpose:** Delay loading of related entities until accessed\n```csharp\npublic TRelated LoadReference<TEntity, TRelated>(\n    TEntity entity,\n    string navigationPropertyName,\n    string foreignKeyPropertyName)\n{\n    // Load only when first accessed\n}\n```\n\n## 3. Behavioral Patterns\n\n### Observer Pattern\n**Location:** `EntityBase.cs`, `ChangeTracker.cs`\n**Purpose:** Track property changes automatically\n```csharp\npublic abstract class EntityBase : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n    \n    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)\n    {\n        if (EqualityComparer<T>.Default.Equals(field, value)) return false;\n        field = value;\n        OnPropertyChanged(propertyName);\n        return true;\n    }\n}\n```\n\n### Visitor Pattern\n**Location:** `ExpressionParser.cs`\n**Purpose:** Traverse expression trees and convert to SQL\n```csharp\nprivate string Visit(Expression expression)\n{\n    return expression switch\n    {\n        BinaryExpression binary => VisitBinary(binary),\n        MemberExpression member => VisitMember(member),\n        ConstantExpression constant => VisitConstant(constant),\n        MethodCallExpression method => VisitMethodCall(method),\n        _ => throw new NotSupportedException()\n    };\n}\n```\n\n### Strategy Pattern\n**Location:** `EagerLoader.cs`, `LazyLoader.cs`\n**Purpose:** Different loading strategies for related entities\n```csharp\n// Eager loading strategy\nvar loader = new EagerLoader<Book>(context)\n    .Include<Author>(b => b.Author, \"AuthorId\");\n\n// Lazy loading strategy  \nvar lazyLoader = new LazyLoader(context);\nvar author = lazyLoader.LoadReference<Book, Author>(book, \"Author\", \"AuthorId\");\n```\n\n### Template Method Pattern\n**Location:** `EntityBase.cs`\n**Purpose:** Define skeleton for entity behavior\n```csharp\npublic abstract class EntityBase\n{\n    // Template for property change notification\n    protected bool SetProperty<T>(ref T field, T value, ...)\n    {\n        // Common logic for all entities\n    }\n}\n```\n\n### Interpreter Pattern\n**Location:** `ExpressionParser.cs`\n**Purpose:** Interpret C# expressions into SQL\n```csharp\n// Interprets: b => b.Price > 100 && b.IsAvailable\n// Into: [Price] > @p0 AND [IsAvailable] = @p1\n```\n\n## 4. Enterprise Patterns\n\n### Unit of Work Pattern\n**Location:** `IUnitOfWork.cs`, `UnitOfWork.cs`\n**Purpose:** Coordinate multiple operations in a single transaction\n```csharp\npublic interface IUnitOfWork : IDisposable\n{\n    IRepository<TEntity> Repository<TEntity>();\n    int SaveChanges();\n    void BeginTransaction();\n    void Commit();\n    void Rollback();\n}\n```\n\n### Identity Map Pattern\n**Location:** `ChangeTracker.cs`\n**Purpose:** Ensure each entity is tracked only once\n```csharp\nprivate readonly Dictionary<object, EntityEntry> _trackedEntities;\n\npublic EntityEntry Track<TEntity>(TEntity entity, EntityState state)\n{\n    if (_trackedEntities.TryGetValue(entity, out var existing))\n    {\n        existing.State = state;\n        return existing;\n    }\n    // Add new tracking entry\n}\n```\n\n### Metadata Mapping Pattern\n**Location:** `Attributes/*.cs`, `EntityMetadata.cs`\n**Purpose:** Map classes to database tables using attributes\n```csharp\n[Table(\"Users\")]\npublic class User\n{\n    [PrimaryKey(AutoGenerate = true)]\n    public int Id { get; set; }\n    \n    [Column(\"UserName\", MaxLength = 50)]\n    public string Name { get; set; }\n}\n```\n\n## 5. Other Patterns\n\n### Object Pool Pattern\n**Location:** `ConnectionPool.cs`\n**Purpose:** Reuse expensive database connections\n```csharp\npublic IDbConnection GetConnection()\n{\n    _semaphore.Wait();\n    if (_availableConnections.TryTake(out var connection))\n        return connection;\n    return CreateNewConnection();\n}\n```\n\n### Cache-Aside Pattern\n**Location:** `QueryCache.cs`\n**Purpose:** Cache query results for repeated queries\n```csharp\npublic TResult GetOrSet<TResult>(\n    string sql,\n    IReadOnlyList<QueryParameter> parameters,\n    Func<TResult> queryExecutor)\n{\n    var key = GenerateCacheKey(sql, parameters);\n    if (_cache.TryGetValue(key, out var cached))\n        return (TResult)cached.Value;\n    \n    var result = queryExecutor();\n    _cache.TryAdd(key, new CacheEntry { Value = result });\n    return result;\n}\n```\n```\n\n---\n\n## 17. Complete Project Structure\n\nHere's the final project structure for reference:\n\n```\nMiniORM/\n│\n├── MiniORM.Core/\n│   │\n│   ├── Attributes/\n│   │   ├── TableAttribute.cs\n│   │   ├── ColumnAttribute.cs\n│   │   ├── PrimaryKeyAttribute.cs\n│   │   ├── ForeignKeyAttribute.cs\n│   │   └── NotMappedAttribute.cs\n│   │\n│   ├── Core/\n│   │   ├── EntityBase.cs\n│   │   ├── EntityState.cs\n│   │   ├── EntityMapper.cs\n│   │   ├── EntityMetadata.cs\n│   │   ├── PropertyMetadata.cs\n│   │   └── DbContext.cs\n│   │\n│   ├── Connection/\n│   │   ├── IDbConnectionFactory.cs\n│   │   ├── SqlConnectionFactory.cs\n│   │   └── SqliteConnectionFactory.cs\n│   │\n│   ├── Query/\n│   │   ├── QueryParameter.cs\n│   │   ├── SqlQueryBuilder.cs\n│   │   ├── InsertQueryBuilder.cs\n│   │   ├── UpdateQueryBuilder.cs\n│   │   ├── DeleteQueryBuilder.cs\n│   │   └── ExpressionParser.cs\n│   │\n│   ├── Repository/\n│   │   ├── IRepository.cs\n│   │   └── Repository.cs\n│   │\n│   ├── UnitOfWork/\n│   │   ├── IUnitOfWork.cs\n│   │   ├── UnitOfWork.cs\n│   │   ├── ChangeTracker.cs\n│   │   ├── EntityEntry.cs\n│   │   └── TrackedRepository.cs\n│   │\n│   ├── Loading/\n│   │   ├── LazyLoader.cs\n│   │   └── EagerLoader.cs\n│   │\n│   └── Performance/\n│       ├── BulkOperations.cs\n│       ├── ConnectionPool.cs\n│       ├── QueryCache.cs\n│       └── CompiledExpressionCache.cs\n│\n├── MiniORM.Tests/\n│   ├── EntityMetadataTests.cs\n│   ├── SqlQueryBuilderTests.cs\n│   ├── InsertUpdateDeleteQueryBuilderTests.cs\n│   ├── ExpressionParserTests.cs\n│   ├── ChangeTrackerTests.cs\n│   ├── RepositoryTests.cs\n│   └── IntegrationTests.cs\n│\n└── MiniORM.Demo/\n    ├── Entities/\n    │   ├── Author.cs\n    │   ├── Book.cs\n    │   └── Category.cs\n    ├── DatabaseSetup.cs\n    └── Program.cs\n```\n\n---\n\n## 18. Key Learning Points\n\n### C# Features Used\n\n| Feature | Location | Purpose |\n|---------|----------|---------|\n| **Generics** | Repository<T>, EntityMapper | Type-safe data access |\n| **Attributes** | Custom attributes | Metadata mapping |\n| **Reflection** | EntityMetadata | Runtime type inspection |\n| **Expression Trees** | ExpressionParser | LINQ-to-SQL translation |\n| **Extension Methods** | Various utilities | Fluent API |\n| **Async/Await** | Repository async methods | Non-blocking I/O |\n| **Records** (C# 9+) | QueryParameter | Immutable data |\n| **Pattern Matching** | Switch expressions | Type dispatch |\n| **Nullable Reference Types** | Throughout | Null safety |\n| **CallerMemberName** | EntityBase | Automatic property names |\n| **ConcurrentDictionary** | Caching | Thread-safe caching |\n\n### Best Practices Demonstrated\n\n1. **Separation of Concerns** - Each class has a single responsibility\n2. **Dependency Injection** - Dependencies passed through constructors\n3. **Interface Segregation** - Small, focused interfaces\n4. **Open/Closed Principle** - Extensible without modification\n5. **DRY (Don't Repeat Yourself)** - Shared logic in base classes\n6. **Defensive Programming** - Null checks, validation\n7. **Resource Management** - Proper IDisposable implementation\n8. **Thread Safety** - ConcurrentDictionary, locks where needed\n\n---\n\n## Conclusion\n\nCongratulations! You've built a fully functional ORM that demonstrates:\n\n- ✅ **10+ Design Patterns** in practical use\n- ✅ **Advanced C# features** (generics, reflection, expressions)\n- ✅ **Enterprise patterns** (Repository, Unit of Work)\n- ✅ **Performance optimizations** (caching, bulk operations)\n- ✅ **Comprehensive testing** (unit and integration tests)\n\nThis project provides an excellent foundation for understanding:\n- How ORMs like Entity Framework work internally\n- When and how to apply design patterns\n- Building maintainable, testable C# applications\n\nFeel free to extend this ORM with additional features like:\n- Migrations support\n- Stored procedure mapping\n- More complex relationship handling (many-to-many)\n- Query result projections\n- Database-specific optimizations",
                    "images": [],
                    "tokenCount": 3347,
                    "model": "claude-opus-4-5-20251101",
                    "isPicked": true,
                    "responseFeedback": {
                        "thumbsFeedback": "None",
                        "feedbackTags": []
                    },
                    "thinkingContent": {
                        "thinking": "The user wants me to continue the C# ORM tutorial. I was in the middle of the Demo Caching section of the Program.cs file. Let me continue from where I left off.",
                        "signature": "EsoCCkYIChgCKkATHIUp1JhyvAq//RpNMUF67QJgiwONU3Qf+p5LMkC00z9lZRnMmlFwGqYCQZn1NLM3lMhhBIlJ+ywKWpg/whU3EgyXWUaAB39GhlGn5/oaDJoyoRUrI37XzWaJqSIwDDd+Y6X//aCLO01g3dOj9xW/K2ev1l+v5R+tH1KtnT4yd0/s9j6YHpqR4wi9+ivOKrEBz7TcERMM1R3yJ4hc0FFoh5vX4kg2c2XVYgaGdsNAqeYqOFI0b+xvDMMZwtYrW4UEnAuq9d1ipK6f+wUwnPZ6dMoVgd4LjyP8ivR8j0OVeOga3BYx1cuzLOnI8GNhEO+4YVkTZHBWPCDZ1Pys4C9582r+EhMRvrq5hQYS7mHlCTTwMJJwRbnYV9aqHhNakQUR5+vV7BY/k9EzOYwnUfV0KOLRfPd97xUFj4UYCWVQhtzSGAE="
                    },
                    "webSources": []
                }
            ],
            "requestedModel": "claude-opus-4-5-20251101",
            "requestedModelWithSpec": {
                "model": "claude-opus-4-5-20251101",
                "enableThinking": true
            },
            "type": "Text",
            "isBattle": false,
            "isEval": false,
            "systemMessage": "You are a helpful chat assistant. You are part of a product called the Model Playground, in which users can chat with various models from leading LLM providers in the Generative AI space. The Model Playground is a perk for contributors on Outlier, a platform that connects subject matter experts to help build the world's most advanced Generative AI.",
            "costDollars": 0.1740965,
            "nodeIdx": 14,
            "parentIdx": 13,
            "childrenIdxs": [],
            "createdAt": "2025-12-04T18:27:48.548Z",
            "updatedAt": "2025-12-04T18:27:48.549Z"
        }
    ],
    "startTurnIdxs": [
        0
    ]
}